{"componentChunkName":"component---src-templates-post-jsx","path":"/serialization/","result":{"data":{"site":{"siteMetadata":{"title":"ppeper🥤"}},"markdownRemark":{"id":"770fa80e-3899-50bc-a219-6f0a4abde7eb","excerpt":"서버에서 REST API를 구현하여 데이터를 다룰때는 Json 데이터 형태로 많이 다루게 된다. 안드로이드에서 서버의 데이터를 받아올때 편리하게  라이브러리를 활용하여 객체-Json 간의 Converter 작업을 하였었다. 이번에 구글 프로젝트를 보면서 새로운 직렬화/역직렬화를 다룰 수 있는 라이브러리를 보려고 한다. Kotlin의 Default Valu…","html":"<p>서버에서 REST API를 구현하여 데이터를 다룰때는 Json 데이터 형태로 많이 다루게 된다. 안드로이드에서 서버의 데이터를 받아올때 편리하게 <code class=\"language-text\">Gson</code> 라이브러리를 활용하여 객체-Json 간의 Converter 작업을 하였었다. 이번에 구글 프로젝트를 보면서 새로운 직렬화/역직렬화를 다룰 수 있는 라이브러리를 보려고 한다.</p>\n<h1>Kotlin의 Default Value</h1>\n<p>Gson으로도 데이터의 직렬화(역직렬화)를 할 수 있지만 코틀린의 데이터 클래스에서 Dafault Value를 사용하고 있다면 자바로 되어있는 Gson에서는 해당 기능을 제공하지 않기 때문에 NPE 가능성이 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">data</span> <span class=\"token keyword\">class</span> <span class=\"token function\">User</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">val</span> name<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> gender<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> age<span class=\"token operator\">:</span> Int <span class=\"token operator\">=</span> <span class=\"token number\">28</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> hobby<span class=\"token operator\">:</span> String <span class=\"token operator\">=</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"Work out\"</span></span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">val</span> jsonString <span class=\"token operator\">=</span> <span class=\"token string-literal multiline\"><span class=\"token string\">\"\"\"\n    {\n        \"name\" : \"ppeper\",\n        \"gender\" : \"Male\"\n    } \n\"\"\"</span></span><span class=\"token punctuation\">.</span><span class=\"token function\">trimIndent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> user <span class=\"token operator\">=</span> <span class=\"token function\">Gson</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">fromJson</span><span class=\"token punctuation\">(</span>jsonString<span class=\"token punctuation\">,</span> User<span class=\"token operator\">::</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">.</span>java<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p>User(name=ppeper, gender=Male, age=0, hobby=null)</p>\n</blockquote>\n<p>age의 값과 hoppy의 값에 Default value가 있지만 Primitive type의 경우 0, Reference type의 경우 null로 나오는 것을 볼 수 있다.   코틀린에서는 Null-Safety 를 통해 hobby가 Not-Null type이지만 null이 들어있어 개발시에 잘못한다면 NPE가 발생할 수 있다.</p>\n<h1>Kotlinx Serialization</h1>\n<p>코틀린에서 공식적으로 제공하고 있는 <strong>Kotlinx Serialization</strong> 라이브러리를 통해 직렬화/역직렬화를 사용할 수 있다. Kotlin에서 사용하면 위와 같은 Default value의 상황에서도 정상적으로 값을 보여줄 수 있으며 다른 Converter들과 다르게 Reflection을 사용하지 않고 KSerializer을 사용한다.</p>\n<p>사용하는 방법은 변환하고자하는 Class에 <code class=\"language-text\">@Serializable</code> 어노테이션만 추가해 주면 된다.\n이 어노테이션을 추가하면 플러그인이 자동으로 해당하는 클래스의 companion object에 <code class=\"language-text\">serializer()</code> 함수를 생성하여 사용할 수 있게 해준다. 이 함수는 <strong>KSerializer</strong> 타입의 객체를 반환하여 직렬화할때 사용된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\">plugins <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">kotlin</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"plugin.serialization\"</span></span><span class=\"token punctuation\">)</span> version <span class=\"token string-literal singleline\"><span class=\"token string\">\"1.9.22\"</span></span>\n<span class=\"token punctuation\">}</span>\n\ndependencies <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">implementation</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"org.jetbrains.kotlinx:kotlinx-serialization-json:</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">latest_version</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation builtin\">@Serializable</span>\n<span class=\"token keyword\">data</span> <span class=\"token keyword\">class</span> <span class=\"token function\">User</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">val</span> name<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> gender<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> age<span class=\"token operator\">:</span> Int <span class=\"token operator\">=</span> <span class=\"token number\">28</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> hobby<span class=\"token operator\">:</span> String <span class=\"token operator\">=</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"Work out\"</span></span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">val</span> jsonString <span class=\"token operator\">=</span> <span class=\"token string-literal multiline\"><span class=\"token string\">\"\"\"\n    {\n        \"name\" : \"ppeper\",\n        \"gender\" : \"Male\"\n    } \n\"\"\"</span></span><span class=\"token punctuation\">.</span><span class=\"token function\">trimIndent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> user <span class=\"token operator\">=</span> Json<span class=\"token punctuation\">.</span>decodeFromString<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>jsonString<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p>User(name=ppeper, gender=Male, age=28, hobby=Work out)</p>\n</blockquote>\n<p>Default Value를 설정한 프로퍼티 값들이 성공적으로 출력되는 것을 볼 수 있다. kotlinx.serialization에서 Json 관련한 여러 옵션추가하여 입맛에 맞게 사용이 가능하다.</p>\n<h2>ignoreKnownKeys</h2>\n<p>보통 Model로 다시 파싱을 할때 Json에 있는 Key값과 Model의 멤버 변수와 mapping이 되어햐 한다. 이때 Json에 있는 Key 값이 Model에 없을 때 이를 무시할 수 있는 <code class=\"language-text\">ignoreKnwonKeys</code> 옵션을 설정해 놓으면 Model에서 있는 멤버 변수의 값들만 파싱이 된다.</p>\n<p>해당 옵션을 사용하지 않으면 Exception을 통해 알지 못하는 값을 출력해준다.</p>\n<blockquote>\n<p>Exception in thread \"main\" kotlinx.serialization.json.internal.JsonDecodingException: Unexpected JSON token at offset 53: Encountered an unknown key 'id' at path: $.gender\nUse 'ignoreUnknownKeys = true' in 'Json {}' builder to ignore unknown keys.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> jsonString <span class=\"token operator\">=</span> <span class=\"token string-literal multiline\"><span class=\"token string\">\"\"\"\n    {\n        \"name\" : \"ppeper\",\n        \"gender\" : \"Male\",\n        \"id\" : \"1\"\n    } \n\"\"\"</span></span><span class=\"token punctuation\">.</span><span class=\"token function\">trimIndent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">val</span> json <span class=\"token operator\">=</span> Json <span class=\"token punctuation\">{</span> ignoreUnknownKeys <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> decodeToString <span class=\"token operator\">=</span> json<span class=\"token punctuation\">.</span>decodeFromString<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>jsonString<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>decodeToString<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p>User(name=ppeper, gender=Male, age=28, hobby=Work out)</p>\n</blockquote>\n<p> 이외에도 공식 <a href=\"https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/builtin-classes.md#enum-classes\">Kotlin Serialization</a>을 보면 직렬화 대상 Model의 멤버 변수에 다양한 어노테이션을 활용할 수 있다. 또한 안드로이드에서 Retrofit을 사용하고 있다면 이를위한 <a href=\"https://github.com/JakeWharton/retrofit2-kotlinx-serialization-converter\">Converter</a>도 현재 제공하고 있다.</p>\n<hr>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://kotlinlang.org/docs/serialization.html#what-s-next\">https://kotlinlang.org/docs/serialization.html#what-s-next</a></li>\n<li><a href=\"https://github.com/google/gson\">https://github.com/google/gson</a></li>\n</ul>","frontmatter":{"title":"코틑린을 위한 Kotlinx Serizalization","date":"March 07, 2024","update":"March 07, 2024","tags":["Kotlin","Serizalization"],"series":"Kotlin"},"fields":{"slug":"/serialization/","readingTime":{"minutes":4.505}}},"seriesList":{"edges":[{"node":{"id":"a7e9c7fb-11d9-59aa-b9c8-faef6cfcd27e","fields":{"slug":"/scope-function/"},"frontmatter":{"title":"코틀린의 Scope Function는 언제쓸까"}}},{"node":{"id":"995d0539-ea55-5757-b642-d423a2fef20c","fields":{"slug":"/sort/"},"frontmatter":{"title":"코틀린 리스트 정렬하는 방법 (sort vs sortBy vs sortWith)"}}},{"node":{"id":"b0b78929-653d-5d49-a7cf-79c5069f2dab","fields":{"slug":"/generic-in-out/"},"frontmatter":{"title":"Kotlin 제네릭의 in, out 키워드?"}}},{"node":{"id":"33959bf6-d080-5100-ac93-0be970a5d159","fields":{"slug":"/flow/"},"frontmatter":{"title":"Kotlin Coroutines Flow 맛보기"}}},{"node":{"id":"770fa80e-3899-50bc-a219-6f0a4abde7eb","fields":{"slug":"/serialization/"},"frontmatter":{"title":"코틑린을 위한 Kotlinx Serizalization"}}},{"node":{"id":"1da09158-79bc-54c5-8886-5cf392f4154f","fields":{"slug":"/ktor/"},"frontmatter":{"title":"KMP를 지원하는 Ktor Client를 사용해보자"}}}]},"previous":{"fields":{"slug":"/goodbye-2023/"},"frontmatter":{"title":"2023년 한해 회고록"}},"next":{"fields":{"slug":"/compose-theme/"},"frontmatter":{"title":"Compose 나만의 Custom Theme 설정하기"}}},"pageContext":{"id":"770fa80e-3899-50bc-a219-6f0a4abde7eb","series":"Kotlin","previousPostId":"3cbf6d19-48fa-5a8b-b1ef-bc34487fb600","nextPostId":"9d857459-0fd2-5d37-8f39-eceec94e02b2"}},"staticQueryHashes":[],"slicesMap":{}}