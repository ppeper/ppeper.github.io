{"componentChunkName":"component---src-templates-post-jsx","path":"/greedy/","result":{"data":{"site":{"siteMetadata":{"title":"ppeper🥤"}},"markdownRemark":{"id":"052ebb4e-897f-5992-bab6-cd7e92036341","excerpt":"그리디(탐욕) 알고리즘에서 그리디(탐욕법) 알고리즘이란 이름에서 유추해 볼 수 있듯이 현재 상황에서 가장 최선의 선택 을 하는 알고리즘을 말한다. 매 순간마다 하는 선택은 그 순간에 대해 으로는 최적이지만, 그 선택들을 계속 수집하여 최종적()인 해답을 만들었다고 해서, 그것이 최적의 해답이라는 보장은 없다.  하지만 그리디 알고리즘을 적용할수 있는 문제…","html":"<p align='center'><img src='https://user-images.githubusercontent.com/63226023/164942840-d52e6623-5973-4c16-99ef-3da83ce1e9ab.png'></p>\n<hr>\n<h1 id=\"그리디탐욕\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%A6%AC%EB%94%94%ED%83%90%EC%9A%95\" aria-label=\"그리디탐욕 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>그리디(탐욕)</h1>\n<p>알고리즘에서 그리디(탐욕법) 알고리즘이란 이름에서 유추해 볼 수 있듯이 <strong>현재 상황에서 가장 최선의 선택</strong> 을 하는 알고리즘을 말한다.</p>\n<p>매 순간마다 하는 선택은 그 순간에 대해 <code class=\"language-text\">지역적</code>으로는 최적이지만, 그 선택들을 계속 수집하여 최종적(<code class=\"language-text\">전역적</code>)인 해답을 만들었다고 해서, 그것이 최적의 해답이라는 보장은 없다. </p>\n<p>하지만 그리디 알고리즘을 적용할수 있는 문제들은 <code class=\"language-text\">지역적</code>으로 최적이면 <code class=\"language-text\">전역적</code>으로 최적인 문제들이다. </p>\n<hr>\n<h1 id=\"어떤-경우에-잘-작동하는가\" style=\"position:relative;\"><a href=\"#%EC%96%B4%EB%96%A4-%EA%B2%BD%EC%9A%B0%EC%97%90-%EC%9E%98-%EC%9E%91%EB%8F%99%ED%95%98%EB%8A%94%EA%B0%80\" aria-label=\"어떤 경우에 잘 작동하는가 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>어떤 경우에 잘 작동하는가?</h1>\n<blockquote>\n<p>🎯그리디 알고리즘이 적용되기 위해서는 아래와 같은 조건이 만족되야 한다.</p>\n</blockquote>\n<ul>\n<li>탐욕스런 선택 조건</li>\n<li>최적 부분 구조 조건</li>\n</ul>\n<blockquote>\n<p>📍탐욕스런 선택 조건(greedy choice property)은 <strong>앞의 선택이 이후의 선택에 영향을 주지 않는다</strong> 는 것이다.</p>\n<p>📍최적 부분 구조 조건(optional substructure)은 <strong>문제에 대한 최적해</strong> 가 <strong>부분 문제에 대해서도 최적해라는 것</strong> 이다.</p>\n</blockquote>\n<hr>\n<h1 id=\"거스름돈-문제\" style=\"position:relative;\"><a href=\"#%EA%B1%B0%EC%8A%A4%EB%A6%84%EB%8F%88-%EB%AC%B8%EC%A0%9C\" aria-label=\"거스름돈 문제 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>거스름돈 문제🪙</h1>\n<p>그리디 문제중에서 거스름돈 문제가 있다. 어떤 금액에 대해 거스름돈을 받을때, 동전을 최소의 개수로 받는 문제이다.</p>\n<p>단, 거스름돈 문제가 항상 <strong>그리디 알고리즘</strong> 으로 해결되는 것은 아니다.<br>\n우리의 실생활에서의 동전은 10, 50, 100, 500원 이 있지만, 문제에서 다음과 같이 냈다고 하자.</p>\n<blockquote>\n<p>거스름돈 14원을 주려고한다. 동전은 1, 6, 10원이 있다고하자.</p>\n</blockquote>\n<p>위의 문제를 그리디 알고리즘을 적용하면 <strong>가장 큰 단위의 동전을 선택하여 거스롬든을 주자</strong> 로 생각해 볼 수 있고 구하는 해는 10원, 1원 * 4 -> 5가지가 된다. 반면에 최소의 개수는 6원 * 2, 1원 * 2 -> 4가지이다.</p>\n<p>이 거스름돈 문제가 그리디 알고리즘이 적용되기 위해서는 <strong>각각의 거스름돈이 서로의 배수/약수의 관계</strong> 가 되어야 한다. 따라서 실생활에 사용되는 동전으로 이루어진 거스름돈 문제는 그리디 알고리즘이 적용이 가능하다.</p>\n<blockquote>\n<p>(500원 = 100원 5개, 100원 = 50원 2개, 50원 = 10원 5개) -> 작은 단위 동전을 조합하여 다른 해가 나올 수 없기 때문에 그리디 알고리즘 사용이 가능하다.</p>\n</blockquote>\n<p>이렇게 그리디 알고리즘을 적용하기 위해서는 문제의 요구사항을 파악하고 위에서 적용되는 조건을 확인하는것이 중요하다.🤔</p>\n<hr>\n<h1 id=\"References\" style=\"position:relative;\"><a href=\"#References\" aria-label=\"References permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>References</h1>\n<ul>\n<li><a href=\"https://ko.wikipedia.org/wiki/%ED%83%90%EC%9A%95_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">https://ko.wikipedia.org/wiki/탐욕_알고리즘</a></li>\n<li><a href=\"https://ujink.tistory.com/10\">https://ujink.tistory.com/10</a></li>\n</ul>","frontmatter":{"title":"그리디 알고리즘(Greedy Algorithm)에 대해","date":"April 24, 2022","update":"April 24, 2022","tags":["Algorithm","Greedy"],"series":"Algorithm"},"fields":{"slug":"/greedy/","readingTime":{"minutes":3.745}}},"seriesList":{"edges":[{"node":{"id":"f95fc217-b9c9-5985-943d-f6db2fd56a30","fields":{"slug":"/programmers-tips-town/"},"frontmatter":{"title":"프로그래머스 2017 팁스타운 - 짝지어 제거하기"}}},{"node":{"id":"de9cf818-57cf-5617-b6f9-aa87e585afa9","fields":{"slug":"/programmers-kakao-blind-2020-1/"},"frontmatter":{"title":"프로그래머스 2020 KAKAO BLIND RECRUITMENT - 괄호 변환"}}},{"node":{"id":"17ca645f-dd9f-516b-aa44-9221aa906278","fields":{"slug":"/programmers-kakao-blind-2020-2/"},"frontmatter":{"title":"프로그래머스 2022 KAKAO RECRUITMENT - 신고 결과 받기"}}},{"node":{"id":"6b276284-ed62-5856-a5e2-c4cabf52acc9","fields":{"slug":"/programmers-kakao-blind-2020-3/"},"frontmatter":{"title":"프로그래머스 2022 KAKAO RECRUITMENT - k진수에서 소수 개수 구하기"}}},{"node":{"id":"e39e5fd5-6c40-5260-b245-d291e7d62b55","fields":{"slug":"/programmers-kakao-blind-2018-1/"},"frontmatter":{"title":"프로그래머스 2018 KAKAO RECRUITMENT - [1차]캐시"}}},{"node":{"id":"243a7274-df6b-570a-8a1e-05e4f556f787","fields":{"slug":"/programmers-kakao-blind-2021-1/"},"frontmatter":{"title":"프로그래머스 2021 KAKAO BLIND RECRUITMENT - 순위 검색"}}},{"node":{"id":"7241a8e0-c224-55a5-a6b1-8136b4f2356c","fields":{"slug":"/brute-force/"},"frontmatter":{"title":"알고리즘 완전탐색(Exhaustive search)이란"}}},{"node":{"id":"052ebb4e-897f-5992-bab6-cd7e92036341","fields":{"slug":"/greedy/"},"frontmatter":{"title":"그리디 알고리즘(Greedy Algorithm)에 대해"}}},{"node":{"id":"f808b5c3-3d94-5f20-a7cc-a1441209d3e6","fields":{"slug":"/dfs-bfs/"},"frontmatter":{"title":"알고리즘 DFS/BFS 탐색 방법 알아보기"}}},{"node":{"id":"aa2be475-c199-5487-bf60-b883bea887af","fields":{"slug":"/dynamic-programming/"},"frontmatter":{"title":"알고리즘 Dynamic Programming(동적 프로그래밍) 살펴보기"}}},{"node":{"id":"459edbb5-9a63-5390-9b2e-331fa9d3d4ad","fields":{"slug":"/graph-mst/"},"frontmatter":{"title":"그래프 알고리즘이란 + 최소 신장 트리(MST)"}}},{"node":{"id":"67819626-dcdc-5ece-bab4-311c5c8f6097","fields":{"slug":"/graph-sortest-path/"},"frontmatter":{"title":"그래프 최단거리 구하기"}}}]},"previous":{"fields":{"slug":"/scope-function/"},"frontmatter":{"title":"코틀린의 Scope Function는 언제쓸까"}},"next":{"fields":{"slug":"/dfs-bfs/"},"frontmatter":{"title":"알고리즘 DFS/BFS 탐색 방법 알아보기"}}},"pageContext":{"id":"052ebb4e-897f-5992-bab6-cd7e92036341","series":"Algorithm","previousPostId":"0d63ee82-1c1d-54ac-a186-badae3a4589b","nextPostId":"f808b5c3-3d94-5f20-a7cc-a1441209d3e6"}},"staticQueryHashes":[],"slicesMap":{}}