{"componentChunkName":"component---src-templates-post-jsx","path":"/greedy/","result":{"data":{"site":{"siteMetadata":{"title":"ppeper🥤"}},"markdownRemark":{"id":"b167a775-e860-5c19-8368-765d569da317","excerpt":"그리디(탐욕) 알고리즘에서 그리디(탐욕법) 알고리즘이란 이름에서 유추해 볼 수 있듯이 현재 상황에서 가장 최선의 선택 을 하는 알고리즘을 말한다. 매 순간마다 하는 선택은 그 순간에 대해 으로는 최적이지만, 그 선택들을 계속 수집하여 최종적()인 해답을 만들었다고 해서, 그것이 최적의 해답이라는 보장은 없다.  하지만 그리디 알고리즘을 적용할수 있는 문제…","html":"<p align='center'><img src='https://user-images.githubusercontent.com/63226023/164942840-d52e6623-5973-4c16-99ef-3da83ce1e9ab.png'></p>\n<hr>\n<h1 id=\"그리디탐욕\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%A6%AC%EB%94%94%ED%83%90%EC%9A%95\" aria-label=\"그리디탐욕 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>그리디(탐욕)</h1>\n<p>알고리즘에서 그리디(탐욕법) 알고리즘이란 이름에서 유추해 볼 수 있듯이 <strong>현재 상황에서 가장 최선의 선택</strong> 을 하는 알고리즘을 말한다.</p>\n<p>매 순간마다 하는 선택은 그 순간에 대해 <code class=\"language-text\">지역적</code>으로는 최적이지만, 그 선택들을 계속 수집하여 최종적(<code class=\"language-text\">전역적</code>)인 해답을 만들었다고 해서, 그것이 최적의 해답이라는 보장은 없다. </p>\n<p>하지만 그리디 알고리즘을 적용할수 있는 문제들은 <code class=\"language-text\">지역적</code>으로 최적이면 <code class=\"language-text\">전역적</code>으로 최적인 문제들이다. </p>\n<hr>\n<h1 id=\"어떤-경우에-잘-작동하는가\" style=\"position:relative;\"><a href=\"#%EC%96%B4%EB%96%A4-%EA%B2%BD%EC%9A%B0%EC%97%90-%EC%9E%98-%EC%9E%91%EB%8F%99%ED%95%98%EB%8A%94%EA%B0%80\" aria-label=\"어떤 경우에 잘 작동하는가 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>어떤 경우에 잘 작동하는가?</h1>\n<blockquote>\n<p>🎯그리디 알고리즘이 적용되기 위해서는 아래와 같은 조건이 만족되야 한다.</p>\n</blockquote>\n<ul>\n<li>탐욕스런 선택 조건</li>\n<li>최적 부분 구조 조건</li>\n</ul>\n<blockquote>\n<p>📍탐욕스런 선택 조건(greedy choice property)은 <strong>앞의 선택이 이후의 선택에 영향을 주지 않는다</strong> 는 것이다.</p>\n<p>📍최적 부분 구조 조건(optional substructure)은 <strong>문제에 대한 최적해</strong> 가 <strong>부분 문제에 대해서도 최적해라는 것</strong> 이다.</p>\n</blockquote>\n<hr>\n<h1 id=\"거스름돈-문제\" style=\"position:relative;\"><a href=\"#%EA%B1%B0%EC%8A%A4%EB%A6%84%EB%8F%88-%EB%AC%B8%EC%A0%9C\" aria-label=\"거스름돈 문제 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>거스름돈 문제🪙</h1>\n<p>그리디 문제중에서 거스름돈 문제가 있다. 어떤 금액에 대해 거스름돈을 받을때, 동전을 최소의 개수로 받는 문제이다.</p>\n<p>단, 거스름돈 문제가 항상 <strong>그리디 알고리즘</strong> 으로 해결되는 것은 아니다.<br>\n우리의 실생활에서의 동전은 10, 50, 100, 500원 이 있지만, 문제에서 다음과 같이 냈다고 하자.</p>\n<blockquote>\n<p>거스름돈 14원을 주려고한다. 동전은 1, 6, 10원이 있다고하자.</p>\n</blockquote>\n<p>위의 문제를 그리디 알고리즘을 적용하면 <strong>가장 큰 단위의 동전을 선택하여 거스롬든을 주자</strong> 로 생각해 볼 수 있고 구하는 해는 10원, 1원 * 4 -> 5가지가 된다. 반면에 최소의 개수는 6원 * 2, 1원 * 2 -> 4가지이다.</p>\n<p>이 거스름돈 문제가 그리디 알고리즘이 적용되기 위해서는 <strong>각각의 거스름돈이 서로의 배수/약수의 관계</strong> 가 되어야 한다. 따라서 실생활에 사용되는 동전으로 이루어진 거스름돈 문제는 그리디 알고리즘이 적용이 가능하다.</p>\n<blockquote>\n<p>(500원 = 100원 5개, 100원 = 50원 2개, 50원 = 10원 5개) -> 작은 단위 동전을 조합하여 다른 해가 나올 수 없기 때문에 그리디 알고리즘 사용이 가능하다.</p>\n</blockquote>\n<p>이렇게 그리디 알고리즘을 적용하기 위해서는 문제의 요구사항을 파악하고 위에서 적용되는 조건을 확인하는것이 중요하다.🤔</p>\n<hr>\n<h1 id=\"References\" style=\"position:relative;\"><a href=\"#References\" aria-label=\"References permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>References</h1>\n<ul>\n<li><a href=\"https://ko.wikipedia.org/wiki/%ED%83%90%EC%9A%95_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">https://ko.wikipedia.org/wiki/탐욕_알고리즘</a></li>\n<li><a href=\"https://ujink.tistory.com/10\">https://ujink.tistory.com/10</a></li>\n</ul>","frontmatter":{"title":"그리디 알고리즘(Greedy Algorithm)에 대해","date":"April 24, 2022","update":"April 24, 2022","tags":["Algorithm","Greedy"],"series":"Algorithm"},"fields":{"slug":"/greedy/","readingTime":{"minutes":3.745}}},"seriesList":{"edges":[{"node":{"id":"6a88ad07-efd2-5e8e-85cb-d5bba9e8cf17","fields":{"slug":"/programmers-tips-town/"},"frontmatter":{"title":"프로그래머스 2017 팁스타운 - 짝지어 제거하기"}}},{"node":{"id":"814be3a5-2662-5037-a41b-ae3a88c11945","fields":{"slug":"/programmers-kakao-blind-2020-1/"},"frontmatter":{"title":"프로그래머스 2020 KAKAO BLIND RECRUITMENT - 괄호 변환"}}},{"node":{"id":"9235e1fe-da08-5cc6-96e9-5919bddff0fa","fields":{"slug":"/programmers-kakao-blind-2020-2/"},"frontmatter":{"title":"프로그래머스 2022 KAKAO RECRUITMENT - 신고 결과 받기"}}},{"node":{"id":"25be2350-7ca4-5657-b192-255f4ac12389","fields":{"slug":"/programmers-kakao-blind-2020-3/"},"frontmatter":{"title":"프로그래머스 2022 KAKAO RECRUITMENT - k진수에서 소수 개수 구하기"}}},{"node":{"id":"8cfe1ce4-abd0-51a5-b257-ee4b1b89dccf","fields":{"slug":"/programmers-kakao-blind-2018-1/"},"frontmatter":{"title":"프로그래머스 2018 KAKAO RECRUITMENT - [1차]캐시"}}},{"node":{"id":"5e3cc442-642e-5777-b707-5f1513b6e7fc","fields":{"slug":"/programmers-kakao-blind-2021-1/"},"frontmatter":{"title":"프로그래머스 2021 KAKAO BLIND RECRUITMENT - 순위 검색"}}},{"node":{"id":"4c2618c6-2138-584d-925b-5ad902505f6b","fields":{"slug":"/brute-force/"},"frontmatter":{"title":"알고리즘 완전탐색(Exhaustive search)이란"}}},{"node":{"id":"b167a775-e860-5c19-8368-765d569da317","fields":{"slug":"/greedy/"},"frontmatter":{"title":"그리디 알고리즘(Greedy Algorithm)에 대해"}}},{"node":{"id":"ef3315e9-7887-56c5-ab56-f0fa510d25a7","fields":{"slug":"/dfs-bfs/"},"frontmatter":{"title":"알고리즘 DFS/BFS 탐색 방법 알아보기"}}},{"node":{"id":"5bfc345a-73e4-5ba2-9ecc-2d0f7cbcc406","fields":{"slug":"/dynamic-programming/"},"frontmatter":{"title":"알고리즘 Dynamic Programming(동적 프로그래밍) 살펴보기"}}},{"node":{"id":"e6cffd30-3ac6-5a9a-8e24-0b0c55c47891","fields":{"slug":"/graph-mst/"},"frontmatter":{"title":"그래프 알고리즘이란 + 최소 신장 트리(MST)"}}},{"node":{"id":"d80bd3c0-f2e9-5a38-a7fd-21ad9685fc86","fields":{"slug":"/graph-sortest-path/"},"frontmatter":{"title":"그래프 최단거리 구하기"}}}]},"previous":{"fields":{"slug":"/scope-function/"},"frontmatter":{"title":"코틀린의 Scope Function는 언제쓸까"}},"next":{"fields":{"slug":"/dfs-bfs/"},"frontmatter":{"title":"알고리즘 DFS/BFS 탐색 방법 알아보기"}}},"pageContext":{"id":"b167a775-e860-5c19-8368-765d569da317","series":"Algorithm","previousPostId":"a7e9c7fb-11d9-59aa-b9c8-faef6cfcd27e","nextPostId":"ef3315e9-7887-56c5-ab56-f0fa510d25a7"}},"staticQueryHashes":[],"slicesMap":{}}