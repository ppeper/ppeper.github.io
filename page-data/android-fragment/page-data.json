{"componentChunkName":"component---src-templates-post-jsx","path":"/android-fragment/","result":{"data":{"site":{"siteMetadata":{"title":"ppeper🥤"}},"markdownRemark":{"id":"62ea7fd4-5557-5c1b-bced-0102a0ab8868","excerpt":"안드로이드에서 UI 화면을 태블릿과 같은 큰 화면에서 역동적이고 유연한 디자인을 하기 위하여 Fragment가 나오게 되었다. Fragment는 Activity와 마찬가지로 자체적인 생명주기를 가지지만 Activity의 생명주기에 영향을 받기 때문에 좀 더 신경쓰고 조심해야 하는 부분들이 많다. 처음 적용하고 공부하였을 때 신경쓰지 못하였던 Fragmen…","html":"<p>안드로이드에서 UI 화면을 태블릿과 같은 큰 화면에서 역동적이고 유연한 디자인을 하기 위하여 Fragment가 나오게 되었다.</p>\n<p>Fragment는 Activity와 마찬가지로 자체적인 생명주기를 가지지만 Activity의 생명주기에 영향을 받기 때문에 좀 더 신경쓰고 조심해야 하는 부분들이 많다. 처음 적용하고 공부하였을 때 신경쓰지 못하였던 Fragment의 내용을 보려고 한다. </p>\n<hr>\n<h1>Fragment LifeCycle</h1>\n<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/231318855-b5603bfb-265c-4f08-bd2d-5eb5c868cc54.png\" width=\"50%\"></p>\n<p>Fragment는 Activity와 다르게 View와 Fragment간의 LifeCycle이 다르다.</p>\n<h4>onAttach()</h4>\n<ul>\n<li>Fragment가 Activity에 붙을(Attach) 때 호출된다.</li>\n<li>아직 Fragment가 완벽하게 생성된 단계는 아니다.</li>\n</ul>\n<h4>onCreate()</h4>\n<ul>\n<li>본격적으로 Fragment가 Activity의 호출을 받아 생성되는 단계</li>\n<li>Fragment를 생성하면서 넘겨준 값들이 있다면, 이 단계에서 값을 꺼내 세팅한ㄷ.</li>\n<li>UI 초기화는 진행할 수 없다.</li>\n</ul>\n<h4>onCreateView()</h4>\n<ul>\n<li>Layout을 inflate하는 단계. 뷰바인딩을 진행한다.</li>\n<li>View가 초기화되는 중이기 때문에, UI 초기화 작업을 진행하면 충돌이 일어날 수 있다.</li>\n</ul>\n<h4>onViewCreate()</h4>\n<ul>\n<li>UI 초기화 진행</li>\n<li>onViewCreated()는 View 생성이 완료되었을 때 호출되는 메서드</li>\n</ul>\n<h4>onStart()</h4>\n<ul>\n<li>Fragment가 사용자에게 보여 지기 직전에 호출되는 단계</li>\n<li>해당 메서드가 호출되었을 때, Activity는 started 상태</li>\n</ul>\n<h4>onResume()</h4>\n<ul>\n<li>사용자와의 상호작용을 시작하는 단계</li>\n<li>특정 이벤트가 발생하여 포커스가 떠날 때까지 onResume 단계에 머무름</li>\n<li>프로그램이 일시정지되면 onPause()가 호출되고, 다시 재개되면 onResume()을 다시 호출함</li>\n<li>Resume 상태로 전환될 때마다 진행해야 되는 초기화 작업들을 세팅</li>\n</ul>\n<h4>onPause()</h4>\n<ul>\n<li>사용자가 Fragment를 떠나면 가장 먼저 onPause()를 호출</li>\n<li>Fragment가 사용자와의 상호작용을 중지하는 단계</li>\n<li>사용자가 해당 Fragment로 돌아오지 않을 수도 있으므로, 지속되어야 하는 변경사항을 onPause에서 저장</li>\n</ul>\n<h4>onStop()</h4>\n<ul>\n<li>다른 Activity가 화면을 완전히 가리거나, 화면이 더이상 보여지지 않게 되는 상황에서 호출된다.</li>\n<li>화면이 보이지 않을 때 실행할 필요가 없는 기능들을 정지시켜 줄 수 있다.</li>\n</ul>\n<h4>onDestroyView()</h4>\n<ul>\n<li>Fragment와 연결된 View Layer가 제거되는 중일 때 호출되는 단계</li>\n</ul>\n<h4>onDestroy()</h4>\n<ul>\n<li>Fragment가 제거되기 직전 단게</li>\n<li>Fragment가 생성될 때 onCreate → onCreateView 순으로 호출된 것과 달리, 파괴는 onDestroyView에서 View를 제거한 후 onDestroy가 호출된다.</li>\n</ul>\n<h2>getViewLifecycleOwner() vs getLifecycleOwner()</h2>\n<h4>LifecycleOwner</h4>\nLifecycleOwner는 __Fragment의 생명주기__ 를 가지고 있는 클래스로 `onAttach()` ~ `onDestroy()`와 연결되어 있다.\n<h4>viewLifecycleOwner</h4>\nviewLifecycleOwner는 __Fragment View의 생명주기__ 를 가지고 있는 클래스로 `onCreateView()` ~ `onDestroyView()` 와 연결되어 있다.\n<blockquote>\n<p>📍viewLifecycle은 Fragment LifeCycle 보다 생명주기가 짧다!</p>\n</blockquote>\n<p>이러한 서로 다른 생명주기에 따라 대표적으로 liveData를 사용할때 매개변수로 <code class=\"language-text\">this</code>로 넘겨주었다면 <strong>경우에 따라 Fragment가 Destroy 되지 않았지만 새로운 observer가 등록되는 경우</strong> 생길 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token comment\">// onAttach() ~ onDestroy()</span>\nliveData<span class=\"token punctuation\">.</span><span class=\"token function\">observe</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> it <span class=\"token operator\">-></span> \n  <span class=\"token comment\">// this(fragment) -> Destroy 되지 않았을 때 다시 불릴 가능성</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// onCreateView() ~ onDestroyView()</span>\nliveData<span class=\"token punctuation\">.</span><span class=\"token function\">observe</span><span class=\"token punctuation\">(</span>viewLifecycleOwner<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> it <span class=\"token operator\">-></span> \n  <span class=\"token operator\">..</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>구글에서 기본으로 제공하는 Fragment 클래스에서도 View와 Fragment의 생명주기가 달라 메모리 누수가 발생할 수 있기 때문에 이에 코드를 볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\">  <span class=\"token keyword\">private</span> <span class=\"token keyword\">var</span> _binding<span class=\"token operator\">:</span> ResultProfileBinding<span class=\"token operator\">?</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n  <span class=\"token comment\">// This property is only valid between onCreateView and</span>\n  <span class=\"token comment\">// onDestroyView.</span>\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">val</span> binding <span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> _binding<span class=\"token operator\">!!</span>\n\n  <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">onCreateView</span><span class=\"token punctuation\">(</span>\n      inflater<span class=\"token operator\">:</span> LayoutInflater<span class=\"token punctuation\">,</span>\n      container<span class=\"token operator\">:</span> ViewGroup<span class=\"token operator\">?</span><span class=\"token punctuation\">,</span>\n      savedInstanceState<span class=\"token operator\">:</span> Bundle<span class=\"token operator\">?</span>\n  <span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> View<span class=\"token operator\">?</span> <span class=\"token punctuation\">{</span>\n      _binding <span class=\"token operator\">=</span> ResultProfileBinding<span class=\"token punctuation\">.</span><span class=\"token function\">inflate</span><span class=\"token punctuation\">(</span>inflater<span class=\"token punctuation\">,</span> container<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">val</span> view <span class=\"token operator\">=</span> binding<span class=\"token punctuation\">.</span>root\n      <span class=\"token keyword\">return</span> view\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">onDestroyView</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">onDestroyView</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      _binding <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n  <span class=\"token punctuation\">}</span>  </code></pre></div>\n<p>Fragment는 제거되지 않았지만 <code class=\"language-text\">onCreateView()</code>는 다시 사용할 수 있기 때문에 명시적으로 <code class=\"language-text\">onDestroyView()</code>에서 binding에 할당을 취소해 가비지 컬렉션이 되도록 해야한다. </p>\n<hr>\n<h1>FragmentManager</h1>\n<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/231444667-211d675f-5ce3-4b11-8b55-f745849df216.png\" width=\"70%\"></p>\n<ul>\n<li>FragmentManager 속성은 호출된 Fragment 계층 구조에서 어디에 있는지에 따라 어떤 FragmentManager에 액세스하는지 다르다.</li>\n<li>FragmentManager는 Activity와 Fragment의 중간에서 서로를 이어주는 역할을 하여 Fragment Transaction 수행해 준다.</li>\n<li>FragmentManager은 백 스택(Back Stack) 에 Fragment 추가/교체/삭제 작업에 의한 변경 사항을 push 및 pop 하는 작업을 담당한다.</li>\n</ul>\n<blockquote>\n<ul>\n<li>\n<p><code class=\"language-text\">findFragmentById()</code> : Fragment 컨테이너 내의 현재 Fragment 참조</p>\n<ul>\n<li>UI를 제공하는 Fragment를 참조할 때 사용</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> fragment <span class=\"token operator\">=</span> supportFragmentManager<span class=\"token punctuation\">.</span><span class=\"token function\">findFragmentById</span><span class=\"token punctuation\">(</span>binding<span class=\"token punctuation\">.</span>fragmentContainer<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span></code></pre></div>\n<blockquote>\n<ul>\n<li><code class=\"language-text\">findFragmentByTag()</code> : Fragment에 고유한 태그를 부여한 후 태그를 이용해 Fragment 참조</li>\n</ul>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> fragment <span class=\"token operator\">=</span> supportFragmentManager<span class=\"token punctuation\">.</span><span class=\"token function\">findFragmentByTag</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"my_fragment\"</span></span><span class=\"token punctuation\">)</span></code></pre></div>\n<hr>\n<h1>Fragment Transaction</h1>\n<p>Fragment Transaction의 인스턴스는 FragmentManager의 beginTransaction() 메서드를 통해 얻을 수 있다</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> manager <span class=\"token operator\">=</span> supportFragmentManager<span class=\"token punctuation\">.</span><span class=\"token function\">beginTransaction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Android Jetpack Fragment 라이브러리에서 제공하는 클래스로 Transaction 클래스는 Fragment 추가/교체/삭제 작업을 제공한다.</p>\n<ul>\n<li>Fragment Transaction은 FragmentManager의 단일 수행 단위</li>\n<li>하나의 Fragment Transaction 단위 내에 Fragment Transaction 클래스가 제공하는 Fragment 추가/교체/삭제 작업 등을 명시하면 된다.</li>\n<li>하나의 Fragment Transaction 단위 내에 작성된 Fragment 조작 관련 작업들은 해당 Fragment Transaction 수행될 때 모두 실행된다.</li>\n</ul>\n<h2>Transaction 메소드</h2>\n<p>Fragment의 Transaction 메소드들은 <code class=\"language-text\">add()</code>, <code class=\"language-text\">replace()</code>, <code class=\"language-text\">commit()</code>, <code class=\"language-text\">commitAllowingStateloss()</code>, <code class=\"language-text\">remove()</code>, <code class=\"language-text\">addToBackStack()</code> 등이 있다.</p>\n<blockquote>\n<p><strong>add()</strong></p>\n<ul>\n<li>기존에 있던 Fragment를 지우는 것이 아니라 그 위에 다시 추가한다.</li>\n</ul>\n<p><strong>replace()</strong></p>\n<ul>\n<li>기본에 있던 Fragment를 제거한 후 새로운 Fragment를 추가한다.</li>\n</ul>\n<p><strong>remove()</strong></p>\n<ul>\n<li>기존에 있던 Fragment를 삭제한다.  </li>\n<li>fragment를 찾기 위해 <code class=\"language-text\">findFragmentById()</code>, <code class=\"language-text\">findFragmentByTag()</code> 메서드로 제거할 fragment를 찾는다</li>\n</ul>\n<p><strong>commit()</strong></p>\n<ul>\n<li>FragmentTransaction을 생성하고 Fragment의 추가/교체/삭제 작업을 명시한 후 <strong>반드시 마지막에 commit</strong> 을 해줘야 한다.</li>\n</ul>\n<p><strong>addToBackStack()</strong></p>\n<ul>\n<li>해당 메소드를 해준 후 commit()을 하게 되면 하기 전까지의 모든 변경 내용이 하나의 Transaction으로 backStack에 들어간다.</li>\n</ul>\n</blockquote>\n<h2>📌 commit() vs commitNow()</h2>\n<p>commit()에는 <code class=\"language-text\">Now</code> 가 붙은 메소드들이 있다. commit() 메서드는 <strong>비동기로 처리되는 함수</strong> 이기 때문에 commit 함수 호출 시점에 바로 Transaction이 즉시 수행되는 것이 아니라 Main Thread에 예약된다.</p>\n<p>반면에 commitNow() 메서드는 호출 시점에 즉시 해당 Fragment Transaction이 <strong>동기적으로 수행</strong> 된다.</p>\n<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/231384985-1a4605eb-ce73-454a-8a91-f1069211ce45.png\" width=\"50%\"></p>\n<blockquote>\n<p>commitNow()는 동기적으로 실행하기 때문에 <code class=\"language-text\">addToBackStack()</code> 를 통하여 백스택에 Transaction을 추가하려는 경우 프레임워크는 명령에 대한 보증을 할 수 없기 때문에 사용할 수 없다.</p>\n</blockquote>\n<h2>📌 commit() vs commitAllowingStateLoss()</h2>\n<p>Fragment를 사용을 해보았다면 <code class=\"language-text\">onSaveInstanceState()</code> 이후 commit()을 수행할 수 없다는 <code class=\"language-text\">IllegalStateException</code> 을 봤을 것이다.</p>\n<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/231441130-7a39f286-91f8-4994-bd48-2bcd813fcf59.png\"></p>\n<ul>\n<li>Fragment Transaction은 호스트 Activity가 자신의 상태(RESUMED, STOPPED 등)를 저장하기 전에 생성되고 commit 되어야 한다.</li>\n<li>\n<p>만약 호스트 Activity가 <code class=\"language-text\">onSaveInstanceState()</code> 메소드를 호출한 후에 Fragment Transaction이 commit 된다면 에러가 발생한다.</p>\n<ul>\n<li>Activity의 상태가 저장될 때 자신에서 <strong>호스팅되어 있는 Fragment의 상태도 저장</strong> 하게 되는데, <strong>이러한 상태 저장 후 Fragment Transaction에 의해 Fragment 추가/교체/삭제 작업이 일어나면 Activity가 저장한 Fragment 상태와 달라</strong> 지기 때문이다.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>📍<code class=\"language-text\">commitAllowingStateLoss()</code> 는 commit()과 거의 동일 하지만 상태와 달라질 수 있는(상태 손실)을 허용한다.</p>\n</blockquote>\n<hr>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://developer.android.com/guide/fragments?hl=ko\">https://developer.android.com/guide/fragments?hl=ko</a></li>\n<li><a href=\"https://medium.com/hongbeomi-dev/%EB%B2%88%EC%97%AD-%EB%8B%A4%EC%96%91%ED%95%9C-%EC%A2%85%EB%A5%98%EC%9D%98-commit-8f646697559f\">https://medium.com/hongbeomi-dev/%EB%B2%88%EC%97%AD-%EB%8B%A4%EC%96%91%ED%95%9C-%EC%A2%85%EB%A5%98%EC%9D%98-commit-8f646697559f</a></li>\n</ul>","frontmatter":{"title":"안드로이드 Fragment 조각내기","date":"April 12, 2023","update":"April 12, 2023","tags":["Android","FragmentTransaction","Fragment"],"series":"Android"},"fields":{"slug":"/android-fragment/","readingTime":{"minutes":9.535}}},"seriesList":{"edges":[{"node":{"id":"ec35f26c-1e41-5966-85a5-26fa93fb5998","fields":{"slug":"/android-start/"},"frontmatter":{"title":"첫 안드로이드 개발에 대한 회고"}}},{"node":{"id":"f0d5a7a2-4729-582b-85a5-b78dd0643477","fields":{"slug":"/lifecycle/"},"frontmatter":{"title":"안드로이드 Lifecycle 제대로 알기"}}},{"node":{"id":"c38cf2b3-111e-5e83-8623-c323546b3596","fields":{"slug":"/fragment/"},"frontmatter":{"title":"안드로이드 Fragment 사용"}}},{"node":{"id":"d0d74ae8-e541-598a-a0c8-30dbf6d27c14","fields":{"slug":"/intent/"},"frontmatter":{"title":"안드로이드 인텐트의 개념"}}},{"node":{"id":"7fddf3e0-5c6a-5813-b716-8b9348184adb","fields":{"slug":"/android-context/"},"frontmatter":{"title":"안드로이드 Context의 개념"}}},{"node":{"id":"da53b090-256e-5185-877e-1c63d36292dd","fields":{"slug":"/recyclerview/"},"frontmatter":{"title":"안드로이드 4대 컴포넌트란"}}},{"node":{"id":"76b96463-5dc0-5bce-9411-653b728c0d07","fields":{"slug":"/broadcast/"},"frontmatter":{"title":"안드로이드 브로드캐스트(Broadcast)"}}},{"node":{"id":"31f9951e-cfe2-5831-9791-bdd8a3f321f2","fields":{"slug":"/android-service/"},"frontmatter":{"title":"안드로이드 서비스(Service) 개요"}}},{"node":{"id":"9f0c308a-f26f-5882-b1c0-603d65208794","fields":{"slug":"/pendingintent/"},"frontmatter":{"title":"안드로이드 PendingIntent의 개념"}}},{"node":{"id":"6d7acb66-c296-5cb4-a56d-a6141652ba03","fields":{"slug":"/notification/"},"frontmatter":{"title":"안드로이드 알림(Notification) 만들기"}}},{"node":{"id":"dd38b1c0-3bb7-5d67-9871-c8a997f7665a","fields":{"slug":"/android-jetpack/"},"frontmatter":{"title":"안드로이드 Jetpack에 대해"}}},{"node":{"id":"4ae3792b-61e4-502c-997f-ea92464eb538","fields":{"slug":"/android-acc/"},"frontmatter":{"title":"안드로이드 MVVM 패턴과 ACC 알아보기"}}},{"node":{"id":"07f0687c-2335-5ce9-adbf-a9e3fdcdb964","fields":{"slug":"/viewmodel/"},"frontmatter":{"title":"안드로이드 Jetpack의 ViewModel 사용해보기"}}},{"node":{"id":"08c0cd05-8fe6-5461-8c79-629efa4d3099","fields":{"slug":"/livedata/"},"frontmatter":{"title":"안드로이드 Jetpack의 LiveData 적용하기"}}},{"node":{"id":"cd2c8fe7-7aa9-53d0-a66c-0157b8f0fdb5","fields":{"slug":"/databinding/"},"frontmatter":{"title":"안드로이드 DataBinding + LiveData 적용하기"}}},{"node":{"id":"567749b8-f03e-5f18-bf62-021e32de6506","fields":{"slug":"/coroutine/"},"frontmatter":{"title":"안드로이드 코루틴의 기초 알아보기"}}},{"node":{"id":"92a49d11-9d7c-5fc9-b5f7-9575ee1886ea","fields":{"slug":"/room-database/"},"frontmatter":{"title":"안드로이드 Room 사용하면서 알아보기"}}},{"node":{"id":"9b4e8bd5-b184-5972-b687-b5a509707a35","fields":{"slug":"/android-dagger2/"},"frontmatter":{"title":"안드로이드 Dagger2 맛보기"}}},{"node":{"id":"f3e41032-8577-5a04-bb96-62be1e0aaf4b","fields":{"slug":"/android-dagger2-more/"},"frontmatter":{"title":"안드로이드 Dagger2 좀 더 알아가기"}}},{"node":{"id":"5eb7df8d-a6a9-5e6c-a6a8-9e79a03cf5e8","fields":{"slug":"/android-hilt/"},"frontmatter":{"title":"안드로이드 Hilt에 대해 알아보기"}}},{"node":{"id":"c20926f6-1320-5a8c-9f4a-59e5892e6350","fields":{"slug":"/repository-pattern/"},"frontmatter":{"title":"안드로이드 Repository 패턴은 무엇인가"}}},{"node":{"id":"2469d97d-f2b6-544e-8ef9-20003ce2bd82","fields":{"slug":"/datastore/"},"frontmatter":{"title":"새로운 동료 DataStore 알아보기"}}},{"node":{"id":"388b7df4-d323-53ac-80ff-f4ad265a6077","fields":{"slug":"/android-diffutil/"},"frontmatter":{"title":"안드로이드 RecyclerView의 DiffUtil 알아보기"}}},{"node":{"id":"b3372752-9e81-5642-ae8e-179f5c6bc152","fields":{"slug":"/viewpager2/"},"frontmatter":{"title":"안드로이드 ViewPager2 사용기"}}},{"node":{"id":"6a3accf7-a0c8-5423-ab54-e336ed105d22","fields":{"slug":"/runOnUiThread/"},"frontmatter":{"title":"안드로이드 runOnUiThread?"}}},{"node":{"id":"5c4802cf-c4a3-5fde-9cde-044d3bf41c70","fields":{"slug":"/android-launcher/"},"frontmatter":{"title":"안드로이드에서 Launcher를 통한 결과 전달"}}},{"node":{"id":"1dde30d6-b5f2-5e8e-bed9-9b829ed73a22","fields":{"slug":"/android-menu/"},"frontmatter":{"title":"안드로이드 다양한 Menu들 사용하기"}}},{"node":{"id":"1247175f-4af3-5f8d-a78f-eddc0317b772","fields":{"slug":"/android-sqlite/"},"frontmatter":{"title":"안드로이드 내부 데이터 저장 SQLite"}}},{"node":{"id":"bf5f92c9-bce8-53e1-825f-5030efe6622a","fields":{"slug":"/android-permission/"},"frontmatter":{"title":"안드로이드 Permission 가져오기"}}},{"node":{"id":"02142718-5257-5488-b9d7-ce45ff8471b1","fields":{"slug":"/android-local-service/"},"frontmatter":{"title":"안드로이드 Local Service 알아보기"}}},{"node":{"id":"62ea7fd4-5557-5c1b-bced-0102a0ab8868","fields":{"slug":"/android-fragment/"},"frontmatter":{"title":"안드로이드 Fragment 조각내기"}}},{"node":{"id":"33da29ed-8ac4-5c3f-b024-3159e1da22b9","fields":{"slug":"/livedata-transform/"},"frontmatter":{"title":"안드로이드 MediatorLiveData와 Transformations"}}},{"node":{"id":"844abb8c-db3f-5c7a-b213-af7e4184750c","fields":{"slug":"/android-navigation/"},"frontmatter":{"title":"안드로이드 Navigation 사용하기"}}},{"node":{"id":"296e6b82-b35b-537d-a5a5-48d5d053235c","fields":{"slug":"/compose-start/"},"frontmatter":{"title":"안드로이드 Compose 알아보기"}}},{"node":{"id":"ac09eecc-30b4-525e-b40f-524fcc4dacc3","fields":{"slug":"/compose-lifecycle/"},"frontmatter":{"title":"안드로이드 Compose 수명 주기"}}},{"node":{"id":"8ecadfc1-855e-53a0-97cc-6594b192981b","fields":{"slug":"/compose-state-hoisting/"},"frontmatter":{"title":"안드로이드 Compose 상태 호이스팅"}}},{"node":{"id":"43f4b29f-ed51-5fc0-bf47-a7bdb00ae9d8","fields":{"slug":"/compose-side-effect/"},"frontmatter":{"title":"안드로이드 Side Effect란?"}}},{"node":{"id":"5bf017e2-3f6c-5f8a-b348-2b3586279023","fields":{"slug":"/android-version-catalog/"},"frontmatter":{"title":"안드로이드 Version Catalog 도입하기"}}},{"node":{"id":"d8ca9764-c28e-5491-b2d6-0f1fe3814612","fields":{"slug":"/android-webview/"},"frontmatter":{"title":"안드로이드 WebView로 웹과 놀기"}}},{"node":{"id":"9d857459-0fd2-5d37-8f39-eceec94e02b2","fields":{"slug":"/compose-theme/"},"frontmatter":{"title":"Compose 나만의 Custom Theme 설정하기"}}},{"node":{"id":"a483c66e-f6c8-5ab3-ad60-d36392c1e724","fields":{"slug":"/compose-bezier/"},"frontmatter":{"title":"Compose에서 Bezier 곡선으로 스쿼클 만들기"}}}]},"previous":{"fields":{"slug":"/android-local-service/"},"frontmatter":{"title":"안드로이드 Local Service 알아보기"}},"next":{"fields":{"slug":"/livedata-transform/"},"frontmatter":{"title":"안드로이드 MediatorLiveData와 Transformations"}}},"pageContext":{"id":"62ea7fd4-5557-5c1b-bced-0102a0ab8868","series":"Android","previousPostId":"02142718-5257-5488-b9d7-ce45ff8471b1","nextPostId":"33da29ed-8ac4-5c3f-b024-3159e1da22b9"}},"staticQueryHashes":[],"slicesMap":{}}