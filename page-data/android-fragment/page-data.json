{"componentChunkName":"component---src-templates-post-jsx","path":"/android-fragment/","result":{"data":{"site":{"siteMetadata":{"title":"ppeper🥤"}},"markdownRemark":{"id":"c3641eee-48c5-5870-a5d1-26d1401311e7","excerpt":"안드로이드에서 UI 화면을 태블릿과 같은 큰 화면에서 역동적이고 유연한 디자인을 하기 위하여 Fragment가 나오게 되었다. Fragment는 Activity와 마찬가지로 자체적인 생명주기를 가지지만 Activity의 생명주기에 영향을 받기 때문에 좀 더 신경쓰고 조심해야 하는 부분들이 많다. 처음 적용하고 공부하였을 때 신경쓰지 못하였던 Fragmen…","html":"<p>안드로이드에서 UI 화면을 태블릿과 같은 큰 화면에서 역동적이고 유연한 디자인을 하기 위하여 Fragment가 나오게 되었다.</p>\n<p>Fragment는 Activity와 마찬가지로 자체적인 생명주기를 가지지만 Activity의 생명주기에 영향을 받기 때문에 좀 더 신경쓰고 조심해야 하는 부분들이 많다. 처음 적용하고 공부하였을 때 신경쓰지 못하였던 Fragment의 내용을 보려고 한다. </p>\n<hr>\n<h1>Fragment LifeCycle</h1>\n<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/231318855-b5603bfb-265c-4f08-bd2d-5eb5c868cc54.png\" width=\"50%\"></p>\n<p>Fragment는 Activity와 다르게 View와 Fragment간의 LifeCycle이 다르다.</p>\n<h4>onAttach()</h4>\n<ul>\n<li>Fragment가 Activity에 붙을(Attach) 때 호출된다.</li>\n<li>아직 Fragment가 완벽하게 생성된 단계는 아니다.</li>\n</ul>\n<h4>onCreate()</h4>\n<ul>\n<li>본격적으로 Fragment가 Activity의 호출을 받아 생성되는 단계</li>\n<li>Fragment를 생성하면서 넘겨준 값들이 있다면, 이 단계에서 값을 꺼내 세팅한ㄷ.</li>\n<li>UI 초기화는 진행할 수 없다.</li>\n</ul>\n<h4>onCreateView()</h4>\n<ul>\n<li>Layout을 inflate하는 단계. 뷰바인딩을 진행한다.</li>\n<li>View가 초기화되는 중이기 때문에, UI 초기화 작업을 진행하면 충돌이 일어날 수 있다.</li>\n</ul>\n<h4>onViewCreate()</h4>\n<ul>\n<li>UI 초기화 진행</li>\n<li>onViewCreated()는 View 생성이 완료되었을 때 호출되는 메서드</li>\n</ul>\n<h4>onStart()</h4>\n<ul>\n<li>Fragment가 사용자에게 보여 지기 직전에 호출되는 단계</li>\n<li>해당 메서드가 호출되었을 때, Activity는 started 상태</li>\n</ul>\n<h4>onResume()</h4>\n<ul>\n<li>사용자와의 상호작용을 시작하는 단계</li>\n<li>특정 이벤트가 발생하여 포커스가 떠날 때까지 onResume 단계에 머무름</li>\n<li>프로그램이 일시정지되면 onPause()가 호출되고, 다시 재개되면 onResume()을 다시 호출함</li>\n<li>Resume 상태로 전환될 때마다 진행해야 되는 초기화 작업들을 세팅</li>\n</ul>\n<h4>onPause()</h4>\n<ul>\n<li>사용자가 Fragment를 떠나면 가장 먼저 onPause()를 호출</li>\n<li>Fragment가 사용자와의 상호작용을 중지하는 단계</li>\n<li>사용자가 해당 Fragment로 돌아오지 않을 수도 있으므로, 지속되어야 하는 변경사항을 onPause에서 저장</li>\n</ul>\n<h4>onStop()</h4>\n<ul>\n<li>다른 Activity가 화면을 완전히 가리거나, 화면이 더이상 보여지지 않게 되는 상황에서 호출된다.</li>\n<li>화면이 보이지 않을 때 실행할 필요가 없는 기능들을 정지시켜 줄 수 있다.</li>\n</ul>\n<h4>onDestroyView()</h4>\n<ul>\n<li>Fragment와 연결된 View Layer가 제거되는 중일 때 호출되는 단계</li>\n</ul>\n<h4>onDestroy()</h4>\n<ul>\n<li>Fragment가 제거되기 직전 단게</li>\n<li>Fragment가 생성될 때 onCreate → onCreateView 순으로 호출된 것과 달리, 파괴는 onDestroyView에서 View를 제거한 후 onDestroy가 호출된다.</li>\n</ul>\n<h2>getViewLifecycleOwner() vs getLifecycleOwner()</h2>\n<h4>LifecycleOwner</h4>\nLifecycleOwner는 __Fragment의 생명주기__ 를 가지고 있는 클래스로 `onAttach()` ~ `onDestroy()`와 연결되어 있다.\n<h4>viewLifecycleOwner</h4>\nviewLifecycleOwner는 __Fragment View의 생명주기__ 를 가지고 있는 클래스로 `onCreateView()` ~ `onDestroyView()` 와 연결되어 있다.\n<blockquote>\n<p>📍viewLifecycle은 Fragment LifeCycle 보다 생명주기가 짧다!</p>\n</blockquote>\n<p>이러한 서로 다른 생명주기에 따라 대표적으로 liveData를 사용할때 매개변수로 <code class=\"language-text\">this</code>로 넘겨주었다면 <strong>경우에 따라 Fragment가 Destroy 되지 않았지만 새로운 observer가 등록되는 경우</strong> 생길 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token comment\">// onAttach() ~ onDestroy()</span>\nliveData<span class=\"token punctuation\">.</span><span class=\"token function\">observe</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> it <span class=\"token operator\">-></span> \n  <span class=\"token comment\">// this(fragment) -> Destroy 되지 않았을 때 다시 불릴 가능성</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// onCreateView() ~ onDestroyView()</span>\nliveData<span class=\"token punctuation\">.</span><span class=\"token function\">observe</span><span class=\"token punctuation\">(</span>viewLifecycleOwner<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> it <span class=\"token operator\">-></span> \n  <span class=\"token operator\">..</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>구글에서 기본으로 제공하는 Fragment 클래스에서도 View와 Fragment의 생명주기가 달라 메모리 누수가 발생할 수 있기 때문에 이에 코드를 볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\">  <span class=\"token keyword\">private</span> <span class=\"token keyword\">var</span> _binding<span class=\"token operator\">:</span> ResultProfileBinding<span class=\"token operator\">?</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n  <span class=\"token comment\">// This property is only valid between onCreateView and</span>\n  <span class=\"token comment\">// onDestroyView.</span>\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">val</span> binding <span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> _binding<span class=\"token operator\">!!</span>\n\n  <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">onCreateView</span><span class=\"token punctuation\">(</span>\n      inflater<span class=\"token operator\">:</span> LayoutInflater<span class=\"token punctuation\">,</span>\n      container<span class=\"token operator\">:</span> ViewGroup<span class=\"token operator\">?</span><span class=\"token punctuation\">,</span>\n      savedInstanceState<span class=\"token operator\">:</span> Bundle<span class=\"token operator\">?</span>\n  <span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> View<span class=\"token operator\">?</span> <span class=\"token punctuation\">{</span>\n      _binding <span class=\"token operator\">=</span> ResultProfileBinding<span class=\"token punctuation\">.</span><span class=\"token function\">inflate</span><span class=\"token punctuation\">(</span>inflater<span class=\"token punctuation\">,</span> container<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">val</span> view <span class=\"token operator\">=</span> binding<span class=\"token punctuation\">.</span>root\n      <span class=\"token keyword\">return</span> view\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">onDestroyView</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">onDestroyView</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      _binding <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n  <span class=\"token punctuation\">}</span>  </code></pre></div>\n<p>Fragment는 제거되지 않았지만 <code class=\"language-text\">onCreateView()</code>는 다시 사용할 수 있기 때문에 명시적으로 <code class=\"language-text\">onDestroyView()</code>에서 binding에 할당을 취소해 가비지 컬렉션이 되도록 해야한다. </p>\n<hr>\n<h1>FragmentManager</h1>\n<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/231444667-211d675f-5ce3-4b11-8b55-f745849df216.png\" width=\"70%\"></p>\n<ul>\n<li>FragmentManager 속성은 호출된 Fragment 계층 구조에서 어디에 있는지에 따라 어떤 FragmentManager에 액세스하는지 다르다.</li>\n<li>FragmentManager는 Activity와 Fragment의 중간에서 서로를 이어주는 역할을 하여 Fragment Transaction 수행해 준다.</li>\n<li>FragmentManager은 백 스택(Back Stack) 에 Fragment 추가/교체/삭제 작업에 의한 변경 사항을 push 및 pop 하는 작업을 담당한다.</li>\n</ul>\n<blockquote>\n<ul>\n<li>\n<p><code class=\"language-text\">findFragmentById()</code> : Fragment 컨테이너 내의 현재 Fragment 참조</p>\n<ul>\n<li>UI를 제공하는 Fragment를 참조할 때 사용</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> fragment <span class=\"token operator\">=</span> supportFragmentManager<span class=\"token punctuation\">.</span><span class=\"token function\">findFragmentById</span><span class=\"token punctuation\">(</span>binding<span class=\"token punctuation\">.</span>fragmentContainer<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span></code></pre></div>\n<blockquote>\n<ul>\n<li><code class=\"language-text\">findFragmentByTag()</code> : Fragment에 고유한 태그를 부여한 후 태그를 이용해 Fragment 참조</li>\n</ul>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> fragment <span class=\"token operator\">=</span> supportFragmentManager<span class=\"token punctuation\">.</span><span class=\"token function\">findFragmentByTag</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"my_fragment\"</span></span><span class=\"token punctuation\">)</span></code></pre></div>\n<hr>\n<h1>Fragment Transaction</h1>\n<p>Fragment Transaction의 인스턴스는 FragmentManager의 beginTransaction() 메서드를 통해 얻을 수 있다</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> manager <span class=\"token operator\">=</span> supportFragmentManager<span class=\"token punctuation\">.</span><span class=\"token function\">beginTransaction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Android Jetpack Fragment 라이브러리에서 제공하는 클래스로 Transaction 클래스는 Fragment 추가/교체/삭제 작업을 제공한다.</p>\n<ul>\n<li>Fragment Transaction은 FragmentManager의 단일 수행 단위</li>\n<li>하나의 Fragment Transaction 단위 내에 Fragment Transaction 클래스가 제공하는 Fragment 추가/교체/삭제 작업 등을 명시하면 된다.</li>\n<li>하나의 Fragment Transaction 단위 내에 작성된 Fragment 조작 관련 작업들은 해당 Fragment Transaction 수행될 때 모두 실행된다.</li>\n</ul>\n<h2>Transaction 메소드</h2>\n<p>Fragment의 Transaction 메소드들은 <code class=\"language-text\">add()</code>, <code class=\"language-text\">replace()</code>, <code class=\"language-text\">commit()</code>, <code class=\"language-text\">commitAllowingStateloss()</code>, <code class=\"language-text\">remove()</code>, <code class=\"language-text\">addToBackStack()</code> 등이 있다.</p>\n<blockquote>\n<p><strong>add()</strong></p>\n<ul>\n<li>기존에 있던 Fragment를 지우는 것이 아니라 그 위에 다시 추가한다.</li>\n</ul>\n<p><strong>replace()</strong></p>\n<ul>\n<li>기본에 있던 Fragment를 제거한 후 새로운 Fragment를 추가한다.</li>\n</ul>\n<p><strong>remove()</strong></p>\n<ul>\n<li>기존에 있던 Fragment를 삭제한다.  </li>\n<li>fragment를 찾기 위해 <code class=\"language-text\">findFragmentById()</code>, <code class=\"language-text\">findFragmentByTag()</code> 메서드로 제거할 fragment를 찾는다</li>\n</ul>\n<p><strong>commit()</strong></p>\n<ul>\n<li>FragmentTransaction을 생성하고 Fragment의 추가/교체/삭제 작업을 명시한 후 <strong>반드시 마지막에 commit</strong> 을 해줘야 한다.</li>\n</ul>\n<p><strong>addToBackStack()</strong></p>\n<ul>\n<li>해당 메소드를 해준 후 commit()을 하게 되면 하기 전까지의 모든 변경 내용이 하나의 Transaction으로 backStack에 들어간다.</li>\n</ul>\n</blockquote>\n<h2>📌 commit() vs commitNow()</h2>\n<p>commit()에는 <code class=\"language-text\">Now</code> 가 붙은 메소드들이 있다. commit() 메서드는 <strong>비동기로 처리되는 함수</strong> 이기 때문에 commit 함수 호출 시점에 바로 Transaction이 즉시 수행되는 것이 아니라 Main Thread에 예약된다.</p>\n<p>반면에 commitNow() 메서드는 호출 시점에 즉시 해당 Fragment Transaction이 <strong>동기적으로 수행</strong> 된다.</p>\n<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/231384985-1a4605eb-ce73-454a-8a91-f1069211ce45.png\" width=\"50%\"></p>\n<blockquote>\n<p>commitNow()는 동기적으로 실행하기 때문에 <code class=\"language-text\">addToBackStack()</code> 를 통하여 백스택에 Transaction을 추가하려는 경우 프레임워크는 명령에 대한 보증을 할 수 없기 때문에 사용할 수 없다.</p>\n</blockquote>\n<h2>📌 commit() vs commitAllowingStateLoss()</h2>\n<p>Fragment를 사용을 해보았다면 <code class=\"language-text\">onSaveInstanceState()</code> 이후 commit()을 수행할 수 없다는 <code class=\"language-text\">IllegalStateException</code> 을 봤을 것이다.</p>\n<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/231441130-7a39f286-91f8-4994-bd48-2bcd813fcf59.png\"></p>\n<ul>\n<li>Fragment Transaction은 호스트 Activity가 자신의 상태(RESUMED, STOPPED 등)를 저장하기 전에 생성되고 commit 되어야 한다.</li>\n<li>\n<p>만약 호스트 Activity가 <code class=\"language-text\">onSaveInstanceState()</code> 메소드를 호출한 후에 Fragment Transaction이 commit 된다면 에러가 발생한다.</p>\n<ul>\n<li>Activity의 상태가 저장될 때 자신에서 <strong>호스팅되어 있는 Fragment의 상태도 저장</strong> 하게 되는데, <strong>이러한 상태 저장 후 Fragment Transaction에 의해 Fragment 추가/교체/삭제 작업이 일어나면 Activity가 저장한 Fragment 상태와 달라</strong> 지기 때문이다.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>📍<code class=\"language-text\">commitAllowingStateLoss()</code> 는 commit()과 거의 동일 하지만 상태와 달라질 수 있는(상태 손실)을 허용한다.</p>\n</blockquote>\n<hr>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://developer.android.com/guide/fragments?hl=ko\">https://developer.android.com/guide/fragments?hl=ko</a></li>\n<li><a href=\"https://medium.com/hongbeomi-dev/%EB%B2%88%EC%97%AD-%EB%8B%A4%EC%96%91%ED%95%9C-%EC%A2%85%EB%A5%98%EC%9D%98-commit-8f646697559f\">https://medium.com/hongbeomi-dev/%EB%B2%88%EC%97%AD-%EB%8B%A4%EC%96%91%ED%95%9C-%EC%A2%85%EB%A5%98%EC%9D%98-commit-8f646697559f</a></li>\n</ul>","frontmatter":{"title":"안드로이드 Fragment 조각내기","date":"April 12, 2023","update":"April 12, 2023","tags":["Android","FragmentTransaction","Fragment"],"series":"Android"},"fields":{"slug":"/android-fragment/","readingTime":{"minutes":9.535}}},"seriesList":{"edges":[{"node":{"id":"6925146a-2b07-5bc9-9607-184a4e3c68c3","fields":{"slug":"/android-start/"},"frontmatter":{"title":"첫 안드로이드 개발에 대한 회고"}}},{"node":{"id":"a565c6a3-fcce-5c9a-ad4d-02af13741cf5","fields":{"slug":"/lifecycle/"},"frontmatter":{"title":"안드로이드 Lifecycle 제대로 알기"}}},{"node":{"id":"468a8f79-4ea8-5898-b283-757c8e875153","fields":{"slug":"/fragment/"},"frontmatter":{"title":"안드로이드 Fragment 사용"}}},{"node":{"id":"bb6db639-8e2b-5530-be8b-949a8b1760be","fields":{"slug":"/intent/"},"frontmatter":{"title":"안드로이드 인텐트의 개념"}}},{"node":{"id":"36ff293e-dde0-550d-aeb8-ec537b790e20","fields":{"slug":"/recyclerview/"},"frontmatter":{"title":"안드로이드 4대 컴포넌트란"}}},{"node":{"id":"797d9ee9-2c11-55bc-b727-4ae592506f62","fields":{"slug":"/android-context/"},"frontmatter":{"title":"안드로이드 Context의 개념"}}},{"node":{"id":"f324f418-379e-5586-bd19-dea6cc747952","fields":{"slug":"/broadcast/"},"frontmatter":{"title":"안드로이드 브로드캐스트(Broadcast)"}}},{"node":{"id":"1668e5f7-7335-5076-9f55-1bec5c8e40be","fields":{"slug":"/android-service/"},"frontmatter":{"title":"안드로이드 서비스(Service) 개요"}}},{"node":{"id":"0b7da456-386b-5c28-b4a8-fefb68cdff05","fields":{"slug":"/pendingintent/"},"frontmatter":{"title":"안드로이드 PendingIntent의 개념"}}},{"node":{"id":"75afba69-c4e6-5bef-ab1b-d9afad6a6115","fields":{"slug":"/notification/"},"frontmatter":{"title":"안드로이드 알림(Notification) 만들기"}}},{"node":{"id":"b8aadf5e-7f02-5e8d-a985-a514d4d23797","fields":{"slug":"/android-jetpack/"},"frontmatter":{"title":"안드로이드 Jetpack에 대해"}}},{"node":{"id":"3cb29f6c-c1ac-5e6b-806e-39b4dabde747","fields":{"slug":"/android-acc/"},"frontmatter":{"title":"안드로이드 MVVM 패턴과 ACC 알아보기"}}},{"node":{"id":"eb635b92-e487-54e6-ad67-e65845019036","fields":{"slug":"/viewmodel/"},"frontmatter":{"title":"안드로이드 Jetpack의 ViewModel 사용해보기"}}},{"node":{"id":"664bce30-45ec-5072-80a9-787c6e62e8a1","fields":{"slug":"/livedata/"},"frontmatter":{"title":"안드로이드 Jetpack의 LiveData 적용하기"}}},{"node":{"id":"98ef256e-b69d-550a-9092-ccea70762e3f","fields":{"slug":"/databinding/"},"frontmatter":{"title":"안드로이드 DataBinding + LiveData 적용하기"}}},{"node":{"id":"c555e79d-0c6c-55f6-bbe3-540d4870fbaa","fields":{"slug":"/coroutine/"},"frontmatter":{"title":"안드로이드 코루틴의 기초 알아보기"}}},{"node":{"id":"120e4269-fab9-56d3-a8c3-4eb27ff99dbc","fields":{"slug":"/room-database/"},"frontmatter":{"title":"안드로이드 Room 사용하면서 알아보기"}}},{"node":{"id":"a23c3328-e672-5cda-b982-a2a0b412559e","fields":{"slug":"/android-dagger2/"},"frontmatter":{"title":"안드로이드 Dagger2 맛보기"}}},{"node":{"id":"97bedaf5-babf-55d6-9af8-caf47bb169b6","fields":{"slug":"/android-dagger2-more/"},"frontmatter":{"title":"안드로이드 Dagger2 좀 더 알아가기"}}},{"node":{"id":"bb9a7240-98d9-538d-9224-6d110a0f0358","fields":{"slug":"/android-hilt/"},"frontmatter":{"title":"안드로이드 Hilt에 대해 알아보기"}}},{"node":{"id":"bf6ff02b-6b19-5062-a565-0d3f1955be42","fields":{"slug":"/repository-pattern/"},"frontmatter":{"title":"안드로이드 Repository 패턴은 무엇인가"}}},{"node":{"id":"8c9cfe55-c118-5907-b606-febd84308e2f","fields":{"slug":"/datastore/"},"frontmatter":{"title":"새로운 동료 DataStore 알아보기"}}},{"node":{"id":"1f43678a-5010-5917-beb2-ad59b1882a3b","fields":{"slug":"/android-diffutil/"},"frontmatter":{"title":"안드로이드 RecyclerView의 DiffUtil 알아보기"}}},{"node":{"id":"afd2b0e2-6cb5-5753-b370-ae59b99bcd30","fields":{"slug":"/viewpager2/"},"frontmatter":{"title":"안드로이드 ViewPager2 사용기"}}},{"node":{"id":"4f0c8d12-3fbe-52d0-95da-58b34e9359fb","fields":{"slug":"/runOnUiThread/"},"frontmatter":{"title":"안드로이드 runOnUiThread?"}}},{"node":{"id":"df647556-1bf0-55cc-af42-57acb7206e5f","fields":{"slug":"/android-launcher/"},"frontmatter":{"title":"안드로이드에서 Launcher를 통한 결과 전달"}}},{"node":{"id":"9e5d89dd-6d3c-5442-bf07-3b6dbf2b3bb1","fields":{"slug":"/android-menu/"},"frontmatter":{"title":"안드로이드 다양한 Menu들 사용하기"}}},{"node":{"id":"c4fb68dc-0882-5bc8-8cf8-1e4bcb82d690","fields":{"slug":"/android-permission/"},"frontmatter":{"title":"안드로이드 Permission 가져오기"}}},{"node":{"id":"6412e19a-99a7-5938-90d1-7296a34757b2","fields":{"slug":"/android-sqlite/"},"frontmatter":{"title":"안드로이드 내부 데이터 저장 SQLite"}}},{"node":{"id":"d5df013b-8ddd-5c33-ab15-38ddacceb71e","fields":{"slug":"/android-local-service/"},"frontmatter":{"title":"안드로이드 Local Service 알아보기"}}},{"node":{"id":"c3641eee-48c5-5870-a5d1-26d1401311e7","fields":{"slug":"/android-fragment/"},"frontmatter":{"title":"안드로이드 Fragment 조각내기"}}},{"node":{"id":"f0a71dbc-6c77-52e0-a749-cc19dbc1b8b3","fields":{"slug":"/livedata-transform/"},"frontmatter":{"title":"안드로이드 MediatorLiveData와 Transformations"}}},{"node":{"id":"ffdd7d7b-34ae-58f8-87f8-7c6c6513ddf5","fields":{"slug":"/android-navigation/"},"frontmatter":{"title":"안드로이드 Navigation 사용하기"}}},{"node":{"id":"38730b0e-28e4-544e-a8db-aad5668516cc","fields":{"slug":"/compose-start/"},"frontmatter":{"title":"안드로이드 Compose 알아보기"}}},{"node":{"id":"f3301d6b-63a2-5b07-b6cb-473f6ec13c7e","fields":{"slug":"/compose-lifecycle/"},"frontmatter":{"title":"안드로이드 Compose 수명 주기"}}},{"node":{"id":"a3a56595-ff49-5d63-b85a-4db183a541b5","fields":{"slug":"/compose-state-hoisting/"},"frontmatter":{"title":"안드로이드 Compose 상태 호이스팅"}}},{"node":{"id":"b7fcd3ce-4e92-52fe-ba70-ada12c9ac982","fields":{"slug":"/compose-side-effect/"},"frontmatter":{"title":"안드로이드 Side Effect란?"}}},{"node":{"id":"57cc52b2-25b0-56fa-92d8-91e55927e81b","fields":{"slug":"/android-version-catalog/"},"frontmatter":{"title":"안드로이드 Version Catalog 도입하기"}}},{"node":{"id":"24c2c48e-3290-5d58-b125-033c68f50682","fields":{"slug":"/android-webview/"},"frontmatter":{"title":"안드로이드 WebView로 웹과 놀기"}}},{"node":{"id":"1da187ef-bc7f-5929-b60f-7ddda78148d4","fields":{"slug":"/compose-theme/"},"frontmatter":{"title":"Compose 나만의 Custom Theme 설정하기"}}},{"node":{"id":"a6e75dd2-49dc-5b27-9a47-308a25586348","fields":{"slug":"/compose-bezier/"},"frontmatter":{"title":"Compose에서 Bezier 곡선으로 스쿼클 만들기"}}},{"node":{"id":"bc850df8-7668-542d-896a-6380a5c90b44","fields":{"slug":"/multipart/"},"frontmatter":{"title":"Ktor와 Multipart로 파일 업로드 근데 이제 Ktrofit을 곁들인"}}}]},"previous":{"fields":{"slug":"/android-local-service/"},"frontmatter":{"title":"안드로이드 Local Service 알아보기"}},"next":{"fields":{"slug":"/livedata-transform/"},"frontmatter":{"title":"안드로이드 MediatorLiveData와 Transformations"}}},"pageContext":{"id":"c3641eee-48c5-5870-a5d1-26d1401311e7","series":"Android","previousPostId":"d5df013b-8ddd-5c33-ab15-38ddacceb71e","nextPostId":"f0a71dbc-6c77-52e0-a749-cc19dbc1b8b3"}},"staticQueryHashes":[],"slicesMap":{}}