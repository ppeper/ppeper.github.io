{"componentChunkName":"component---src-templates-post-jsx","path":"/generic-in-out/","result":{"data":{"site":{"siteMetadata":{"title":"ppeper🥤"}},"markdownRemark":{"id":"b0b78929-653d-5d49-a7cf-79c5069f2dab","excerpt":"안드로이드와 코틀린을 공부 하면서 ,  키워드를 많이 봤지만 의미를 정확히 알지 못하였던 개념에 대해서 차근차근 알아가보려고 한다 😅 제네릭(Generic) 프로그래밍 언어에서는 Int, Char, String등 기본(Primitive) 데이터 타입을 지원한다. 제네릭 은 타입을 확실히 정하지 않고 동일한 코드를 사용할 수 있도록 지원해주는 유용한 기능이…","html":"<p>안드로이드와 코틀린을 공부 하면서 <code class=\"language-text\">out</code>, <code class=\"language-text\">in</code> 키워드를 많이 봤지만 의미를 정확히 알지 못하였던 개념에 대해서 차근차근 알아가보려고 한다 😅</p>\n<h1>제네릭(Generic)</h1>\n<p>프로그래밍 언어에서는 Int, Char, String등 기본(Primitive) 데이터 타입을 지원한다. <strong>제네릭</strong> 은 <strong>타입을 확실히 정하지 않고</strong> 동일한 코드를 사용할 수 있도록 지원해주는 유용한 기능이다. 이는 <strong><code class=\"language-text\">&lt;T></code></strong> 로 많이 친숙하게 볼 수 있는 친구다. </p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">generic</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> T<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">generic</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"ppeper\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">generic</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"26\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h1>불변성이란??</h1>\n<p><code class=\"language-text\">제네릭</code>은 자바와 마찬가지로 <strong>타입 불변성</strong> 을 가진다. 타입 불변성은 제네릭 타입을 사용하는 <strong>클래스나 인터페이스</strong> 에서는 <strong>일치하는 타입만 사용할 수 있다</strong> 는 것을 말한다. 즉 해당 타입의 부모,자식의 타입은 사용이 불가하다. 그러한 이유는 예시를 통하여 알아가보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">open</span> <span class=\"token keyword\">class</span> Phone\n<span class=\"token keyword\">class</span> Apple<span class=\"token operator\">:</span> <span class=\"token function\">Phone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">class</span> Samsung <span class=\"token operator\">:</span> <span class=\"token function\">Phone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// 상속 관계로 부모에 자식 사용이 가능하다.</span>\n<span class=\"token keyword\">val</span> iphone<span class=\"token operator\">:</span> Phone <span class=\"token operator\">=</span> <span class=\"token function\">Apple</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// 오케이 나도 해볼까</span>\n<span class=\"token comment\">// Type Mismatch -> Required: Array&lt;Phone> / Found: Array&lt;Apple></span>\n<span class=\"token comment\">// ....</span>\n<span class=\"token keyword\">val</span> iphones<span class=\"token operator\">:</span> Array<span class=\"token operator\">&lt;</span>Apple<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token function\">arrayOf</span><span class=\"token punctuation\">(</span><span class=\"token function\">Apple</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">Apple</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> phones<span class=\"token operator\">:</span> Array<span class=\"token operator\">&lt;</span>Phone<span class=\"token operator\">></span> <span class=\"token operator\">=</span> iphones</code></pre></div>\n<blockquote>\n<p>🤔분명 Phone을 상속받은 Apple 클래스인데 Type Mismatch?</p>\n</blockquote>\n<p>위와 같이 제네릭의 타입을 가지는 클래스, 인터페이스에서 <strong>클래스의 상속관계가 형식인자의 상속관계와 같이 유지되지 않는다</strong> 즉, <code class=\"language-text\">A -> B</code> 일때 <code class=\"language-text\">Class&lt;A> -> Class&lt;B></code> 를 만족하지 못한다. 이를 <strong>Invariance(불변성)</strong> 이라고 한다.</p>\n<p><strong>불변성(Invariance)</strong> 이 존재하는 이유는 다음과 같은 문제가 일어날 수 있기 때문이다!</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">myPhones</span><span class=\"token punctuation\">(</span>phones<span class=\"token operator\">:</span> Array<span class=\"token operator\">&lt;</span>Phone<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...???</span>\n    phones<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">Apple</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> galaxys<span class=\"token operator\">:</span> Array<span class=\"token operator\">&lt;</span>Samsung<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token function\">arrayOf</span><span class=\"token punctuation\">(</span><span class=\"token function\">Samsung</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">myPhones</span><span class=\"token punctuation\">(</span>galaxys<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Samsung폰에 대한 galaxys 변수의 Array를 모르고 myPhones[0]에 Apple()을 넣어준다면 타입이 맞지 않아 문제가 발생하게 된다.</p>\n<hr>\n<h2>불변성에 대한 한계점</h2>\n<p><strong>불변성</strong> 은 <strong>컴파일 타임 에러를 잡아주고 런타임에 에러를 내지않는 안전한 방법</strong> 이다. 그러나 이는 가끔 안전하다고 보장된 상황에서도 컴파일 에러를내 개발자를 불편하게 할 수 있다. </p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span>from<span class=\"token operator\">:</span> Array<span class=\"token operator\">&lt;</span>Phone<span class=\"token operator\">></span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">to</span><span class=\"token operator\">:</span> Array<span class=\"token operator\">&lt;</span>Phone<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>index <span class=\"token keyword\">in</span> from<span class=\"token punctuation\">.</span>indices<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">to</span><span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> from<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> phones<span class=\"token operator\">:</span> Array<span class=\"token operator\">&lt;</span>Phone<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token function\">arrayOf</span><span class=\"token punctuation\">(</span><span class=\"token function\">Phone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">val</span> galaxys<span class=\"token operator\">:</span> Array<span class=\"token operator\">&lt;</span>Samsung<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token function\">arrayOf</span><span class=\"token punctuation\">(</span><span class=\"token function\">Samsung</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span>galaxys<span class=\"token punctuation\">,</span> phones<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// Type Mismatch -> Required: Array&lt;Phone> / Found: Array&lt;Samsung></span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>phones에 galaxys를 copy를 하는 함수는 문제가 없어보인다. 하지만 위에서 말한 <strong>불변성</strong> 으로 인하여 <strong><code class=\"language-text\">A -> B</code> 일때 <code class=\"language-text\">Class&lt;A> -> Class&lt;B></code></strong> 를 만족하지 못하여 컴파일 에러로 판단한다.</p>\n<p>이를 해결하기 위해서는 개발자가 <strong><code class=\"language-text\">A -> B</code> 일때 <code class=\"language-text\">Class&lt;A> -> Class&lt;B></code></strong> 를 상속 받게 바꿔 주어야한다. 이를 <strong>공병성</strong> 이라고 하며 코틀린에서는 <strong><code class=\"language-text\">out</code></strong> 키워드를 사용한다.</p>\n<hr>\n<h2>📍공병성, out 키워드</h2>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span>from<span class=\"token operator\">:</span> Array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">out</span> Phone<span class=\"token operator\">></span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">to</span><span class=\"token operator\">:</span> Array<span class=\"token operator\">&lt;</span>Phone<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>index <span class=\"token keyword\">in</span> from<span class=\"token punctuation\">.</span>indices<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">to</span><span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> from<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> phones<span class=\"token operator\">:</span> Array<span class=\"token operator\">&lt;</span>Phone<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token function\">arrayOf</span><span class=\"token punctuation\">(</span><span class=\"token function\">Phone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">val</span> galaxys<span class=\"token operator\">:</span> Array<span class=\"token operator\">&lt;</span>Samsung<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token function\">arrayOf</span><span class=\"token punctuation\">(</span><span class=\"token function\">Samsung</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span>galaxys<span class=\"token punctuation\">,</span> phones<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p>위와 같이 <strong><code class=\"language-text\">out</code></strong> 키워드를 통하여 <strong>공변성</strong> 으로 변환을 통하여 불필요한 <strong>불변성</strong> 문제를 해결할 수 있다.</p>\n</blockquote>\n<p>❗하지만 여기서 from에 Samsung()을 Write하려고 한다면 에러가 발생한다. </p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span>from<span class=\"token operator\">:</span> Array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">out</span> Phone<span class=\"token operator\">></span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">to</span><span class=\"token operator\">:</span> Array<span class=\"token operator\">&lt;</span>Phone<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>index <span class=\"token keyword\">in</span> from<span class=\"token punctuation\">.</span>indices<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">to</span><span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> from<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// Type Mismatch -> Required: Nothing / Found: Samsung</span>\n    from<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">Samsung</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>from[0]에서는 Nothing 즉, 아무것도 입력받기를 원하지 않는다. 이유는 불변성과 비슷하다고 할 수 있다.</p>\n<blockquote>\n<p><strong>[Read]</strong></p>\n<p>from에서는 <code class=\"language-text\">Array&lt;out Phone></code>을 통하여 컴파일러가 from의 부모가 Phone인것과 sub Type인 Apple, Samasung 중 하나인것을 인지 하고 있다. 따라서 읽을때는 문제가 발생하지 않는다.</p>\n<p><strong>[Write]</strong></p>\n<p>하지만 from에 값을 쓰려고 한다면 타입이 Phone, Apple, Samsung 중 하나라는 것만 인지하고 있을뿐 <strong>실제 타입을 모르는 Array</strong> 에서 값을 쓸 수가 없는 것이다.</p>\n</blockquote>\n<p>그렇다면 공병성과 반대되는 Read가 불가능하고 Write만 할 수 있는 것이 있지 않을까?</p>\n<p>Read가 가능한 <strong><code class=\"language-text\">out</code></strong> 키워드가 있다면 반대로 Write이 가능한\n<strong><code class=\"language-text\">in</code></strong> 키워드가 있다. 이를 <strong>반공병성(Contravariance)</strong> 라고 한다.</p>\n<hr>\n<p>to 파라미터에 대해서 <strong><code class=\"language-text\">Array&lt;Phone></code></strong> 에 대하여 <strong>Phone의 super Type인 부모 클래스</strong> 를 전달하고 싶다면 어떻게 해야할까?</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span>from<span class=\"token operator\">:</span> Array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">out</span> Phone<span class=\"token operator\">></span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">to</span><span class=\"token operator\">:</span> Array<span class=\"token operator\">&lt;</span>Phone<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>index <span class=\"token keyword\">in</span> from<span class=\"token punctuation\">.</span>indices<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">to</span><span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> from<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> phones<span class=\"token operator\">:</span> Array<span class=\"token operator\">&lt;</span>Any<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token function\">arrayOf</span><span class=\"token punctuation\">(</span><span class=\"token function\">Any</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">val</span> galaxys<span class=\"token operator\">:</span> Array<span class=\"token operator\">&lt;</span>Samsung<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token function\">arrayOf</span><span class=\"token punctuation\">(</span><span class=\"token function\">Samsung</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span>galaxys<span class=\"token punctuation\">,</span> phones<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// Type Mismatch -> Required: Array&lt;Phone> / Found: Array&lt;Any></span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위와 같이 <strong><code class=\"language-text\">Array&lt;Any></code></strong> 로 선언하고 싶지만 위에서 설명한 <strong>불변성으로 이는 안된다고 하였고</strong> 미리 컴파일러는 Type Mismatch를 통하여 에러를 알려 준다<del>(고..마워😅)</del>.</p>\n<p>이에 대해서 명시적으로 부모 클래스를 넘겨 줄 수 있는 방법이 <strong><code class=\"language-text\">in</code></strong> 키워드이다.</p>\n<h1>📍반공변성 in!</h1>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span>from<span class=\"token operator\">:</span> Array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">out</span> Phone<span class=\"token operator\">></span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">to</span><span class=\"token operator\">:</span> Array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">in</span> Phone<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>index <span class=\"token keyword\">in</span> from<span class=\"token punctuation\">.</span>indices<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">to</span><span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> from<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> phones<span class=\"token operator\">:</span> Array<span class=\"token operator\">&lt;</span>Any<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token function\">arrayOf</span><span class=\"token punctuation\">(</span><span class=\"token function\">Any</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">val</span> galaxys<span class=\"token operator\">:</span> Array<span class=\"token operator\">&lt;</span>Samsung<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token function\">arrayOf</span><span class=\"token punctuation\">(</span><span class=\"token function\">Samsung</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span>galaxys<span class=\"token punctuation\">,</span> phones<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p>위와 같이 <strong><code class=\"language-text\">in</code></strong> 키워드를 통하여 <strong>반공변성</strong> 으로 변환을 통하여 불필요한 <strong>불변성</strong> 문제를 해결할 수 있다.</p>\n</blockquote>\n<p><code class=\"language-text\">to[index] = from[index]</code>로 반공병성은 Write할때는 문제가 되지 않지만 반대로 Read를 하려고 하면 문제가 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span>from<span class=\"token operator\">:</span> Array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">out</span> Phone<span class=\"token operator\">></span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">to</span><span class=\"token operator\">:</span> Array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">in</span> Phone<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>index <span class=\"token keyword\">in</span> from<span class=\"token punctuation\">.</span>indices<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">to</span><span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> from<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">val</span> phone<span class=\"token operator\">:</span> Phone <span class=\"token operator\">=</span> <span class=\"token keyword\">to</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n    <span class=\"token comment\">// Type Mismatch -> Required: Phone / Found: Any?</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이에 대한 문제는 공병성과 반대로 컴파일러가 to 매개변수를 읽으려 할때 <strong>반공병성</strong> 으로 <strong>Phone과 그에 대한 조상 타입을 명시적으로 가능하게 하였으므로</strong> 읽을때는 실제 타입을 모르기 때문에 함부로 읽을 수 없는 것이다.</p>\n<h1>정리</h1>\n<p>공병성, 반공병성에 대해서 학습을 해보았지만 간단한 예시를 통하여 해보았기 때문에 많은 소스를 접해보고 사용해 봐야 할 것 같다.</p>\n<blockquote>\n<p>out: <strong>꺼내와서(out 시킨다)</strong> 읽는다. -> Write은 불가능</p>\n<ul>\n<li>슈퍼 클래스에 서브 클래스를 사용가능하게 해준다.</li>\n</ul>\n<p>in: <strong>넣어준다(in 시킨다)</strong> 즉, Write 할 수 있다. -> Read는 불가능</p>\n<ul>\n<li>서버 클래스에 슈퍼 클래스를 사용가능하게 해준다.</li>\n</ul>\n</blockquote>\n<hr>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://medium.com/mj-studio/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%A0%9C%EB%84%A4%EB%A6%AD-in-out-3b809869610e\">https://medium.com/mj-studio/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%A0%9C%EB%84%A4%EB%A6%AD-in-out-3b809869610e</a></li>\n<li><a href=\"https://readystory.tistory.com/201\">https://readystory.tistory.com/201</a></li>\n</ul>","frontmatter":{"title":"Kotlin 제네릭의 in, out 키워드?","date":"June 25, 2022","update":"June 25, 2022","tags":["제네릭","공병성","반공병성","불변성"],"series":"Kotlin"},"fields":{"slug":"/generic-in-out/","readingTime":{"minutes":8.455}}},"seriesList":{"edges":[{"node":{"id":"a7e9c7fb-11d9-59aa-b9c8-faef6cfcd27e","fields":{"slug":"/scope-function/"},"frontmatter":{"title":"코틀린의 Scope Function는 언제쓸까"}}},{"node":{"id":"995d0539-ea55-5757-b642-d423a2fef20c","fields":{"slug":"/sort/"},"frontmatter":{"title":"코틀린 리스트 정렬하는 방법 (sort vs sortBy vs sortWith)"}}},{"node":{"id":"b0b78929-653d-5d49-a7cf-79c5069f2dab","fields":{"slug":"/generic-in-out/"},"frontmatter":{"title":"Kotlin 제네릭의 in, out 키워드?"}}},{"node":{"id":"33959bf6-d080-5100-ac93-0be970a5d159","fields":{"slug":"/flow/"},"frontmatter":{"title":"Kotlin Coroutines Flow 맛보기"}}},{"node":{"id":"770fa80e-3899-50bc-a219-6f0a4abde7eb","fields":{"slug":"/serialization/"},"frontmatter":{"title":"코틑린을 위한 Kotlinx Serizalization"}}},{"node":{"id":"1da09158-79bc-54c5-8886-5cf392f4154f","fields":{"slug":"/ktor/"},"frontmatter":{"title":"KMP를 지원하는 Ktor Client를 사용해보자"}}}]},"previous":{"fields":{"slug":"/datastore/"},"frontmatter":{"title":"새로운 동료 DataStore 알아보기"}},"next":{"fields":{"slug":"/flow/"},"frontmatter":{"title":"Kotlin Coroutines Flow 맛보기"}}},"pageContext":{"id":"b0b78929-653d-5d49-a7cf-79c5069f2dab","series":"Kotlin","previousPostId":"2469d97d-f2b6-544e-8ef9-20003ce2bd82","nextPostId":"33959bf6-d080-5100-ac93-0be970a5d159"}},"staticQueryHashes":[],"slicesMap":{}}