{"componentChunkName":"component---src-templates-post-jsx","path":"/brute-force/","result":{"data":{"site":{"siteMetadata":{"title":"ppeper🥤"}},"markdownRemark":{"id":"a7cdd531-abe3-5f8b-a851-04e96b20b97b","excerpt":"완전탐색이란? 완전탐색이란 가능한 모든 경우의 수 를 모두 찾는 방법이다. 이러한 방법은 무식한 한다는 의미로 'Brute Force'라고도 이름이 불린다. 완전탐색은 직관적이어서 이해하기 쉽고, 문제에 대한 결과값이 정확하게 얻을 수 있다 는 점에서 가장 확실하고 기초적인 문제 풀이 방법이다. 알고리즘 문제를 풀때에는 기본적으로 두가지를 생각하고 들어간…","html":"<h1 id=\"완전탐색이란\" style=\"position:relative;\"><a href=\"#%EC%99%84%EC%A0%84%ED%83%90%EC%83%89%EC%9D%B4%EB%9E%80\" aria-label=\"완전탐색이란 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>완전탐색이란?</h1>\n<p>완전탐색이란 <strong>가능한 모든 경우의 수</strong> 를 모두 찾는 방법이다. 이러한 방법은 무식한 한다는 의미로 'Brute Force'라고도 이름이 불린다.</p>\n<p>완전탐색은 <strong>직관적이어서 이해하기 쉽고</strong>, 문제에 대한 <strong>결과값이 정확하게 얻을 수 있다</strong> 는 점에서 가장 확실하고 기초적인 문제 풀이 방법이다.</p>\n<p>알고리즘 문제를 풀때에는 기본적으로 두가지를 생각하고 들어간다.</p>\n<ol>\n<li>해당 알고리즘이 적절한가> -> 문제를 풀 수 있는 방법인가</li>\n<li>효율적인가? -> 제한된 시간이 안에 알고리즘이 동작하는가</li>\n</ol>\n<p>1번의 경우에서의 완전탐색은 가능한 모든 경우의 수를 확인하여 정확한 답은 얻어 낼 수 있다. 반면에 2번 측면에서는 문제와 주어진 조건에 따라 제한된 시간안에 결과값을 도출할 수 없을 수 있다.</p>\n<p>완전탐색은 가장 기초적으로 알고리즘 문제를 푸는 방식중 하나이지만 완전탐색을 사용할때는 문제를 잘 파악하여 적용시킬 수 있는지 확인하는것이 중요하다.</p>\n<h1 id=\"완전탐색-기법들\" style=\"position:relative;\"><a href=\"#%EC%99%84%EC%A0%84%ED%83%90%EC%83%89-%EA%B8%B0%EB%B2%95%EB%93%A4\" aria-label=\"완전탐색 기법들 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>완전탐색 기법들</h1>\n<p>완전탐색은 그 자체로 알고리즘보단 <strong>문제 풀이</strong> 방법이기 때문에 완전탐색을 구현하기 위한 여러가지 방법들이 존재한다. 주로 이용하는 방법은 아래와 같다.</p>\n<ul>\n<li>Brute-Force</li>\n<li>비트마스크(Bitmask)</li>\n<li>재귀함수(Recursion)</li>\n<li>순열(Permutation)</li>\n<li>DFS/BFS</li>\n</ul>\n<h2 id=\"Brute-Force\" style=\"position:relative;\"><a href=\"#Brute-Force\" aria-label=\"Brute Force permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Brute-Force</h2>\n<p>단순 Brute-Force는 for문 또는 if문을 사용하여 가능한 모든 경우의 수를 확인하여 답을 구하는 방법이다. 이 방법은 가장 기초적인 문제에서 사용이되거나, 전체의 문제에서 일부분에서만 사용된다. 코딩 테스트에서는 거의 이 방법만으로 푸는 문제는 자주등장하지 않는다.</p>\n<h2 id=\"비트마스크Bitmask\" style=\"position:relative;\"><a href=\"#%EB%B9%84%ED%8A%B8%EB%A7%88%EC%8A%A4%ED%81%ACBitmask\" aria-label=\"비트마스크Bitmask permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>비트마스크(Bitmask)</h2>\n<p>비트마스크는 이진수를 사용하는 컴퓨터의 연산 방식을 이용하여, 정수의 이진 표현을 자료 구조로 사용하는 기법을 말한다.</p>\n<p>이진수는 1과 0을 이용하여 하나의 비트에서 사용할 수 있는 가짓수는 2가지이다. 이러한 방식으로 어떤 비트가 1이면 \"존재한다\" 0이면 \"존재하지 않는다\"라고 말할 수 있다.</p>\n<h2 id=\"재귀함수Recursion\" style=\"position:relative;\"><a href=\"#%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98Recursion\" aria-label=\"재귀함수Recursion permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>재귀함수(Recursion)</h2>\n<p>재귀함수란 어떠한 함수에서 자신을 다시 호출하여 작업을하는 방식이다. 재귀 함수는 함수 내에서 자기 자신을 계속 호출하는 방식이기 때문에 함수 안에 <strong>반드시 종료 구간</strong> 을 정해주어야 합니다.</p>\n<h2 id=\"순열Permutation\" style=\"position:relative;\"><a href=\"#%EC%88%9C%EC%97%B4Permutation\" aria-label=\"순열Permutation permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>순열(Permutation)</h2>\n<p>완전 탐색의 대표적인 유형으로. 순열은 순서에 상관있게 선택하는 혹은 나열하는 것을 말한다. N개의 원소가 주어졌을때 순열의 수는 N!개이다.</p>\n<blockquote>\n<p>ex)[1,2,3]이라는 배열이 주어졌을때, 모든 경우의 수</p>\n<p>[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1] 총 6개. -> 3!의 값과 동일한 개수이다</p>\n</blockquote>\n<h2 id=\"DFSBFS\" style=\"position:relative;\"><a href=\"#DFSBFS\" aria-label=\"DFSBFS permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>DFS/BFS</h2>\n<p>약간의 난이도가 있는 문제로 완전 탐색 + BFS/DFS 문제와 그래프를 탐색할때 사용하는 알고리즘이다.</p>\n<h1 id=\"References\" style=\"position:relative;\"><a href=\"#References\" aria-label=\"References permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>References</h1>\n<ul>\n<li><a href=\"https://hongjw1938.tistory.com/78\">https://hongjw1938.tistory.com/78</a></li>\n</ul>","frontmatter":{"title":"알고리즘 완전탐색(Exhaustive search)이란","date":"April 17, 2022","update":"April 17, 2022","tags":["Algorithm","완전탐색"],"series":"Algorithm"},"fields":{"slug":"/brute-force/","readingTime":{"minutes":4.375}}},"seriesList":{"edges":[{"node":{"id":"a6e2b33f-15de-5f46-9612-692c2a3b893b","fields":{"slug":"/programmers-tips-town/"},"frontmatter":{"title":"프로그래머스 2017 팁스타운 - 짝지어 제거하기"}}},{"node":{"id":"92348803-f39f-5558-b4f5-2108ac192122","fields":{"slug":"/programmers-kakao-blind-2020-1/"},"frontmatter":{"title":"프로그래머스 2020 KAKAO BLIND RECRUITMENT - 괄호 변환"}}},{"node":{"id":"fb1f5d3c-d399-50ed-a817-20df36759001","fields":{"slug":"/programmers-kakao-blind-2020-2/"},"frontmatter":{"title":"프로그래머스 2022 KAKAO RECRUITMENT - 신고 결과 받기"}}},{"node":{"id":"31b31189-9fe0-55a7-bc1d-fd7f5a5f204e","fields":{"slug":"/programmers-kakao-blind-2020-3/"},"frontmatter":{"title":"프로그래머스 2022 KAKAO RECRUITMENT - k진수에서 소수 개수 구하기"}}},{"node":{"id":"436137ee-76e2-55d1-8423-e79026957050","fields":{"slug":"/programmers-kakao-blind-2018-1/"},"frontmatter":{"title":"프로그래머스 2018 KAKAO RECRUITMENT - [1차]캐시"}}},{"node":{"id":"a392149d-17e0-5618-9c81-ff93eb50e4ce","fields":{"slug":"/programmers-kakao-blind-2021-1/"},"frontmatter":{"title":"프로그래머스 2021 KAKAO BLIND RECRUITMENT - 순위 검색"}}},{"node":{"id":"a7cdd531-abe3-5f8b-a851-04e96b20b97b","fields":{"slug":"/brute-force/"},"frontmatter":{"title":"알고리즘 완전탐색(Exhaustive search)이란"}}},{"node":{"id":"f045bd0f-f85c-5d2b-8d5e-5071f9308fb5","fields":{"slug":"/greedy/"},"frontmatter":{"title":"그리디 알고리즘(Greedy Algorithm)에 대해"}}},{"node":{"id":"7dbb88c6-1acd-5dfb-ba0b-b33d71f105f6","fields":{"slug":"/dfs-bfs/"},"frontmatter":{"title":"알고리즘 DFS/BFS 탐색 방법 알아보기"}}},{"node":{"id":"8538a459-fc98-5af8-82f2-4ec7fd589e83","fields":{"slug":"/dynamic-programming/"},"frontmatter":{"title":"알고리즘 Dynamic Programming(동적 프로그래밍) 살펴보기"}}},{"node":{"id":"7818114f-7688-56f9-9e8f-2756095022de","fields":{"slug":"/graph-mst/"},"frontmatter":{"title":"그래프 알고리즘이란 + 최소 신장 트리(MST)"}}},{"node":{"id":"100720b0-59e5-5a28-985b-043ebfeba57f","fields":{"slug":"/graph-sortest-path/"},"frontmatter":{"title":"그래프 최단거리 구하기"}}}]},"previous":{"fields":{"slug":"/android-hilt/"},"frontmatter":{"title":"안드로이드 Hilt에 대해 알아보기"}},"next":{"fields":{"slug":"/repository-pattern/"},"frontmatter":{"title":"안드로이드 Repository 패턴은 무엇인가"}}},"pageContext":{"id":"a7cdd531-abe3-5f8b-a851-04e96b20b97b","series":"Algorithm","previousPostId":"e7e7c2d3-ace1-53dc-bd3b-ee4e96ad9b6c","nextPostId":"fcc174d6-e820-5bfb-8407-5db69e9cff26"}},"staticQueryHashes":[],"slicesMap":{}}