{"componentChunkName":"component---src-templates-post-jsx","path":"/brute-force/","result":{"data":{"site":{"siteMetadata":{"title":"ppeper🥤"}},"markdownRemark":{"id":"7241a8e0-c224-55a5-a6b1-8136b4f2356c","excerpt":"완전탐색이란? 완전탐색이란 가능한 모든 경우의 수 를 모두 찾는 방법이다. 이러한 방법은 무식한 한다는 의미로 'Brute Force'라고도 이름이 불린다. 완전탐색은 직관적이어서 이해하기 쉽고, 문제에 대한 결과값이 정확하게 얻을 수 있다 는 점에서 가장 확실하고 기초적인 문제 풀이 방법이다. 알고리즘 문제를 풀때에는 기본적으로 두가지를 생각하고 들어간…","html":"<h1>완전탐색이란?</h1>\n<p>완전탐색이란 <strong>가능한 모든 경우의 수</strong> 를 모두 찾는 방법이다. 이러한 방법은 무식한 한다는 의미로 'Brute Force'라고도 이름이 불린다.</p>\n<p>완전탐색은 <strong>직관적이어서 이해하기 쉽고</strong>, 문제에 대한 <strong>결과값이 정확하게 얻을 수 있다</strong> 는 점에서 가장 확실하고 기초적인 문제 풀이 방법이다.</p>\n<p>알고리즘 문제를 풀때에는 기본적으로 두가지를 생각하고 들어간다.</p>\n<ol>\n<li>해당 알고리즘이 적절한가> -> 문제를 풀 수 있는 방법인가</li>\n<li>효율적인가? -> 제한된 시간이 안에 알고리즘이 동작하는가</li>\n</ol>\n<p>1번의 경우에서의 완전탐색은 가능한 모든 경우의 수를 확인하여 정확한 답은 얻어 낼 수 있다. 반면에 2번 측면에서는 문제와 주어진 조건에 따라 제한된 시간안에 결과값을 도출할 수 없을 수 있다.</p>\n<p>완전탐색은 가장 기초적으로 알고리즘 문제를 푸는 방식중 하나이지만 완전탐색을 사용할때는 문제를 잘 파악하여 적용시킬 수 있는지 확인하는것이 중요하다.</p>\n<h1>완전탐색 기법들</h1>\n<p>완전탐색은 그 자체로 알고리즘보단 <strong>문제 풀이</strong> 방법이기 때문에 완전탐색을 구현하기 위한 여러가지 방법들이 존재한다. 주로 이용하는 방법은 아래와 같다.</p>\n<ul>\n<li>Brute-Force</li>\n<li>비트마스크(Bitmask)</li>\n<li>재귀함수(Recursion)</li>\n<li>순열(Permutation)</li>\n<li>DFS/BFS</li>\n</ul>\n<h2>Brute-Force</h2>\n<p>단순 Brute-Force는 for문 또는 if문을 사용하여 가능한 모든 경우의 수를 확인하여 답을 구하는 방법이다. 이 방법은 가장 기초적인 문제에서 사용이되거나, 전체의 문제에서 일부분에서만 사용된다. 코딩 테스트에서는 거의 이 방법만으로 푸는 문제는 자주등장하지 않는다.</p>\n<h2>비트마스크(Bitmask)</h2>\n<p>비트마스크는 이진수를 사용하는 컴퓨터의 연산 방식을 이용하여, 정수의 이진 표현을 자료 구조로 사용하는 기법을 말한다.</p>\n<p>이진수는 1과 0을 이용하여 하나의 비트에서 사용할 수 있는 가짓수는 2가지이다. 이러한 방식으로 어떤 비트가 1이면 \"존재한다\" 0이면 \"존재하지 않는다\"라고 말할 수 있다.</p>\n<h2>재귀함수(Recursion)</h2>\n<p>재귀함수란 어떠한 함수에서 자신을 다시 호출하여 작업을하는 방식이다. 재귀 함수는 함수 내에서 자기 자신을 계속 호출하는 방식이기 때문에 함수 안에 <strong>반드시 종료 구간</strong> 을 정해주어야 합니다.</p>\n<h2>순열(Permutation)</h2>\n<p>완전 탐색의 대표적인 유형으로. 순열은 순서에 상관있게 선택하는 혹은 나열하는 것을 말한다. N개의 원소가 주어졌을때 순열의 수는 N!개이다.</p>\n<blockquote>\n<p>ex)[1,2,3]이라는 배열이 주어졌을때, 모든 경우의 수</p>\n<p>[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1] 총 6개. -> 3!의 값과 동일한 개수이다</p>\n</blockquote>\n<h2>DFS/BFS</h2>\n<p>약간의 난이도가 있는 문제로 완전 탐색 + BFS/DFS 문제와 그래프를 탐색할때 사용하는 알고리즘이다.</p>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://hongjw1938.tistory.com/78\">https://hongjw1938.tistory.com/78</a></li>\n</ul>","frontmatter":{"title":"알고리즘 완전탐색(Exhaustive search)이란","date":"April 17, 2022","update":"April 17, 2022","tags":["Algorithm","완전탐색"],"series":"Algorithm"},"fields":{"slug":"/brute-force/","readingTime":{"minutes":4.375}}},"seriesList":{"edges":[{"node":{"id":"f95fc217-b9c9-5985-943d-f6db2fd56a30","fields":{"slug":"/programmers-tips-town/"},"frontmatter":{"title":"프로그래머스 2017 팁스타운 - 짝지어 제거하기"}}},{"node":{"id":"de9cf818-57cf-5617-b6f9-aa87e585afa9","fields":{"slug":"/programmers-kakao-blind-2020-1/"},"frontmatter":{"title":"프로그래머스 2020 KAKAO BLIND RECRUITMENT - 괄호 변환"}}},{"node":{"id":"17ca645f-dd9f-516b-aa44-9221aa906278","fields":{"slug":"/programmers-kakao-blind-2020-2/"},"frontmatter":{"title":"프로그래머스 2022 KAKAO RECRUITMENT - 신고 결과 받기"}}},{"node":{"id":"6b276284-ed62-5856-a5e2-c4cabf52acc9","fields":{"slug":"/programmers-kakao-blind-2020-3/"},"frontmatter":{"title":"프로그래머스 2022 KAKAO RECRUITMENT - k진수에서 소수 개수 구하기"}}},{"node":{"id":"e39e5fd5-6c40-5260-b245-d291e7d62b55","fields":{"slug":"/programmers-kakao-blind-2018-1/"},"frontmatter":{"title":"프로그래머스 2018 KAKAO RECRUITMENT - [1차]캐시"}}},{"node":{"id":"243a7274-df6b-570a-8a1e-05e4f556f787","fields":{"slug":"/programmers-kakao-blind-2021-1/"},"frontmatter":{"title":"프로그래머스 2021 KAKAO BLIND RECRUITMENT - 순위 검색"}}},{"node":{"id":"7241a8e0-c224-55a5-a6b1-8136b4f2356c","fields":{"slug":"/brute-force/"},"frontmatter":{"title":"알고리즘 완전탐색(Exhaustive search)이란"}}},{"node":{"id":"052ebb4e-897f-5992-bab6-cd7e92036341","fields":{"slug":"/greedy/"},"frontmatter":{"title":"그리디 알고리즘(Greedy Algorithm)에 대해"}}},{"node":{"id":"f808b5c3-3d94-5f20-a7cc-a1441209d3e6","fields":{"slug":"/dfs-bfs/"},"frontmatter":{"title":"알고리즘 DFS/BFS 탐색 방법 알아보기"}}},{"node":{"id":"aa2be475-c199-5487-bf60-b883bea887af","fields":{"slug":"/dynamic-programming/"},"frontmatter":{"title":"알고리즘 Dynamic Programming(동적 프로그래밍) 살펴보기"}}},{"node":{"id":"459edbb5-9a63-5390-9b2e-331fa9d3d4ad","fields":{"slug":"/graph-mst/"},"frontmatter":{"title":"그래프 알고리즘이란 + 최소 신장 트리(MST)"}}},{"node":{"id":"67819626-dcdc-5ece-bab4-311c5c8f6097","fields":{"slug":"/graph-sortest-path/"},"frontmatter":{"title":"그래프 최단거리 구하기"}}}]},"previous":{"fields":{"slug":"/android-hilt/"},"frontmatter":{"title":"안드로이드 Hilt에 대해 알아보기"}},"next":{"fields":{"slug":"/repository-pattern/"},"frontmatter":{"title":"안드로이드 Repository 패턴은 무엇인가"}}},"pageContext":{"id":"7241a8e0-c224-55a5-a6b1-8136b4f2356c","series":"Algorithm","previousPostId":"bb9a7240-98d9-538d-9224-6d110a0f0358","nextPostId":"bf6ff02b-6b19-5062-a565-0d3f1955be42"}},"staticQueryHashes":[],"slicesMap":{}}