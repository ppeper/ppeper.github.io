{"componentChunkName":"component---src-templates-post-jsx","path":"/graph-sortest-path/","result":{"data":{"site":{"siteMetadata":{"title":"ppeper🥤"}},"markdownRemark":{"id":"67819626-dcdc-5ece-bab4-311c5c8f6097","excerpt":"🚀최단 경로 탐색 지난 시간에는 그래프와 최소 신장 트리(MST)를 구하는 알고리즘인 프림, 크루스칼 알고리즘을 알아보았다. (그래프 알고리즘이란 + 최소 신장 트리(MST)) 이번 포스팅은 그래프 최단 거리를 구하는 알고리즘에 대해서 알아보려고 한다. 📌다익스트라 다익스트라(dijkstra) 알고리즘은 그래프에서 최단 경로를 구하는 알고리즘 중 하나이다…","html":"<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/170924395-e92bdf93-a6f9-4ad4-a57a-5a996edcbe7e.png\" width=\"70%\"></p>\n출처: 픽사베이\n<h1>🚀최단 경로 탐색</h1>\n<p>지난 시간에는 그래프와 최소 신장 트리(MST)를 구하는 알고리즘인 프림, 크루스칼 알고리즘을 알아보았다. <a href=\"https://ppeper.github.io/algorithm/graph/\">(그래프 알고리즘이란 + 최소 신장 트리(MST))</a></p>\n<p>이번 포스팅은 그래프 최단 거리를 구하는 알고리즘에 대해서 알아보려고 한다.</p>\n<h2>📌다익스트라</h2>\n<blockquote>\n<p>다익스트라(dijkstra) 알고리즘은 그래프에서 최단 경로를 구하는 알고리즘 중 하나이다. 다익스트라 알고리즘은 도착 정점 뿐만 아니라 <strong>하나의 정점에서 모든 다른 정점까지 최단 경로로 방문하며 각 정점까지의 최단 경로</strong> 를 모두 찾게 된다.</p>\n</blockquote>\n<ul>\n<li>\n<p>인접행렬을 사용: 정점의 수가 N일때, 인접행렬을 사용하면 각 단계마다 N개의 정점을 가중치가 짧은 간선을 찾기위해 순사탐색을 진행한다.</p>\n<ul>\n<li><strong>시간 복잡도: O(N²)</strong></li>\n</ul>\n</li>\n<li>우선순위 큐 사용: 노드의 개수 V, 간선의 개수 E라고 했을때, 모든 간선을 확인하는 O(E)와 우선순위 큐에 최대로 들어갈 수 있는 수 O(E)와 추가 또는 삭제할때 드는 비용 O(LogE) -> 우선순위 큐에서의 시간 복잡도는 O(ELogE).</li>\n</ul>\n<p>따라서 전체 시간 복잡도는 O(E + ELogE) = O(ELogE)이고, 보통 E &#x3C;= V² 이므로, <strong>O(ELogV)</strong> 라고 볼 수 있다.</p>\n<h3>동작 과정(우선순위 큐)</h3>\n<ol>\n<li>모든 노드에 대한 거리를 무한대 값(충분히 큰 값)으로 초기화</li>\n<li>시작 노드에 대한 거리를 0으로 초기화 후 우선순위 큐에 담음</li>\n<li>우선순위 큐에서 가져온 노드에 대한 인접한(갈수 있는 노드)노드를 확인</li>\n<li>더 빠르면 거리를 갱신하고 우선순위 큐에 넣어줌</li>\n<li>방문 or 더 느리면 continue</li>\n<li>우선순위 큐가 empty될때까지 3~5 반복</li>\n</ol>\n<p>간단하게 1,2,3번 노드를 가지는 그래프에서 거리가 갱신되는 과정을 보면 아래와 같다.</p>\n<img src=\"https://user-images.githubusercontent.com/63226023/169876693-1b222949-9886-4093-9aae-81bacfc62c01.png\">\n<h3>코드(우선순위 큐)</h3>\n<p>인접한 정점들에 대한 list는 graph로 생성하였다고 가정</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">data</span> <span class=\"token keyword\">class</span> <span class=\"token function\">Node</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">val</span> end<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> weight<span class=\"token operator\">:</span> Int\n<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 최단 경로 리스트</span>\n<span class=\"token keyword\">val</span> distance <span class=\"token operator\">=</span> <span class=\"token function\">IntArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> Int<span class=\"token punctuation\">.</span>MAX_VALUE <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">dijkstra</span><span class=\"token punctuation\">(</span>start<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 시작 노드의 거리는 0</span>\n    distance<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token comment\">// 기준은 가중치로 오름차순</span>\n    <span class=\"token keyword\">val</span> pq <span class=\"token operator\">=</span> PriorityQueue<span class=\"token operator\">&lt;</span>Node<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>compareBy <span class=\"token punctuation\">{</span> it<span class=\"token punctuation\">.</span>weight <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// 시작 노드</span>\n    pq<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token function\">Node</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>pq<span class=\"token punctuation\">.</span><span class=\"token function\">isNotEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">val</span> curr <span class=\"token operator\">=</span> pq<span class=\"token punctuation\">.</span><span class=\"token function\">poll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\">// 새로 선택된 node보다 더 가중치가 적음 -> 방문한 느드</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>distance<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">.</span>end<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> curr<span class=\"token punctuation\">.</span>weight<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">continue</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\">// 현재 시작 노드의 인접 노드들 확인</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>node <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">.</span>end<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">val</span> nextNode <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>end\n            <span class=\"token comment\">// 다음 노드까지의 거리 + 현재 노드까지의 거리 -> 방문후 가는 거리</span>\n            <span class=\"token keyword\">val</span> nextDistance <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>weight <span class=\"token operator\">+</span> curr<span class=\"token punctuation\">.</span>weight\n            <span class=\"token comment\">// 지금까지의 거리 보다 방문후 가는 거리가 짧으면 업데이트 후 우선순위 큐에 넣어줌</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextDistance <span class=\"token operator\">&lt;</span> distance<span class=\"token punctuation\">[</span>nextNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                distance<span class=\"token punctuation\">[</span>nextNode<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nextDistance\n                pq<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token function\">Node</span><span class=\"token punctuation\">(</span>nextNode<span class=\"token punctuation\">,</span> nextDistance<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>📌벨만 포드</h2>\n<blockquote>\n<p>다익스트라 알고리즘과 마친가지로  <strong>_하나의 정점에서 모든 다른 정점까지 최단 경로로 방문하며 각 정점까지의 최단 거리</strong> 를 찾을 수 있지만 차이점은 <strong>음의 가중치가 있는 그래프</strong> 에서 사용할 수 있다. </p>\n</blockquote>\n<p>벨만 포드 알고리즘에서는 <strong>음수 사이클</strong> 로 인하여 최단 거리를 정의할 수 없는 경우도 알아낼 수 있다.</p>\n<img src=\"https://user-images.githubusercontent.com/63226023/170925669-279f8a63-2a15-46b5-b110-d7d2ff30a814.png\">\n<blockquote>\n<p>1->2->3으로 가는경우 무한히 작아질 수 있으므로 최단 거리를 구할 수 없음 -> 계속 노드를 거쳐가면 1 + 2 -4 = -1 이므로 음의방향으로 발산한다.</p>\n</blockquote>\n<p>벨만 포드 알고리즘과 다익스트라 알고리즘의 차이점은 <strong>음수 가중치</strong> 가 존재하는 경우에도 적용할 수 있다는 것이며, 시간 복잡도는 <strong>O(VE)</strong> (V: 정점 개수, E: 간선 대수)로 다익스트라에서 우선순위 큐를 이용한 방식인 <strong>O(ELogV)</strong> 보다 느리다.</p>\n<h3>동작 과정</h3>\n<ol>\n<li>모든 노드에 대한 거리를 무한대 값(충분히 큰 값)으로 초기화</li>\n<li>\n<p>다음의 과정을 V-1번 반복한다.</p>\n<ul>\n<li>모든 간선 E개를 순서대로 확인한다.</li>\n<li>각 간선을 가쳐가 다른 노드로 가는 비용을 비교하여 최단 거리로 갱신한다.</li>\n</ul>\n</li>\n<li>음수 간선 순환이 발생하는지 확인하기 위해서는 2번의 과정을 한 번 더 수행한다. -> 최단 거리가 갱신이 된다면 음수 간선 순환이 존재한다.</li>\n</ol>\n<h3>코드</h3>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">bellmanFord</span><span class=\"token punctuation\">(</span>start<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Boolean <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 최단 경로 리스트</span>\n    <span class=\"token keyword\">val</span> distance <span class=\"token operator\">=</span> <span class=\"token function\">IntArray</span><span class=\"token punctuation\">(</span>graph<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> INF <span class=\"token punctuation\">}</span>\n    distance<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">.</span>indices<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>j <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">.</span>indices<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>graph<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> INF<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>distance<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> graph<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    distance<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> graph<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span>\n                    <span class=\"token comment\">// N번째에서 갱신이 되었다면 음수 사이클 존재</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">==</span> graph<span class=\"token punctuation\">.</span>size <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>📌플로이드 와샬</h2>\n<blockquote>\n<p>플로이드 와샬 알고리즘은 벨만포드와 같이 <strong>음의 가중치가 있는 그래프</strong> 에서 사용할 수 있고, 차이점은 하나의 정점이 아닌 <strong>모든 정점에서 모든 다른 정점으로 가는 최단 거리</strong> 를 구할 수 있다. 다시 말하여 <strong>다른 정점을 경유</strong> 하여 도착하는 최단 거리를 구할 수 있다.</p>\n</blockquote>\n<p>플로이드-워셜 알고리즘은 DP(Dynamic Programming) 기법을 사용한 알고리즘이다. 각 정점으로 부터 <strong>다른 정점을 순차적으로 거쳐가면서 더 짧은 길이를 선택</strong> 하여 갱신 한다.</p>\n<p>다익스트라와 다른점은 정점까지의 거리 dist 배열을 <strong>모든 정점</strong> 에서 모든 다른 정점으로 가는 최단 거리를 구해야 하므로 정점의 개수 V일때 V * V 크기의 dist 배열을 생성해주어야한다. </p>\n<img src=\"https://user-images.githubusercontent.com/63226023/170028092-efb435f9-1df9-406a-8c81-cb1be9081667.png\">\n<p>위의 거리 배열에서 각 dist[i][i]는 시작 정점으로 자기자신에 대한 거리는 0이므로 초기화 해준다.</p>\n<h3>동작 과정</h3>\n<ol>\n<li>\n<p>인접행렬을 저장할 2차원 배열을 만들고 무한대(충분히 큰 값)로 초기화한다.</p>\n<ul>\n<li>자기자신([i][i])는 0으로 초기화</li>\n<li>그래프에 따라 간선 정보를 저장한다.</li>\n</ul>\n</li>\n<li>\n<p>경유지를 거쳐가는 것이 빠르다면 거리 배열을 갱신 해준다.</p>\n<ul>\n<li>(시작: i, 도착: j일때 k가 경유 노드라면, dist[i][j] = min(dist[i][k] + dist[k][j])로 갱신)</li>\n</ul>\n</li>\n<li>모든 정점에 대해 순차적으로 경유지로 선택하여 2번 과정을 반복한다.</li>\n</ol>\n<h3>코드</h3>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">floyd</span><span class=\"token punctuation\">(</span>dist<span class=\"token operator\">:</span> Array<span class=\"token operator\">&lt;</span>IntArray<span class=\"token operator\">></span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// k -> 거쳐가는 노드</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>k <span class=\"token keyword\">in</span> <span class=\"token number\">0</span> until n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// i -> 출발 노드</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token keyword\">in</span> <span class=\"token number\">0</span> until n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">// j -> 도착 노드</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>j <span class=\"token keyword\">in</span> <span class=\"token number\">0</span> until n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                dist<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> dist<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">coerceAtMost</span><span class=\"token punctuation\">(</span>dist<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> dist<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<hr>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://born2bedeveloper.tistory.com/44\">https://born2bedeveloper.tistory.com/44</a></li>\n<li><a href=\"https://reinvestment.tistory.com/58\">https://reinvestment.tistory.com/58</a></li>\n</ul>","frontmatter":{"title":"그래프 최단거리 구하기","date":"May 30, 2022","update":"May 30, 2022","tags":["Algorithm","다익스트라","플로이드 와샬","벨만포드"],"series":"Algorithm"},"fields":{"slug":"/graph-sortest-path/","readingTime":{"minutes":9.005}}},"seriesList":{"edges":[{"node":{"id":"f95fc217-b9c9-5985-943d-f6db2fd56a30","fields":{"slug":"/programmers-tips-town/"},"frontmatter":{"title":"프로그래머스 2017 팁스타운 - 짝지어 제거하기"}}},{"node":{"id":"de9cf818-57cf-5617-b6f9-aa87e585afa9","fields":{"slug":"/programmers-kakao-blind-2020-1/"},"frontmatter":{"title":"프로그래머스 2020 KAKAO BLIND RECRUITMENT - 괄호 변환"}}},{"node":{"id":"17ca645f-dd9f-516b-aa44-9221aa906278","fields":{"slug":"/programmers-kakao-blind-2020-2/"},"frontmatter":{"title":"프로그래머스 2022 KAKAO RECRUITMENT - 신고 결과 받기"}}},{"node":{"id":"6b276284-ed62-5856-a5e2-c4cabf52acc9","fields":{"slug":"/programmers-kakao-blind-2020-3/"},"frontmatter":{"title":"프로그래머스 2022 KAKAO RECRUITMENT - k진수에서 소수 개수 구하기"}}},{"node":{"id":"e39e5fd5-6c40-5260-b245-d291e7d62b55","fields":{"slug":"/programmers-kakao-blind-2018-1/"},"frontmatter":{"title":"프로그래머스 2018 KAKAO RECRUITMENT - [1차]캐시"}}},{"node":{"id":"243a7274-df6b-570a-8a1e-05e4f556f787","fields":{"slug":"/programmers-kakao-blind-2021-1/"},"frontmatter":{"title":"프로그래머스 2021 KAKAO BLIND RECRUITMENT - 순위 검색"}}},{"node":{"id":"7241a8e0-c224-55a5-a6b1-8136b4f2356c","fields":{"slug":"/brute-force/"},"frontmatter":{"title":"알고리즘 완전탐색(Exhaustive search)이란"}}},{"node":{"id":"052ebb4e-897f-5992-bab6-cd7e92036341","fields":{"slug":"/greedy/"},"frontmatter":{"title":"그리디 알고리즘(Greedy Algorithm)에 대해"}}},{"node":{"id":"f808b5c3-3d94-5f20-a7cc-a1441209d3e6","fields":{"slug":"/dfs-bfs/"},"frontmatter":{"title":"알고리즘 DFS/BFS 탐색 방법 알아보기"}}},{"node":{"id":"aa2be475-c199-5487-bf60-b883bea887af","fields":{"slug":"/dynamic-programming/"},"frontmatter":{"title":"알고리즘 Dynamic Programming(동적 프로그래밍) 살펴보기"}}},{"node":{"id":"459edbb5-9a63-5390-9b2e-331fa9d3d4ad","fields":{"slug":"/graph-mst/"},"frontmatter":{"title":"그래프 알고리즘이란 + 최소 신장 트리(MST)"}}},{"node":{"id":"67819626-dcdc-5ece-bab4-311c5c8f6097","fields":{"slug":"/graph-sortest-path/"},"frontmatter":{"title":"그래프 최단거리 구하기"}}}]},"previous":{"fields":{"slug":"/graph-mst/"},"frontmatter":{"title":"그래프 알고리즘이란 + 최소 신장 트리(MST)"}},"next":{"fields":{"slug":"/datastore/"},"frontmatter":{"title":"새로운 동료 DataStore 알아보기"}}},"pageContext":{"id":"67819626-dcdc-5ece-bab4-311c5c8f6097","series":"Algorithm","previousPostId":"459edbb5-9a63-5390-9b2e-331fa9d3d4ad","nextPostId":"8c9cfe55-c118-5907-b606-febd84308e2f"}},"staticQueryHashes":[],"slicesMap":{}}