{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"모바일 개발을 진행하다 보면 이미지, 동영상과 같이 파일을 업로드 하는 경우가 생기기 마련이다. 이때  라는 개념을 처음 접하게 된다. 이전에 안드로이드 네트워크 라이브러리로 Retrofit을 사용했던 경험을 토대로 Multiplatform 사용하고 있는 Ktrofit 라이브러리에서 사용하는 방법을 보려고 한다. Multipart 모바일 개발에서 이미지 …","fields":{"slug":"/multipart/"},"frontmatter":{"date":"March 20, 2025","title":"Ktor와 Multipart로 파일 업로드 근데 이제 Ktrofit을 곁들인","tags":["Android","Compose","Multipart","Ktor"]},"rawMarkdownBody":"\r\n> 모바일 개발을 진행하다 보면 이미지, 동영상과 같이 파일을 업로드 하는 경우가 생기기 마련이다. 이때 `Multipart` 라는 개념을 처음 접하게 된다. 이전에 안드로이드 네트워크 라이브러리로 Retrofit을 사용했던 경험을 토대로 Multiplatform 사용하고 있는 Ktrofit 라이브러리에서 사용하는 방법을 보려고 한다.\r\n\r\n# Multipart\r\n\r\n모바일 개발에서 이미지 업로드를 구현하다 보면 \"Multipart로 보내야 한다\"는 것을 찾아보게 된다. \r\n\r\n`Multipart`는 여러 개의 데이터를 하나의 HTTP 요청에 포함시키는 방식으로, 보통 파일 업로드나 데이터를 여러 부분으로 나누어 서버에 전달할 때 사용된다. 이 방식은 `Content-Type: multipart/form-data` 헤더를 사용하여 데이터가 여러 파트로 나누어져 전송된다는 것을 서버에 알린다.\r\n\r\n이 개념은 웹에서 파일 업로드를 처리하는 데 많이 사용되며, 이미지, 비디오, 오디오 파일과 같은 바이너리 데이터를 HTTP를 통해 서버로 전송할 때 사용하는 방법이다. 각 파트는 특정 형식으로 나누어지며, 이 방식은 데이터를 다른 형식(예: 텍스트, 파일 등)으로 혼합하여 전송할 수 있도록 한다.\r\n\r\n## multipart/form-data\r\n\r\n![](./http-request.png)\r\n\r\n\r\nHTTP Request에는 위와 같이 4가지 파트로 나눌 수 있다.\r\n\r\nHTTP 통신에는 헤더로 `Content-Type`을 지정하게 되는데 이는 리소스의 미디어 타입을 나타내기 위해 사용된다. 기본적으로 사용하는 CRUD를 살펴보면 헤더는 `application/json` 을 사용하는데 이는 json 타입임을 나타낸다. (요즘은 json 형태로 서버와 데이터를 주고 받아 자연스럽게 사용중인듯 하다)\r\n\r\n이와 같이 `multipart/form-data` 는 __file__ 을 업로드 하기 위해서 사용되는 Type이다. 이름과 같이 이 형식의 요청은 각 파트별로 분리하여 개별 파일의 정보를 얻게 된다.\r\n\r\nMultipart 요청을 보낼 때는 `POST` HTTP 메소드를 사용해서 보낸다. 이때 Boundary라는 것을 통해 각 파트별로 분리할 수 있도록 하여 서버에서 각각 데이터를 읽을 수 있게 된다.\r\n\r\n> Boundary? : 파일을 첨부할 때 브라우저가 생성한 값으로, 여러 파일이 전송되었을때 이를 구분하기 위해서 사용된다. \r\n\r\n# 방법 알아보기\r\n\r\n현재 개발중인 서비스는 안드로이드와 Desktop에서 사용할 수 있도록 개발하고 있으며 네트워크 라이브러리로 Ktor와 Ktorfit을 사용하고 있다. 먼저 Ktor에서는 [공식문서](https://ktor.io/docs/client-requests.html#upload_file)에 `submitFormWithBinaryData` 를 사용하면 된다고 한다. 프로젝트에서는 Ktorfit을 골자로 사용하고 있으므로 이를 더 살펴보도록 하겠다.\r\n\r\nKtorfit의 [공식문서](https://foso.github.io/Ktorfit/requests/#multipart)에서는 두가지 방법을 알려주고 있다.\r\n\r\n## 1. @Body\r\n\r\n```kotlin\r\ninterface ExampleService {\r\n    @POST(\"upload\")\r\n    suspend fun upload(@Body map: MultiPartFormDataContent)\r\n}\r\n```\r\n\r\n@Body 어노테이션이 붙은 `MultiPartFormDataContent` 타입의 파라미터를 사용한다.\r\n\r\n```kotlin\r\nval multipart = MultiPartFormDataContent(formData {\r\n    append(\"description\", \"Ktor logo\")\r\n    append(\"image\", File(\"ktor_logo.png\").readBytes(), Headers.build {\r\n        append(HttpHeaders.ContentType, \"image/png\")\r\n        append(HttpHeaders.ContentDisposition, \"filename=ktor_logo.png\")\r\n    })\r\n})\r\n\r\nexampleApi.upload(multipart)\r\n```\r\n\r\n## 2. @Multipart\r\n\r\n```kotlin\r\n@Multipart\r\n@POST(\"upload\")\r\nsuspend fun uploadFile(@Part(\"description\") description: String, @Part(\"\") file: List<PartData>): String\r\n```\r\n\r\n함수에 @Multipart 어노테이션과 @Part 어노테이션을 붙은 파라미터를 사용하면 해당 어노테이션이 붙은 파라미터들은 MultiPartFormDataContent 형태로 합쳐저 보내게 된다.\r\n\r\n```kotlin\r\nval multipart = formData {\r\n    append(\"image\", File(\"ktor_logo.png\").readBytes(), Headers.build {\r\n        append(HttpHeaders.ContentType, \"image/png\")\r\n        append(HttpHeaders.ContentDisposition, \"filename=ktor_logo.png\")\r\n    })\r\n}\r\n\r\nexampleApi.upload(\"Ktor logo\",multipart)\r\n```\r\n\r\n## 문제 발생\r\n처음에는 두 번째 방식인 @Multipart를 붙여 구현하려 했지만 __Required request part 'file' is not present__ 이라는 에러를 계속 마주했다 😭. 해당 에러는 파일이 서버로 넘어오지 않았을때 발생한다고 되어있어 확인했지만 문제되는 코드는 없었다. \r\n\r\n계속 Multipart에 필요한 Content-Type, Content-Disposition 등을 바꾸거나 여러가지를 시도했지만 계속 똑같은 에러가 발생했는데, ktorfit 공식 github에서 하나의 issue를 찾게 되었다..!.\r\n\r\n![](./multipart-issue.png)\r\n\r\n\r\n해당 issue를 생성한 개발자분도 같은 문제로 @Multipart 방법은 되지 않고 `@Body` 를 사용한 MultiPartFormDataContent만 된다는 내용이 있었다.\r\n\r\n> 라이브러리를 사용할때 내부 코드나 해당 오픈소스를 잘 살펴봐야겠다..! (혹시 @Multipart를 사용해도 문제가 없으신 분은 알려주시면 감사하겠습니다! 🙇🏻)\r\n\r\n# 구현 간단하게 살펴보기\r\n\r\n현재 Android와 Desktop에서 동작하는 서비스를 개발하고 있어 File에 대해 다른점이 있었다. Android의 경우 이미지, 동영상과 같은 파일은 contentResolver를 통해 uri 형태로 가져오게 되고 Desktop의 경우 File의 형태로 가져올 수 있다. \r\n\r\nDesktop의 경우 JFileChooser와 같이 파일 선택기를 사용할 수 있고 Android의 경우 Content Uri를 가져오는 방식은 서비스 마다 다르게 [사진 선택 도구](https://developer.android.com/training/data-storage/shared/photopicker?hl=ko) 나 ContentProvider로 가져올 수 있다.\r\n\r\nMultipart 업로드에 초점을 맞춰 Uri와 File을 받아온 이후부터 업로드하는 부분만 확인해 보자!\r\n\r\n먼저 각 플랫폼에 맞게 필수로 필요한 값들을 다음과 같이 정의하여 추가하였다.\r\n> 1. File의 ByteArray\r\n> 2. MIME type\r\n\r\n```kotlin\r\nexpect class PlatformFile {\r\n    fun toByteArray(): ByteArray\r\n    fun getMimeType(): String\r\n}\r\n\r\n// Android\r\nactual class PlatformFile(\r\n    private val uri: Uri?,\r\n    private val contentResolver: ContentResolver\r\n) {\r\n    actual fun toByteArray(): ByteArray {\r\n        return uri?.let { contentResolver.openInputStream(it)?.readBytes() } ?: byteArrayOf()\r\n    }\r\n\r\n    actual fun getMimeType(): String {\r\n        return uri?.let { contentResolver.getType(it) }.orEmpty()\r\n    }\r\n}\r\n\r\n\r\n// Desktop\r\nactual class PlatformFile(\r\n    private val file: File?\r\n) {\r\n    actual fun toByteArray(): ByteArray {\r\n        return file?.readBytes() ?: byteArrayOf()\r\n    }\r\n\r\n    // probeContentType -> mimeType을 가져온다\r\n    actual fun getMimeType(): String {\r\n        return file?.let { Files.probeContentType(it.toPath()) }.orEmpty()\r\n    }\r\n}\r\n\r\n\r\n안드로이드의 경우 Compose를 사용하여 개발하고 있는데 화면에서 다음과 같이 `ContentResolver`를 가져올 수 있다.\r\n\r\n@Composable\r\nfun Screen() {\r\n    val context = LocalContext.current\r\n    val contentResolver = context.contentResolver\r\n    // 사용하는 곳에서 넘겨주기\r\n}\r\n```\r\n\r\n## 1. Body 방식으로 파일 업로드\r\n이제 MultipartDataContent로 업로드를 하면된다.\r\n\r\n```kotlin\r\n@POST\r\nsuspend fun uploadFile(\r\n    // other parameter\r\n    @Body file: MultiPartFormDataContent\r\n)\r\n\r\n// 사용하는 Repository 코드에서\r\nsuspend fun postUploadFile(\r\n    byteArray: ByteArray,\r\n    mimeType: String\r\n) {\r\n    val extension = mimeType.substringAfter(\"/\")\r\n    val multipart = MultiPartFormDataContent(\r\n    formData {\r\n        // 서버에서 지정한 \"key\" 값\r\n        append(\"{your_key}\", byteArray, Headers.build {\r\n            append(HttpHeaders.ContentType, mimeType)\r\n            append(HttpHeaders.ContentDisposition,  \"filename={file_name}.$extension\")\r\n        })\r\n    })\r\n    {yourService}.uploadFile(multipart)\r\n}\r\n```\r\n\r\n# References\r\n\r\n- [https://jw910911.tistory.com/117](https://jw910911.tistory.com/117)\r\n- [https://foso.github.io/Ktorfit/](https://foso.github.io/Ktorfit/)"},{"excerpt":"사이드 프로젝트 중 스쿼클 모양을 디자인에 구현해야 하는 상황이 생겨, Compose의 Custom View를 활용하여 해당 화면을 구현하며 학습한 내용을 정리하고자 합니다. 스쿼클? 스쿼클은 정사각형과 원의 중간 형태로, 과 의 합성어이다. 위의 이미지에서 볼 수 있듯이, 일반적인 라운드 처리된 사각형과 비교하면 더 부드러운 곡률로 연결된 것을 알 수 …","fields":{"slug":"/compose-bezier/"},"frontmatter":{"date":"January 07, 2025","title":"Compose에서 Bezier 곡선으로 스쿼클 만들기","tags":["Android","Compose","Canvas"]},"rawMarkdownBody":"> 사이드 프로젝트 중 스쿼클 모양을 디자인에 구현해야 하는 상황이 생겨, Compose의 Custom View를 활용하여 해당 화면을 구현하며 학습한 내용을 정리하고자 합니다.\r\n\r\n# 스쿼클?\r\n<img src = \"squircle-and-round-image.png\">\r\n\r\n스쿼클은 정사각형과 원의 중간 형태로, `정사각형`과 `원`의 합성어이다. 위의 이미지에서 볼 수 있듯이, 일반적인 라운드 처리된 사각형과 비교하면 더 부드러운 곡률로 연결된 것을 알 수 있다.\r\n\r\nCompose에서는 `Canvas` 스코프 내에서 `draw`라는 접두사가 붙은 함수를 활용해 커스텀 UI를 그릴 수 있다.\r\n\r\n<img src = \"canvas-draw-functions.png\">\r\n\r\n일반적인 선으로 이루어진 Chart 화면, 그래프와 같은 경우는 `Path()` 와 `drawPath()` 를 사용하여 그리면 될 것이다. 하지만 스쿼클의 경우 곡선 처리가 되어 있어 쉽지 않을 것이다.\r\n\r\n## Bezier Curve\r\n> Bezier Curve는 부드러운 곡선을 만드는데 이용되고 있으며, CAD, 컴퓨터 그래픽등 컴퓨터 환경에서 널리 쓰인다.\r\n>\r\n> (🗣️ TMI: 학부 시절 컴퓨터 그래픽스 수업에서 Bezier Curve를 배웠던 기억이 문득났다.)\r\n\r\nBezier Curve는 `조절점(Control point)` 를 사용해 직선을 점차 기울여 곡선을 만드는 방식이다. 이 조절점은 n개가 있을 수 있으며, n개일때를 `n-1차 Bezier Curve` 라고 한다.\r\n\r\n아래의 영상에서 Bezier Curve를 간략하게 설명하고 있으니 참고하면 좋습니다!\r\n\r\n`youtube: https://www.youtube.com/embed/pnYccz1Ha34?si=Ownd81WYKoXqXcFG`\r\n\r\n요약하자면\r\n- 1차 Bezier Curve는 t가 0에서 1로 이동하면서 조절점 하나가 직선을 이루는 방식이다.\r\n- 2차는 조절점 두 개를 사용해 곡선을 그리며, 조절점이 많아질수록 더욱 복잡한 곡선을 그릴 수 있다.\r\n\r\nCompose에서는 Bezier Curve를 그리기 위한 여러 함수를 제공하며, `quadraticBezierTo()`는 2차, `cubicTo()`는 3차 Bezier Curve를 그릴 수 있다.\r\n\r\n```kotlin\r\nfun quadraticBezierTo(x1: Float, y1: Float, x2: Float, y2: Float)\r\n\r\n/**\r\n    * Adds a quadratic bezier segment that curves from the current\r\n    * point to the point at the offset ([dx2], [dy2]) from the current point,\r\n    * using the control point at the offset ([dx1], [dy1]) from the current\r\n    * point.\r\n    */\r\nfun relativeQuadraticBezierTo(dx1: Float, dy1: Float, dx2: Float, dy2: Float)\r\n\r\n/**\r\n    * Adds a cubic bezier segment that curves from the current point\r\n    * to the given point ([x3], [y3]), using the control points ([x1], [y1]) and\r\n    * ([x2], [y2]).\r\n    */\r\nfun cubicTo(x1: Float, y1: Float, x2: Float, y2: Float, x3: Float, y3: Float)\r\n\r\n/**\r\n    * Adds a cubic bezier segment that curves from the current point\r\n    * to the point at the offset ([dx3], [dy3]) from the current point, using\r\n    * the control points at the offsets ([dx1], [dy1]) and ([dx2], [dy2]) from the\r\n    * current point.\r\n    */\r\nfun relativeCubicTo(dx1: Float, dy1: Float, dx2: Float, dy2: Float, dx3: Float, dy3: Float)\r\n```\r\n\r\n> `cubicTo()` 함수는 3개의 정점을 받게 되는데 이는 3차 베지어 곡선으로 앞의 점 3개를 이용하여 2차 베지어 곡선을 그리고, 나머지 3개의 점으로 다시 2차 베지어 곡선을 그린 것을 선형 보간하는 방식으로 그려진다.\r\n\r\n## 스쿼클 그리기\r\n\r\n[스쿼클을 웹사이트](https://cubic-bezier.com/#.17,.67,.83,.67)에서 미리 시물레이션 해볼 수 있는 사이트가 있어 혹시 그리게 될 디자인이 있다면 조절점들을 이동하며 확인해 보고 구현할 수 있다.\r\n\r\n<img src = \"squircle-my-design.png\">\r\n\r\n스쿼클을 그리기 위해 조절점들을 start, c1, c2, end로 잡아 (start ~ c2), (c1 ~ end) 를 이용해서 그리도록 구상했다. 이 과정을 반복하여 전체 도형을 완성하도록 하자.\r\n\r\n\r\n```kotlin\r\nPreview\r\n@Composable\r\nfun SquircleShapeWithIcon(\r\n    modifier: Modifier = Modifier.size(200.dp),\r\n    backgroundColor: Color = Color(0xFFFBFBFB),\r\n    content: @Composable () -> Unit = {\r\n        Icon(\r\n            modifier = Modifier.size((200 / 3).dp),\r\n            tint = Color(0xFFFF814D),\r\n            painter = painterResource(id = R.drawable.icon_student_check),\r\n            contentDescription = null\r\n        )\r\n    },\r\n) {\r\n    Box(\r\n        modifier = modifier,\r\n        contentAlignment = Alignment.Center\r\n    ) {\r\n\r\n        Canvas(\r\n            modifier = Modifier.fillMaxSize()\r\n        ) { // 원하는 크기\r\n            val width = size.width\r\n            val height = size.height\r\n\r\n            val path = Path().apply {\r\n                // 시작점 (상단 중앙)\r\n                moveTo(width / 2, 0f)\r\n\r\n                // 상단 오른쪽 코너\r\n                cubicTo(\r\n                    width.times(0.95f), 0f, // 첫 번째 컨트롤 포인트\r\n                    width, height.times(0.05f), // 두 번째 컨트롤 포인트\r\n                    width, height / 2 // 도착점\r\n                )\r\n\r\n                // 오른쪽 아래 코너\r\n                cubicTo(\r\n                    width, height.times(0.95f), // 첫 번째 컨트롤 포인트\r\n                    width.times(0.95f), height, // 두 번째 컨트롤 포인트\r\n                    width / 2, height // 도착점\r\n                )\r\n\r\n                // 아래쪽 왼쪽 코너\r\n                cubicTo(\r\n                    width.times(0.05f), height, // 첫 번째 컨트롤 포인트\r\n                    0f, height.times(0.95f), // 두 번째 컨트롤 포인트\r\n                    0f, height / 2 // 도착점\r\n                )\r\n\r\n                // 왼쪽 위 코너\r\n                cubicTo(\r\n                    0f, height.times(0.05f),\r\n                    width.times(0.05f), 0f,\r\n                    width / 2, 0f\r\n                )\r\n\r\n                close()\r\n            }\r\n\r\n            drawPath(\r\n                path = path,\r\n                color = backgroundColor\r\n            )\r\n        }\r\n        content()\r\n    }\r\n}\r\n```\r\n위 코드는 Slot API 형식을 사용하여 Preview용 Icon을 삽입한 코드로 결과는 아래와 같다.\r\n\r\n<img src=\"design-preview.png\" width=\"50%\">\r\n\r\n# References\r\n- [https://namu.wiki](https://namu.wiki/w/%EB%B2%A0%EC%A7%80%EC%97%90%20%EA%B3%A1%EC%84%A0)\r\n- [https://cubic-bezier.com/#.17,.67,.83,.67](https://cubic-bezier.com/#.17,.67,.83,.67)\r\n- [https://charlezz.com/?p=46274](https://charlezz.com/?p=46274)\r\n- [https://woongsios.tistory.com/70](https://woongsios.tistory.com/70)\r\n- [https://www.youtube.com/watch?v=pnYccz1Ha34](https://www.youtube.com/watch?v=pnYccz1Ha34)\r\n"},{"excerpt":"2024년을 되돌아보며 한해동안 있었던 일들을 돌아보고자 회고를 작성해보려고 합니다. File(2024).use { 📌 다사다난 했던 1년 2024년은 취업 준비에 많은 시간을 쏟았던 해로 기억됩니다. 하지만 되돌아보면, 여의도 불꽃놀이를 다녀오고, 힘든 시기를 스스로 이겨내며 성장했던 순간들이 함께 떠오릅니다. 상반기에는 졸린 눈을 비비며 면접 준비 스…","fields":{"slug":"/goodbye-2024/"},"frontmatter":{"date":"December 24, 2024","title":"2024년 한해를 돌아보며 ","tags":["Blog","Retrospect"]},"rawMarkdownBody":"<img src = \"./fireworks-festival.png\" class=\"align-center\">\r\n\r\n> 2024년을 되돌아보며 한해동안 있었던 일들을 돌아보고자 회고를 작성해보려고 합니다.\r\n\r\n# File(2024).use {\r\n\r\n## 📌 다사다난 했던 1년\r\n2024년은 취업 준비에 많은 시간을 쏟았던 해로 기억됩니다. 하지만 되돌아보면, 여의도 불꽃놀이를 다녀오고, 힘든 시기를 스스로 이겨내며 성장했던 순간들이 함께 떠오릅니다.\r\n\r\n상반기에는 졸린 눈을 비비며 면접 준비 스크립트를 들고 택시를 타고 이동했던 아침, 그리고 세 시간에 걸친 면접을 봤던 날들이 생각납니다. 하반기에는 네이버 부스트캠프에 참여하며, 뛰어난 개발자들과 소통하고 CS 지식을 실제 프로젝트에 적용해 보며 새로운 것들을 배우고 익히는 소중한 시간을 보냈었습니다.\r\n\r\n상반기가 끝날 무렵, 긴 취업 준비 기간에 지치면서 멘탈이 크게 흔들려 집중하기 어려운 시기가 있었습니다. 이를 극복하기 위해 무작정 헬스장에 다니기 시작했고, 꾸준히 운동하며 건강과 활력을 되찾을 수 있었습니다.\r\n\r\n비록 아직은 익숙한 운동들만 하고 있지만, 내년에는 체력을 더 키우기 위해 새로운 도전을 해보며 더욱 열심히 운동할 계획입니다. 💪🏼\r\n\r\n## 📌 한 해의 마무리\r\n\r\n2024년의 마지막은 스타트업에 합류하며 마무리하게 되었습니다. 스타트업에서 업무를 적응하는 과정에서, 이전 인턴 경험과는 많은 차이점을 느낄 수 있었습니다. \r\n\r\n기존 서비스의 유지보수뿐만 아니라, 스타트업에서는 새로운 프로젝트의 기획부터 개발까지 직접 맡아 진행해야 한다는 점이 가장 큰 차이였습니다. 규모 있는 회사에서는 PM, 기획자, 디자이너 등 다양한 팀과 협업하며 미리 만들어진 기능 및 디자인 요구사항에서 놓칠 수 있는 부분들을 함께 보완하게 되는데, 처음부터 혼자 모두 맡아 진행하는 만큼 최대한 빼먹지 않도록 꼼꼼하게 봐야겠다는 생각이 들었습니다.\r\n\r\n또한, 첫 인턴 경험에서는 수년간 축적된 깊이 있는 코드들을 이해하고 파악하는 데 어려움을 느꼈었습니다. 이러한 경험을 바탕으로 현재는 코드 구조를 명확히 하고 변수명을 직관적으로 작성하여, 더 읽기 쉽고 유지보수가 용이한 코드를 작성하려고 의식적으로 노력하고 있습니다.\r\n\r\n> 코드는 7살 어린아이가 봐도 알수 있게 작성 해보자!\r\n>\r\n> (현재는 나조차도 몇 개월 전의 내 코드를 보면 헷갈릴 때가 있지만요... 😅)\r\n\r\n# } createNewFile(2025)\r\n이번 2025년에는 취업준비를 하면서 하지 못했던 일과 자기개발에 대한 아쉬움들을 종합하여 목표를 정하며, 다음 회고 날까지 이 목표들을 달성하기 위해 꾸준히 노력하려 합니다!\r\n1. 개발 서적 읽기 📖 (언제까지 책장에 꽂혀만 있을래..?)\r\n2. 블로그 포스팅: 월 1개 이상 작성하기 ✏️\r\n3. 개인 또한 팀 프로젝트 진행하기 🖥️\r\n4. 여행가기 ✈️ \r\n5. 운동 꾸준히 가기 💪🏼\r\n"},{"excerpt":"개요 최근에 Kotlin Multiplatform을 활용하여 안드로이드 태블릿과 Desktop에서 사용할 서비스들을 개발하고 있습니다. 안드로이드에서는 화면간에 Jetpack Compose Navigation을 사용하고 있지만 현재 Android에서만 사용이 가능하여 대체할 여러 라이브러리를 찾아보던 도중 Decompose를 알게되어 한번 공유해보고자 합…","fields":{"slug":"/decompose/"},"frontmatter":{"date":"December 18, 2024","title":"Kotlin Multiplatform - Decompose","tags":["Android","Kotlin Multiplatform"]},"rawMarkdownBody":"### 개요\r\n\r\n> 최근에 Kotlin Multiplatform을 활용하여 안드로이드 태블릿과 Desktop에서 사용할 서비스들을 개발하고 있습니다.\r\n> \r\n> \r\n> 안드로이드에서는 화면간에 Jetpack Compose Navigation을 사용하고 있지만 현재 Android에서만 사용이 가능하여 대체할 여러 라이브러리를 찾아보던 도중 Decompose를 알게되어 한번 공유해보고자 합니다.\r\n> \r\n\r\n## Decompose??\r\n\r\nDecompose 는 멀티 플랫폼에서 사용할 수 있는 라이브러리로 공식 문서에서는 Lifecycle-aware한 비즈니스 컴포넌트(Business Logic Component, BLoC)로 코드를 분해해 준다고 설명하고 있다.\r\n\r\n\r\n> 💡 [BLoC](https://github.com/felangel/bloc) 이란 키워드를 처음 접하였는데 이는 Flutter에서 쓰이는 상태관리 패턴중 하나로\r\nUI와 비즈니스 로직의 분리를 강화하는 디자인 패턴이라고 합니다. \r\n\r\n\r\n공식 문서의 Decompose의 주요 장점으로는 Navigation의 역할 (argument 전달, 뒤로가기), 딥링크도 지원을 하며, State Holder로써의 역할을 해줄 수 있다.\r\n\r\n또한 가장 중요한 Lifecycle aware Component로써의 역할을 할 수 있는데, 이는 Android 내에서 Activity와 같이 수명 주기 상태 변경에 따라 작업을 실행 할 수 있다.\r\n\r\n## Decompose의 구성 요소\r\n\r\n코드를 살펴보기 전에 Decompose에 사용된 주요 구성 요소를 살펴보겠습니다.\r\n\r\n- ComponentContext\r\n    - 수명 주기를 관리하여 수명주기 이벤트를 관찰할 수 있도록 한다.\r\n- Value\r\n    - 상태 홀더 역할을 하며 현재 상태를 반환한다. (Android의 stateflow나 LiveData와 비슷한 느낌)\r\n- ChildStack\r\n    - 요소간의 탐색을 관리한다. (push, pop, replace)\r\n- StackNavigation\r\n    - 현재 표시되는 구성을 유지하므로 탐색 관리가 용이해진다.\r\n\r\n---\r\n\r\nDecompose를 보면서 Android에서 Lifecycle, 상태, Navigation의 핵심 기능을 Multiplatform 환경에서 사용할 수 있도록 제공하고 있구나 생각이 들었습니다. \r\n\r\nItem 리스트와 Detail 화면을 이동하는 간단한 화면을 만들어보면서 구성요소들 및 사용법을 한번 살펴보고자 합니다.\r\n\r\n```kotlin\r\n@Serializable\r\ndata class Item(\r\n    val title: String\r\n)\r\n```\r\n\r\n## libs.versions.toml\r\n\r\n```toml\r\n[versions]\r\n...\r\ndecompose = \"<latest_version>\"\r\nkotlin = \"<latest_version>\"\r\n\r\n[libraries]\r\n...\r\ndecompose = { module = \"com.arkivanov.decompose:decompose\", version.ref = \"decompose\" }\r\ndecompose-extensions-compose = { module = \"com.arkivanov.decompose:extensions-compose\", version.ref = \"decompose\" }\r\n\r\n[plugins]\r\nkotlinSerialization = { id = \"org.jetbrains.kotlin.plugin.serialization\", version.ref = \"kotlin\"}\r\n```\r\n\r\nshared 모듈에 있는 에 있는 `build.gradle.kts` 에 의존성을 추가해준다.\r\n\r\n```kotlin\r\nplugins {\r\n    ...\r\n    alias(libs.plugins.kotlinSerialization)\r\n}\r\n\r\nkotlin {\r\n    ...\r\n    sourceSets {\r\n        commonMain.dependencies {\r\n        ...\r\n        implementation(libs.decompose)\r\n        implementation(libs.decompose.extensions.compose)\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n> 💡 kotlin-serialization의 경우 Navigation 통해 데이터를 다른 화면으로 전달 시 직렬화 과정이 필요하기 때문에 이를 위해 사용하였다.\r\n\r\n## RootComponent\r\n\r\nDecompose에서 가장 핵심이 퇴는 클래스로 애플리케이션이 실행되는 동안 다른 SubComponent들을 관리하는 Host 역할을 한다. \r\n\r\n해당 클래스에서 Navigation들을 정의하고 화면에 대한 이동, 백스택, Args 들을 관리한다. Decompose에서도 안드로이드와 마찬가지로 Stack을 사용하여 화면을 쌓아가며 관리한다.\r\n\r\n```kotlin\r\nclass RootComponent(\r\n    componentContext: ComponentContext\r\n): ComponentContext by componentContext {\r\n\r\n    private val navigation = StackNavigation<Configuration>()\r\n    val childStack = childStack(\r\n        source = navigation,\r\n        serializer = Configuration.serializer(),\r\n        initialConfiguration = Configuration.ItemList,\r\n        handleBackButton = true,\r\n        childFactory = ::createChild\r\n    )\r\n    \r\n    private fun createChild(\r\n        config: Configuration,\r\n        context: ComponentContext\r\n    ): Child {\r\n        return when (config) {\r\n            is Configuration.ItemList -> Child.ItemList(\r\n                ItemListComponent(\r\n                    componentContext = context,\r\n                    onNavigateToDetail = { item ->\r\n                        navigation.pushNew(Configuration.ItemDetail(item))\r\n                    }\r\n                )\r\n            )\r\n            is Configuration.ItemDetail -> Child.ItemDetail(\r\n                ItemDetailComponent(\r\n                    item = config.item,\r\n                    componentContext = context,\r\n                    onBackPressed = {\r\n                        navigation.pop()\r\n                    }\r\n                )\r\n            )\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n안드로이드 Navigation에서 NavHost와 같은 중심이 되는 RootComponent를 생성해 주기위해서는 `ComponentContext` 를 만들어 주어야 한다. 이때 기본 값이 되는 DefaultComponentContext 를 사용하여 Lifecycle만을 가지고 있는 구현체를 생성해 줄 수 있다.\r\n\r\n### ComponentContext?\r\n\r\nDecompose에서 Component는 로직을 캡슐화하는 클래스로 각자 관리되는 요소들이 있다. 기본적으로 Component 클래스를 만들때 `ComponentContext` 인터페이스에 의해 구현된 각 요소들을 가지게 된다.\r\n\r\n1. LifecycleOwner\r\n2. StateKeeperOwner\r\n3. InstanceKeeperOwner\r\n4. BackHandlerOwner\r\n\r\n> 각 요소들의 역할은 [문서](https://arkivanov.github.io/Decompose/component/overview/#componentcontext)에서 자세하게 확인해 볼 수 있다.\r\n\r\n```kotlin\r\nclass DefaultComponentContext(\r\n    override val lifecycle: Lifecycle,\r\n    stateKeeper: StateKeeper? = null,\r\n    instanceKeeper: InstanceKeeper? = null,\r\n    backHandler: BackHandler? = null,\r\n) : ComponentContext {\r\n\r\n    override val stateKeeper: StateKeeper = stateKeeper ?: StateKeeperDispatcher()\r\n    override val instanceKeeper: InstanceKeeper = instanceKeeper ?: InstanceKeeperDispatcher().attachTo(lifecycle)\r\n    override val backHandler: BackHandler = backHandler ?: BackDispatcher()\r\n    override val componentContextFactory: ComponentContextFactory<ComponentContext> = ComponentContextFactory(::DefaultComponentContext)\r\n\r\n    constructor(lifecycle: Lifecycle) : this(\r\n        lifecycle = lifecycle,\r\n        stateKeeper = null,\r\n        instanceKeeper = null,\r\n        backHandler = null,\r\n    )\r\n}\r\n```\r\n\r\n### Configuration\r\n\r\nDecompose navigation에서 사용하는 용어로 child component를 표현하고 argument들을 담고 있는 클래스들이다.\r\n\r\n```kotlin\r\n@Serializable\r\nsealed class Configuration {\r\n    @Serializable\r\n    data object ItemList: Configuration()\r\n    @Serializable\r\n    data class ItemDetail(val item: Item): Configuration()\r\n}\r\n```\r\n\r\n### Child Stack\r\n\r\n컴포넌트들은 각자 생명주기를 가진다. 새 컴포넌트가 push되면 원래 활성화 되어있던 컴포넌트는 stopped 상태가 되고, 컴포넌트가 pop되면 그 앞의 컴포넌트가 resumed 상태가 된다. \r\n\r\n즉, 백스택에 있는 동안 컴포넌트의 비즈니스 로직을 중단하지 않고 실행한 채로 둘 수 있다.\r\n\r\nChild Stack은 2가지 main entity로 이루어져있다.\r\n\r\n- ChildStack: Component와 Configuration을 담고 있는 data class이다.\r\n- StackNavigation: navigation 명령을 수행하고 구독한 옵저버들에게 메세지를 전달한다.\r\n\r\n```kotlin\r\nprivate val navigation = StackNavigation<Configuration>()\r\nval childStack = childStack(\r\n    source = navigation,\r\n    serializer = Configuration.serializer(),\r\n    initialConfiguration = Configuration.ItemList,\r\n    handleBackButton = true,\r\n    childFactory = ::createChild\r\n)\r\n```\r\n\r\n> 📌 [Decompose Navigation](https://arkivanov.github.io/Decompose/navigation/stack/navigation/) 를 확인하면 console 예시와 함께 다양한 명령들을 확인 할 수 있다.\r\n\r\n위에서 말하는 Child는 각 Screen 하나하나를 말한다고 볼 수 있다. 해당 컴포넌트는 부모 컴포넌트의 생명주기가 끝나면 자동으로 같이 파괴된다.\r\n\r\n## Child Component\r\n\r\n```kotlin\r\nclass ItemDetailComponent(\r\n    componentContext: ComponentContext,\r\n    item: Item,\r\n    private val onBackPressed: () -> Unit\r\n): ComponentContext by componentContext {\r\n\r\n    val state: Value<Item> = MutableValue(item)\r\n\r\n    fun onBack() {\r\n        onBackPressed()\r\n    }\r\n}\r\n\r\nclass ItemListComponent(\r\n    componentContext: ComponentContext,\r\n    private val onNavigateToDetail: (Item) -> Unit\r\n): ComponentContext by componentContext {\r\n\r\n    private var _list = MutableValue(\r\n        (1..10).map { Item(\"Decompose Item $it\") }\r\n    )\r\n    val list: Value<List<Item>> = _list\r\n\r\n    fun onItemClick(item: Item) {\r\n        onNavigateToDetail(item)\r\n    }\r\n}\r\n```\r\n\r\n각 Screen의 Component에서는 Decompose에서 `Value` 를 통해 안드로이드에서의 StateFlow, LiveData와 같이 State들을 Holder할 수 있는 기능을 제공하며 Decompose-extension에서 제공하는 subscribeAsState()로 변화들을 옵저빙 할 수 있다.\r\n\r\n```kotlin\r\nval state by component.list.subscribeAsState()\r\n```\r\n\r\n리스트 화면과 Detail 화면에서 사용 예시를 보면 다음과 같다.\r\n\r\n```kotlin\r\n@Composable\r\nfun ItemListScreen(\r\n    component: ItemListComponent,\r\n) {\r\n    val state by component.list.subscribeAsState()\r\n\r\n    LazyColumn(\r\n        modifier = Modifier.fillMaxSize(),\r\n        state = rememberLazyListState(),\r\n        contentPadding = PaddingValues(16.dp),\r\n        verticalArrangement = Arrangement.spacedBy(8.dp)\r\n    ) {\r\n        items(state) { item ->\r\n            Row(\r\n                modifier = Modifier\r\n                    .fillMaxWidth()\r\n                    .clip(RoundedCornerShape(12.dp))\r\n                    .border(\r\n                        border = BorderStroke(\r\n                            width = 1.dp,\r\n                            color = Color.LightGray\r\n                        ),\r\n                        shape = RoundedCornerShape(12.dp)\r\n                    )\r\n                    .clickable { component.onItemClick(item) }\r\n                    .padding(16.dp),\r\n                horizontalArrangement = Arrangement.SpaceBetween,\r\n                verticalAlignment = Alignment.CenterVertically\r\n            ) {\r\n                Text(item.title)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n@Composable\r\nfun ItemDetailScreen(\r\n    component: ItemDetailComponent\r\n) {\r\n    val item by component.state.subscribeAsState()\r\n\r\n    Scaffold(\r\n        modifier = Modifier\r\n            .fillMaxSize(),\r\n        topBar = {\r\n            TopAppBar(\r\n                title = { Text(\"Decompose Example\") },\r\n                navigationIcon = {\r\n                    IconButton(\r\n                        onClick = {\r\n                            component.onBack()\r\n                        }\r\n                    ) {\r\n                        Icon(\r\n                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,\r\n                            contentDescription = \"Back\"\r\n                        )\r\n                    }\r\n                }\r\n            )\r\n        }\r\n    ) {\r\n        Box(\r\n            modifier = Modifier.fillMaxSize(),\r\n            contentAlignment = Alignment.Center\r\n        ) {\r\n            Text(text = item.title)\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## Application 실행\r\n\r\n각 플랫폼에서 사용할 App Composable 함수에서는 앞서 만든 `RootComponent` 를 사용하여 childStack을 제공하여 어떠한 화면을 보여줄 지 결정하게 된다.\r\n\r\n> 추가로 Navigation의 전환 애니메이션 또한 지정해 줄 수 있다.\r\n\r\n```kotlin\r\n@Composable\r\n@Preview\r\nfun App(\r\n    root: RootComponent\r\n) {\r\n    MaterialTheme {\r\n        val childStack by root.childStack.subscribeAsState()\r\n        Children(\r\n            stack = childStack,\r\n            animation = stackAnimation(slide())\r\n        ) { child ->\r\n            when (val instance = child.instance) {\r\n                is RootComponent.Child.ItemList -> ItemListScreen(instance.component)\r\n                is RootComponent.Child.ItemDetail-> ItemDetailScreen(instance.component)\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n이제 만들어진 RootComponent를 App의 파라미터로 전달하여 안드로이드, Desktop에서 실행해 보자.\r\n\r\n### MainActivity\r\n\r\n```kotlin\r\nclass MainActivity : ComponentActivity() {\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n\r\n        val root = retainedComponent {\r\n            RootComponent(it)\r\n        }\r\n\r\n        setContent {\r\n            App(root = root)\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### Desktop\r\n\r\n```kotlin\r\nfun main() {\r\n    val lifecycle = LifecycleRegistry()\r\n    val root = runOnUiThread {\r\n        RootComponent(\r\n            componentContext = DefaultComponentContext(lifecycle = lifecycle)\r\n        )\r\n    }\r\n    application {\r\n        val windowState = rememberWindowState()\r\n        Window(\r\n            onCloseRequest = ::exitApplication,\r\n            state = windowState,\r\n            title = \"DecomposeExample\",\r\n        ) {\r\n            LifecycleController(\r\n                lifecycleRegistry = lifecycle,\r\n                windowState = windowState,\r\n                windowInfo = LocalWindowInfo.current\r\n            )\r\n            App(root)\r\n        }   \r\n    }\r\n}\r\n\r\ninternal fun <T> runOnUiThread(block: () -> T): T {\r\n    if (SwingUtilities.isEventDispatchThread()) {\r\n        return block()\r\n    }\r\n\r\n    var error: Throwable? = null\r\n    var result: T? = null\r\n\r\n    SwingUtilities.invokeAndWait {\r\n        try {\r\n            result = block()\r\n        } catch (e: Throwable) {\r\n            error = e\r\n        }\r\n    }\r\n\r\n    error?.also { throw it }\r\n\r\n    @Suppress(\"UNCHECKED_CAST\")\r\n    return result as T\r\n}\r\n```\r\n\r\n<img src = \"https://github.com/user-attachments/assets/bee9a8d9-db82-4f36-9c36-bb55ad65392f\"/>\r\n\r\n\r\n## References\r\n\r\n- [https://github.com/arkivanov/Decompose](https://github.com/arkivanov/Decompose)\r\n- [https://arkivanov.github.io/Decompose/](https://arkivanov.github.io/Decompose/)"},{"excerpt":"안드로이드에서는 Rest Api 통신을 편리하게 해주는  ,  라이브러리를 사용을 현재까지도 많이 사용하고 있다. 최근 Kotlin Multiplatform을 사용하게 되면서 Retrofit을 사용하지 못하게 되어 말로만 듣던 Ktor를 살펴보고자 한다. Ktor? Ktor는 Kotlin으로만 작성된 경량 웹 프레임워크이다.  따라서 플랫폼에 종속적이지 …","fields":{"slug":"/ktor/"},"frontmatter":{"date":"December 04, 2024","title":"KMP를 지원하는 Ktor Client를 사용해보자","tags":["Android","Kotlin Multiplatform"]},"rawMarkdownBody":"안드로이드에서는 Rest Api 통신을 편리하게 해주는 `Retrofit2` , `Okhttp` 라이브러리를 사용을 현재까지도 많이 사용하고 있다. 최근 Kotlin Multiplatform을 사용하게 되면서 Retrofit을 사용하지 못하게 되어 말로만 듣던 Ktor를 살펴보고자 한다.\r\n\r\n# Ktor?\r\n\r\nKtor는 Kotlin으로만 작성된 경량 웹 프레임워크이다.  따라서 플랫폼에 종속적이지 않고 Multiplatform 환경에서 사용이 가능하다.\r\n\r\nKtor는 Server와 Client 두 모듈을 모두 제공을 하고 있으며 Android 및 Multiplatform에서 사용하기 위해 Client 부분을 알아보려고 한다.\r\n\r\n1. 먼저 ktor를 사용하기 위해 gradle에 등록해준다.\r\n\r\n```groovy\r\nktor = <latest_version>\r\n\r\nimplementation(\"io.ktor:ktor-client-core:$ktor\")\r\nimplementation(\"io.ktor:ktor-client-cio:$ktor\")\r\n```\r\n\r\nKtor에서 지원하는 여러 옵션들이 있지만 공식문서에서 말하는  라이브러리를 살펴보면 다음과 같다.\r\n\r\n- `core` :  클라이언트 함수들을 제공하는 모듈\r\n- `CIO` : 플랫폼 별로 요청을 처리하는 엔진에 관한 모듈\r\n\r\n| Engine | Platforms |\r\n| --- | --- |\r\n| Apache | JVM |\r\n| Java | JVM |\r\n| Jetty | JVM |\r\n| Android | JVM, Android |\r\n| OkHttp | JVM, Android |\r\n| Darwin | Native |\r\n| WinHttp | Native |\r\n| Curl | Native |\r\n| CIO | JVM, Android, Native |\r\n| Js | JavaScript |\r\n\r\n간단한 예시로 네트워크 통신에서 필요한 직렬화는 Ktor에서 직렬화/역직렬화를 위해서 사용되는 `negotiation` 라이브러리와 `Kotlin-serialization` 을 사용하여 요청/응답 값을 파싱할 수 있고 이는 Ktor는 HttpClient 생성할때 `install` 함수를 사용하면 된다.\r\n\r\n[(Ktor 공식 문서](https://ktor.io/docs/client-create-new-application.html)에는 다양한 옵션, 함수들을 제공하고 있어 필요한 내용을 학습하고 적용하면 될것 같다!)\r\n\r\n> 💡 많이 사용하는 Retrofit2 라이브러리와 같이 어노테이션 기반으로 사용할 수 있는 [Ktorfit 라이브러리](https://foso.github.io/Ktorfit/) 도 지원하고 있다!\r\n> \r\n\r\n```groovy\r\nimplementation(\"io.ktor:ktor-client-content-negotiation:$ktor\")\r\nimplementation(\"io.ktor:ktor-serialization-kotlinx-json:$ktor\")\r\n```\r\n\r\n```kotlin\r\nval client = HttpClient {\r\n\tinstall(ContentNegotiation) {\r\n    json(Json {\r\n        isLenient = true\r\n        ignoreUnknownKeys = true\r\n    })\r\n\t}\r\n\tinstall(HttpTimeout) {\r\n    connectTimeoutMillis = 5_000L\r\n    socketTimeoutMillis = 5_000L\r\n    requestTimeoutMillis = 5_000L\r\n\t}\r\n}\r\n```\r\n\r\n이렇게 생성된 client를 통해 HttpRequest들을 보낼 수 있다. 공식문서의 get 요청을 하나 만들어 보면 다음과 같다.\r\n\r\n```kotlin\r\n// 많은 함수들이 존재 (ex. request, post, delete...)\r\npublic suspend inline fun HttpClient.get(\r\n    urlString: String,\r\n    block: HttpRequestBuilder.() -> Unit = {}\r\n): HttpResponse = get { url(urlString); block() }\r\n\r\n// ktor docs를 가져오도록 하자\r\nsuspend fun greet(): String {\r\n    val response = client.get(\"https://ktor.io/docs\")\r\n    return \"[Response]\\n${response.bodyAsText()}\"\r\n}\r\n```\r\n\r\n이제 Kotlin Multiplatform Wizard로 생성한 프로젝트에 Desktop에서 해당 요청을 사용해 보자!\r\n\r\n```kotlin\r\n@Composable\r\n@Preview\r\nfun App() {\r\n    MaterialTheme {\r\n        var showContent by remember { mutableStateOf(false) }\r\n        Column(Modifier.fillMaxWidth(), horizontalAlignment = Alignment.CenterHorizontally) {\r\n            Button(onClick = { showContent = !showContent }) {\r\n                Text(\"Ktor Click me!\")\r\n            }\r\n            AnimatedVisibility(showContent) {\r\n                val scope = rememberCoroutineScope()\r\n                var text by remember { mutableStateOf(\"Loading\") }\r\n                Column(\r\n                    Modifier.fillMaxWidth(),\r\n                    horizontalAlignment = Alignment.CenterHorizontally\r\n                ) {\r\n                    LaunchedEffect(true) {\r\n                        scope.launch {\r\n                            text = try {\r\n\t\t                            // Get 요청 \r\n                                KtorExample().greet()\r\n                            } catch (e: Exception) {\r\n                                e.message ?: \"UnKnown Error\"\r\n                            }\r\n                        }\r\n                    }\r\n                    Text(text)\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n<img src=\"https://github.com/user-attachments/assets/48b1d777-3e20-4560-8537-5d251023b820\">\r\n\r\n- - -\r\n# References\r\n\r\n- [https://ktor.io/docs/welcome.html](https://ktor.io/docs/welcome.html)\r\n- [https://foso.github.io/Ktorfit/](https://foso.github.io/Ktorfit/)"},{"excerpt":"안드로이드에서는 Material Design을 사용하여 컬러를 적용하여 라이트, 다크모드를 지원하는 앱을 만들 수 있게 해주고 있습니다. 하지만 Material의 지정된 테마가 한정적이고, 디자이너가 만든 색상의 네임을 사용해야 하는 경우에는 사용자 지정 테마를 만들어야 합니다. 이번에 Compose에서 사용자 지정 테마를 적용하는 방법을 하나씩 살펴보도…","fields":{"slug":"/compose-theme/"},"frontmatter":{"date":"April 26, 2024","title":"Compose 나만의 Custom Theme 설정하기","tags":["Android","Compose"]},"rawMarkdownBody":"<img src=\"https://github.com/ppeper/Kotlin_Algorithm/assets/63226023/3ee7a814-cc90-42ba-9411-6a20ff29c970\">\r\n\r\n안드로이드에서는 Material Design을 사용하여 컬러를 적용하여 라이트, 다크모드를 지원하는 앱을 만들 수 있게 해주고 있습니다.\r\n\r\n하지만 Material의 지정된 테마가 한정적이고, 디자이너가 만든 색상의 네임을 사용해야 하는 경우에는 사용자 지정 테마를 만들어야 합니다. 이번에 Compose에서 사용자 지정 테마를 적용하는 방법을 하나씩 살펴보도록 하겠습니다!\r\n\r\n# 📍 Compose Theme\r\n안드로이드 스튜디오에서 기본적으로 Compose 프로젝트를 만들게 되면 `Color`, `Theme`, `Type`의 기본 값들이 생성되어 있습니다.\r\n\r\n## 1. Color\r\n앱에서 사용할 라이트,다크모드에 사용할 색상들을 지정하고 있습니다.\r\n\r\n```kotlin\r\nval Purple80 = Color(0xFFD0BCFF)\r\nval PurpleGrey80 = Color(0xFFCCC2DC)\r\nval Pink80 = Color(0xFFEFB8C8)\r\n\r\nval Purple40 = Color(0xFF6650a4)\r\nval PurpleGrey40 = Color(0xFF625b71)\r\nval Pink40 = Color(0xFF7D5260)\r\n```\r\n\r\n## 2. Typography\r\n\r\n```kotlin\r\n// Set of Material typography styles to start with\r\nval Typography = Typography(\r\n    bodyLarge = TextStyle(\r\n        fontFamily = FontFamily.Default,\r\n        fontWeight = FontWeight.Normal,\r\n        fontSize = 16.sp,\r\n        lineHeight = 24.sp,\r\n        letterSpacing = 0.5.sp\r\n    )\r\n    ...\r\n)\r\n```\r\n\r\n## 3. Theme\r\n```kotlin\r\nprivate val DarkColorScheme = darkColorScheme(\r\n    primary = Purple80,\r\n    secondary = PurpleGrey80,\r\n    tertiary = Pink80\r\n    ...\r\n)\r\n\r\nprivate val LightColorScheme = lightColorScheme(\r\n    primary = Purple40,\r\n    secondary = PurpleGrey40,\r\n    tertiary = Pink40\r\n    ...\r\n)\r\n```\r\n\r\n`Theme.kt` 에서는 라이트, 다크모드에서 사용할 ColorScheme가 지정되어 있습니다. 이 메소드에서는 parameter를 따로 채워주지 않으면 기본 값이 설정되게 됩니다.\r\n\r\n시스템의 모드에 따라 colors를 정의하고 `MaterialTheme`에 해당 인자들을 넘겨줘 사용하고 있다는 것을 볼 수 있습니다.\r\n\r\n```kotlin\r\n@Composable\r\nfun CustomTheme(\r\n    darkTheme: Boolean = isSystemInDarkTheme(),\r\n    dynamicColor: Boolean = true,\r\n    content: @Composable () -> Unit\r\n) {\r\n    val colorScheme = when {\r\n        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {\r\n            val context = LocalContext.current\r\n            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)\r\n        }\r\n\r\n        darkTheme -> DarkColorScheme\r\n        else -> LightColorScheme\r\n    }\r\n    .\r\n    .\r\n    MaterialTheme(\r\n        colorScheme = colorScheme,\r\n        typography = Typography,\r\n        content = content\r\n    )\r\n}\r\n```\r\n\r\n# Theme 만들어보기\r\n위에서 봤던 컬러, 폰트등을 사용자 지정 테마로 만들어서 사용해 보도록 하겠습니다.\r\n\r\n먼저 Material에서 `lightColorScheme`, `darkColorScheme`을 사용했던 것과 같이 커스텀 ColorScheme를 만들어야 합니다.\r\n\r\nColor들이 시스템 모드에 맞게 변경된다면 Recomposition이 일어나야하므로 지정한 color들을 State로 감싸주는 작업이 필요합니다.\r\n\r\n## 사용자 Color\r\n```kotlin\r\nval primary = Color(0xFFB4BDE9)\r\nval primaryDark = Color(0xFF6E81E4)\r\n\r\nval background = Color(0xFFE2E2E2)\r\nval backgroundDark = Color(0xFF3D3D3D)\r\n\r\n\r\nclass CustomColorScheme(\r\n    primary: Color,\r\n    background: Color,\r\n    .\r\n    .\r\n) {\r\n    var primary by mutableStateOf(primary)\r\n        private set\r\n    var background by mutableStateOf(background)\r\n        private set\r\n    .\r\n    .\r\n}\r\n\r\nval customLightColorScheme: RickColorScheme by lazy {\r\n    RickColorScheme(\r\n        primary = primary,\r\n        background = background,\r\n        .\r\n        .\r\n    )\r\n}\r\n\r\nval customDarkColorScheme: RickColorScheme by lazy {\r\n    RickColorScheme(\r\n        primary = primaryDark,\r\n        background = backgroundDark,\r\n        .\r\n        .\r\n    )\r\n}\r\n```\r\n## 사용자 Typography\r\n\r\n```kotlin\r\nprivate val pretendard = FontFamily(\r\n    Font(R.font.pretendard_regular, FontWeight.Normal),\r\n    Font(R.font.pretendard_medium, FontWeight.Medium),\r\n    Font(R.font.pretendard_semi_bold, FontWeight.SemiBold)\r\n    .\r\n    .\r\n)\r\n\r\n// FontFamily가 FontWeight에 따라 선택된다.\r\nval title01 = TextStyle(\r\n    fontSize = 18.sp,\r\n    fontWeight = FontWeight.Bold,\r\n    fontFamily = pretendard\r\n)\r\n\r\nval title02 = TextStyle(\r\n    fontSize = 14.sp,\r\n    fontWeight = FontWeight.SemiBold,\r\n    fontFamily = pretendard\r\n)\r\n.\r\n.\r\ndata class CustomTypography(\r\n    val title01: TextStyle = title01,\r\n    val title02: TextStyle = title02,\r\n)\r\n```\r\n만들어준 ColorScheme 및 Typography들은 `CompositionLocalProvider` 를 통해 제공할 수 있습니다.\r\n\r\n```kotlin\r\n@Composable\r\nfun CustomTheme(\r\n    darkTheme: Boolean = isSystemInDarkTheme(),\r\n    content: @Composable () -> Unit\r\n) {\r\n\r\n    val typography = CustomTypography()\r\n    val currentColor = remember {\r\n        if (darkTheme) {\r\n            customDarkColorScheme\r\n        } else {\r\n            customLightColorScheme\r\n        }\r\n    }\r\n\r\n    CompositionLocalProvider(\r\n        LocalColorScheme provides currentColor\r\n        LocalTypography provides typography\r\n    ) {\r\n        ProvideTextStyle(typography.title01, content = content)\r\n    }\r\n}\r\n\r\nval LocalColorScheme = staticCompositionLocalOf { customLightColorScheme }\r\nval LocalTypography = staticCompositionLocalOf { CustomTypography() }\r\n\r\n```\r\n\r\n## 테마 값 사용하기\r\n__CompositionLocalProvider__ 로 주입된 color나 typography는 `LocalColorScheme.current` 를 통해 최신 값을 가져올 수 있습니다.\r\n\r\n이를 `object` 로 감싸 더 쉽게 사용할 수 있도록 만들어 줍니다.\r\n\r\n```kotlin\r\nobject CustomTheme {\r\n    val colors: CustomColorScheme\r\n        @Composable\r\n        @ReadOnlyComposable\r\n        get() = LocalColorScheme.current\r\n\r\n    val typography: CustomTypography\r\n        @Composable\r\n        @ReadOnlyComposable\r\n        get() = LocalTypography.current\r\n}\r\n```\r\n> @ReadOnlyComposable : 읽기에 최적화되게 만들어주는 어노테이션\r\n\r\n간단에게 테스트를 위해 color값을 설정해 보면 시스템 모드에 따라 색상이 설정되는 것을 볼 수 있습니다 👋🏼\r\n\r\n```kotlin\r\nColumn(\r\n    modifier = modifier\r\n        .fillMaxSize()\r\n        .background(color = CustomTheme.colors.background)\r\n) {\r\n    ...\r\n}\r\n```\r\n\r\n<img src=\"https://github.com/ppeper/Kotlin_Algorithm/assets/63226023/09855cf3-7793-42a8-ab19-441ce43df544\">\r\n\r\n- - -\r\n# References\r\n- [https://betterprogramming.pub/jetpack-compose-custom-themes-b1836877981d](https://betterprogramming.pub/jetpack-compose-custom-themes-b1836877981d)"},{"excerpt":"서버에서 REST API를 구현하여 데이터를 다룰때는 Json 데이터 형태로 많이 다루게 된다. 안드로이드에서 서버의 데이터를 받아올때 편리하게  라이브러리를 활용하여 객체-Json 간의 Converter 작업을 하였었다. 이번에 구글 프로젝트를 보면서 새로운 직렬화/역직렬화를 다룰 수 있는 라이브러리를 보려고 한다. Kotlin의 Default Valu…","fields":{"slug":"/serialization/"},"frontmatter":{"date":"March 07, 2024","title":"코틑린을 위한 Kotlinx Serizalization","tags":["Kotlin","Serizalization"]},"rawMarkdownBody":"서버에서 REST API를 구현하여 데이터를 다룰때는 Json 데이터 형태로 많이 다루게 된다. 안드로이드에서 서버의 데이터를 받아올때 편리하게 `Gson` 라이브러리를 활용하여 객체-Json 간의 Converter 작업을 하였었다. 이번에 구글 프로젝트를 보면서 새로운 직렬화/역직렬화를 다룰 수 있는 라이브러리를 보려고 한다.\r\n\r\n# Kotlin의 Default Value\r\nGson으로도 데이터의 직렬화(역직렬화)를 할 수 있지만 코틀린의 데이터 클래스에서 Dafault Value를 사용하고 있다면 자바로 되어있는 Gson에서는 해당 기능을 제공하지 않기 때문에 NPE 가능성이 있다.\r\n\r\n```kotlin\r\ndata class User(\r\n    val name: String,\r\n    val gender: String,\r\n    val age: Int = 28,\r\n    val hobby: String = \"Work out\"\r\n)\r\n\r\nval jsonString = \"\"\"\r\n    {\r\n        \"name\" : \"ppeper\",\r\n        \"gender\" : \"Male\"\r\n    } \r\n\"\"\".trimIndent()\r\n\r\nfun main() {\r\n    val user = Gson().fromJson(jsonString, User::class.java)\r\n    println(user)\r\n}\r\n```\r\n\r\n> User(name=ppeper, gender=Male, age=0, hobby=null)\r\n\r\nage의 값과 hoppy의 값에 Default value가 있지만 Primitive type의 경우 0, Reference type의 경우 null로 나오는 것을 볼 수 있다.   코틀린에서는 Null-Safety 를 통해 hobby가 Not-Null type이지만 null이 들어있어 개발시에 잘못한다면 NPE가 발생할 수 있다.\r\n\r\n# Kotlinx Serialization\r\n코틀린에서 공식적으로 제공하고 있는 __Kotlinx Serialization__ 라이브러리를 통해 직렬화/역직렬화를 사용할 수 있다. Kotlin에서 사용하면 위와 같은 Default value의 상황에서도 정상적으로 값을 보여줄 수 있으며 다른 Converter들과 다르게 Reflection을 사용하지 않고 KSerializer을 사용한다.\r\n\r\n사용하는 방법은 변환하고자하는 Class에 `@Serializable` 어노테이션만 추가해 주면 된다.\r\n이 어노테이션을 추가하면 플러그인이 자동으로 해당하는 클래스의 companion object에 `serializer()` 함수를 생성하여 사용할 수 있게 해준다. 이 함수는 __KSerializer__ 타입의 객체를 반환하여 직렬화할때 사용된다.\r\n\r\n```kotlin\r\nplugins {\r\n    kotlin(\"plugin.serialization\") version \"1.9.22\"\r\n}\r\n\r\ndependencies {\r\n    implementation(\"org.jetbrains.kotlinx:kotlinx-serialization-json:$latest_version\")\r\n}\r\n\r\n@Serializable\r\ndata class User(\r\n    val name: String,\r\n    val gender: String,\r\n    val age: Int = 28,\r\n    val hobby: String = \"Work out\"\r\n)\r\n\r\nval jsonString = \"\"\"\r\n    {\r\n        \"name\" : \"ppeper\",\r\n        \"gender\" : \"Male\"\r\n    } \r\n\"\"\".trimIndent()\r\n\r\nfun main() {\r\n    val user = Json.decodeFromString<User>(jsonString)\r\n    println(user)\r\n}\r\n```\r\n\r\n> User(name=ppeper, gender=Male, age=28, hobby=Work out)\r\n\r\nDefault Value를 설정한 프로퍼티 값들이 성공적으로 출력되는 것을 볼 수 있다. kotlinx.serialization에서 Json 관련한 여러 옵션추가하여 입맛에 맞게 사용이 가능하다.\r\n\r\n## ignoreKnownKeys\r\n보통 Model로 다시 파싱을 할때 Json에 있는 Key값과 Model의 멤버 변수와 mapping이 되어햐 한다. 이때 Json에 있는 Key 값이 Model에 없을 때 이를 무시할 수 있는 `ignoreKnwonKeys` 옵션을 설정해 놓으면 Model에서 있는 멤버 변수의 값들만 파싱이 된다.\r\n\r\n해당 옵션을 사용하지 않으면 Exception을 통해 알지 못하는 값을 출력해준다.\r\n> Exception in thread \"main\" kotlinx.serialization.json.internal.JsonDecodingException: Unexpected JSON token at offset 53: Encountered an unknown key 'id' at path: $.gender\r\nUse 'ignoreUnknownKeys = true' in 'Json {}' builder to ignore unknown keys.\r\n\r\n```kotlin\r\nval jsonString = \"\"\"\r\n    {\r\n        \"name\" : \"ppeper\",\r\n        \"gender\" : \"Male\",\r\n        \"id\" : \"1\"\r\n    } \r\n\"\"\".trimIndent()\r\n\r\nprivate val json = Json { ignoreUnknownKeys = true }\r\n\r\nfun main() {\r\n    val decodeToString = json.decodeFromString<User>(jsonString)\r\n    println(decodeToString)\r\n}\r\n```\r\n\r\n> User(name=ppeper, gender=Male, age=28, hobby=Work out)\r\n\r\n 이외에도 공식 [Kotlin Serialization](https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/builtin-classes.md#enum-classes)을 보면 직렬화 대상 Model의 멤버 변수에 다양한 어노테이션을 활용할 수 있다. 또한 안드로이드에서 Retrofit을 사용하고 있다면 이를위한 [Converter](https://github.com/JakeWharton/retrofit2-kotlinx-serialization-converter)도 현재 제공하고 있다.\r\n\r\n- - -\r\n\r\n# References\r\n- [https://kotlinlang.org/docs/serialization.html#what-s-next](https://kotlinlang.org/docs/serialization.html#what-s-next)\r\n- [https://github.com/google/gson](https://github.com/google/gson)"},{"excerpt":"들어가며 👋🏼 2023년은 대부분 타지에서 생활을 했던 한해여서 그런지 유난히 빨리 지나간것 같다. 새로운 지역에서의 생활부터 대학교를 졸업하고 인턴경험까지 지난 2023년을 되돌아보며 회고록을 작성해보려고 한다. lateinit var 2024: 청룡의 해 2023.open() 📌 SSAFY 9th 이번 2023년은 시작부터 1월 초  9기 모바일 트랙 …","fields":{"slug":"/goodbye-2023/"},"frontmatter":{"date":"December 31, 2023","title":"2023년 한해 회고록","tags":["Blog","Retrospect"]},"rawMarkdownBody":"# 들어가며 👋🏼 \r\n\r\n2023년은 대부분 타지에서 생활을 했던 한해여서 그런지 유난히 빨리 지나간것 같다.   \r\n새로운 지역에서의 생활부터 대학교를 졸업하고 인턴경험까지 지난 2023년을 되돌아보며 회고록을 작성해보려고 한다.\r\n\r\n# lateinit var 2024: 청룡의 해\r\n# 2023.open()\r\n## 📌 SSAFY 9th\r\n이번 2023년은 시작부터 1월 초 `삼성 청년 SW 아카데미` 9기 모바일 트랙 교육을 받기 시작하였다.\r\n\r\n교육을 받기전 SSAFY에 지원하게 된 이유는 두 가지가 있었다.\r\n1. Soft한 지식과 기본기를 탄탄히 갖추자\r\n2. 좋은 개발자 동료들을 얻을 수 있다\r\n\r\n교육을 받기 이전부터 안드로이드 개발자의 꿈을 위해 달려왔었지만 개발은 내 분야 이외의 Soft한 지식도 알고 있어야 좋은 개발자가 될 수 있겠다는 생각이 들었고 이는 SSAFY에서   웹부터 서버까지 동작과정과 기술의 사용만 학습하는 것이 아니라 왜 이러한 기술이 나오고 발전해 갔는지 배경까지 세세하게 배울 수 있는 기회가 되었다.\r\n\r\n두 번째로는 홀로 공부를 하다가 문제가 발생하거나 막히는 부분에 대한 의문점을 해결할 떄의 아쉬움이 있었었다.\r\n\r\n대학교에서 안드로이드를 희망하고 있는 동료들이 부족하여 항상 구글이 정보를 얻을 수 있는 나의 친구였다. 이러한 점에 있어서 문제해결에 대한 답이 __이것이 맞나?, 더 좋은 방법이 있는지 기술적인 목마름__ 이 많이 있었는데 SSAFY에서 같은 모바일을 위해 달리는 좋은 동료들을 만났고 계속 좋은 인연으로 연락을 하고 있다는 것이 올해는 정말 좋은 시간을 보냈다는 생각이 들었다.🥹\r\n\r\n## 📌 갚진 프로젝트들\r\n안드로이드를 공부하면서 선언형 UI인 Compose를 통한 프로젝트를 개발하면서 xml과 다른 특장점들을 알 수 있었다. SSAFY에서 좋은 동료들과 함께 같이 처음부터 공부하며 소통을 통해 안드로이드에 대한 서로의 생각과 문제해결 방법을 공유할 수 있는 갚진 시간들을 가졌던 것 같다.\r\n\r\n## 📌 서비스 기업에서의 경험\r\n1년과정인 SSAFY 과정중 9월달에 서비스기업에 합격되어 교육과정을 수료하게 되었다.🥳 기존과 다르게 현업에서 실제로 서비스중인 프로젝트에 참여하여 개발할 수 있다는 것에 설레면서 동시에 두려움이 좀 있었다.\r\n\r\n기업에서 3개월동안 경험하면서 `일하는 것`과 `개발 하는 일` 은 다르다는 것을 단숨에 느낄 수 있었다. 프로젝트에 투입되어 코드를 분석하고 새로운 기능 개발 및 유지보수를 하는 __개발적인 일__ 에서는 두려움과 달리 실제로는 굉장히 설레고 책임감 있게 잘 진행 했다는 생각이 들었지만 __일하는 것__ 에 대해 좀 더 의견을 자유롭게 내고, 활발하게 소통하는데는 조금 늦게 적응하였다.\r\n\r\n이번 인턴경험을 통해 이전과 달리 실제 회사에서의 경험들을 통해 스스로 개발과 일 두부분 모두 많이 발전되었다는 것을 느끼고, 이후에도 일을하게 되었을 때 어떠한 방식으로 소통해야 좋을지  깊게 생각 하게되어 너무 갚진 경험을 올해 마지막에 했던 것 같다. 🙏🏼\r\n\r\n<h4>Good Bye</h4>\r\n2023년은 구미에서 생활하며 대부분의 시간이 SSAFY에서 보냈지만 안드로이드 개발자로써 실제 서비스 중인 회사에서 갚진 경험으로 마무리했던 좋은 시간이였다!\r\n\r\n- - -\r\n# 2023.close()\r\n# 2024 = 청룡의 해()\r\n2024년에는 안드로이드 개발에 대한 부족한 점을 채워나가며 좀 더 건강에 신경을 쓸 수 있는 한해를 보내도록 다짐하며 다음 회고를 작성하기까지 열심히 살아야겠다!"},{"excerpt":"Gradle에서 최근에 많이 사용하는 버전관리는  를 통하여 하고 있다. 결국 version-catalog, BuildSrc 등은 의존성 버전, 관리에 대한 재사용성을 높여주고 멀티 모듈을 구성하게 되면 공통적으로 사용되는 코드 작성을 줄여주게 된다. 이번에 Now in Android 예시 프로젝트를 보면서 build-logic이 적용되어 있는 모듈을 한…","fields":{"slug":"/gradle-plugins/"},"frontmatter":{"date":"December 26, 2023","title":"Gradle Convention Plugin 생성 및 적용하기","tags":["Version Catalog"]},"rawMarkdownBody":"<img src=\"https://github.com/ppeper/Kotlin_Algorithm/assets/63226023/ecbbb8e9-4775-4847-8485-76ef893b3453\">\r\n\r\nGradle에서 최근에 많이 사용하는 버전관리는 `version-catalog` 를 통하여 하고 있다. 결국 version-catalog, BuildSrc 등은 의존성 버전, 관리에 대한 재사용성을 높여주고 멀티 모듈을 구성하게 되면 공통적으로 사용되는 코드 작성을 줄여주게 된다.\r\n\r\n이번에 Now in Android 예시 프로젝트를 보면서 build-logic이 적용되어 있는 모듈을 한번 구성해 보면서 기본 프로젝트 생성시에 Android, Compose에 대한 Convention Plugin을 생성해보려고 한다.\r\n- - -\r\n\r\n# Convention Plugin 생성하기\r\n최근 안드로이드 스튜디오에서는 version-catalog가 적용된 프로젝트로 생성이 가능하다. 해당 프로젝트를 생성 후 `build-logic` 으로 plugin 들을 관리할 모듈을 추가한다.\r\n\r\n`settings.gradle.kts(Project Settings)` 에서 기본적으로 모듈이 추가되었을 때 자동 include되는 `include(\":build-logic\")` 의 경우는 삭제해 주고 __build-logic__ 에 convention 모듈을 하나 더 생성하여 사용하기 때문에 `includeBuild(\"build-logic\")` 을 추가해 준다.\r\n\r\n```kotlin\r\npluginManagement {\r\n    // 추가 되는 내용\r\n    includeBuild(\"build-logic\")\r\n    repositories {\r\n        google()\r\n        mavenCentral()\r\n        gradlePluginPortal()\r\n    }\r\n}\r\ndependencyResolutionManagement {\r\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\r\n    repositories {\r\n        google()\r\n        mavenCentral()\r\n    }\r\n}\r\n\r\nrootProject.name = \"ConventionPlugin\"\r\ninclude(\":app\")\r\n// include(\"build-logic\") 삭제\r\n```\r\n\r\nbuild-logic 모듈에 `convention` 모듈(java or kotlin library)을 추가해주고 root에 `settins.gradle.kts` 파일을 다음과 같이 추가해 준다. (convention 모듈이 추가되었을 때 `include(\":build-logic:convention\")` 는 동일하게 삭제해 준다.)\r\n\r\n```kotlin\r\n// settins.gradle.kts\r\ndependencyResolutionManagement {\r\n    repositories {\r\n        google()\r\n        mavenCentral()\r\n    }\r\n    versionCatalogs {\r\n        create(\"libs\") {\r\n            from(files(\"../gradle/libs.versions.toml\"))\r\n        }\r\n    }\r\n}\r\n\r\nrootProject.name = \"build-logic\"\r\ninclude(\":convention\")\r\n```\r\n\r\n<img src=\"https://github.com/ppeper/Kotlin_Algorithm/assets/63226023/7bc87c15-08ef-4e9b-8a30-fea9581138e5\">\r\n\r\nlib.versions.toml 파일에 아래의 버전을 추가하고 이를 build-logic:convention의 build.gradle.kts에 아래와 같이 수정한다.\r\n\r\n```toml\r\n// libs.versions.toml\r\nandroidGradlePlugin = \"8.1.4\"\r\nandroidTools = \"31.2.0\"\r\nkotlin = \"1.9.10\"\r\n.\r\n.\r\n# Dependencies of the included build-logic\r\nandroid-gradlePlugin = { group = \"com.android.tools.build\", name = \"gradle\", version.ref = \"androidGradlePlugin\" }\r\nandroid-tools-common = { group = \"com.android.tools\", name = \"common\", version.ref = \"androidTools\" }\r\nkotlin-gradlePlugin = { group = \"org.jetbrains.kotlin\", name = \"kotlin-gradle-plugin\", version.ref = \"kotlin\" }\r\n```\r\n\r\n```kotlin\r\n// build.gradle.kts\r\n@Suppress(\"DSL_SCOPE_VIOLATION\") // TODO: Remove once KTIJ-19369 is fixed\r\nplugins {\r\n    `kotlin-dsl`\r\n}\r\n\r\njava {\r\n    sourceCompatibility = JavaVersion.VERSION_17\r\n    targetCompatibility = JavaVersion.VERSION_17\r\n}\r\n\r\ndependencies {\r\n    compileOnly(libs.android.gradlePlugin)\r\n    compileOnly(libs.android.tools.common)\r\n    compileOnly(libs.kotlin.gradlePlugin)\r\n}\r\n```\r\n\r\n다음으로 Android의 기본 세팅을 도와주는 Extension 파일인 `KotlinAndroid.kt` 파일과 Compose 세팅을 위한 `AndroidCompose.kt` 파일을 생성해 준다.\r\n\r\n<img src=\"https://github.com/ppeper/Kotlin_Algorithm/assets/63226023/3b3e5521-3677-4238-9dab-795971204841\">\r\n\r\n```kotlin\r\n// KotlinAndroid.kt\r\n\r\ninternal fun Project.configureKotlinAndroid(\r\n    commonExtension: CommonExtension<*, *, *, *, *>\r\n) {\r\n    commonExtension.apply {\r\n        compileSdk = 34\r\n\r\n        defaultConfig {\r\n            minSdk = 26\r\n\r\n            testInstrumentationRunner = \"android.support.test.runner.AndroidJUnitRunner\"\r\n            vectorDrawables.useSupportLibrary = true\r\n        }\r\n\r\n        compileOptions {\r\n            sourceCompatibility = JavaVersion.VERSION_17\r\n            targetCompatibility = JavaVersion.VERSION_17\r\n        }\r\n\r\n        kotlinOptions {\r\n            jvmTarget = JavaVersion.VERSION_17.toString()\r\n        }\r\n    }\r\n}\r\n\r\nfun CommonExtension<*, *, *, *, *>.kotlinOptions(block: KotlinJvmOptions.() -> Unit) {\r\n    (this as ExtensionAware).extensions.configure(\"kotlinOptions\", block)\r\n}\r\n\r\n// AndroidCompose.kt\r\n// 기본적으로 프로젝트 생성시 적용되어있는 libs.versions.toml 파일에 있는 compose 관련 라이브러리 추가\r\ninternal fun Project.configureAndroidCompose(\r\n    commonExtension: CommonExtension<*, *, *, *, *>\r\n) {\r\n    commonExtension.apply {\r\n        val libs = extensions.getByType<VersionCatalogsExtension>().named(\"libs\")\r\n\r\n        buildFeatures.compose = true\r\n\r\n        composeOptions {\r\n            kotlinCompilerExtensionVersion =\r\n                libs.findVersion(\"androidxComposeCompiler\").get().toString()\r\n        }\r\n\r\n        dependencies {\r\n            val bom = libs.findLibrary(\"compose-bom\").get()\r\n            add(\"implementation\", platform(bom))\r\n            add(\"androidTestImplementation\", platform(bom))\r\n\r\n            add(\"implementation\", libs.findLibrary(\"activity-compose\").get())\r\n            add(\"implementation\", libs.findLibrary(\"ui\").get())\r\n            add(\"implementation\", libs.findLibrary(\"ui-graphics\").get())\r\n            add(\"implementation\", libs.findLibrary(\"ui-tooling\").get())\r\n            add(\"implementation\", libs.findLibrary(\"ui-tooling-preview\").get())\r\n            add(\"implementation\", libs.findLibrary(\"material3\").get())\r\n            add(\"implementation\", libs.findLibrary(\"ui-test-manifest\").get())\r\n        }\r\n    }\r\n}\r\n\r\n// libs.versions.tomal\r\nandroidxComposeCompiler = \"1.5.3\"\r\n.\r\n.\r\n[libraries]\r\n.\r\n.\r\ncompose-bom = { group = \"androidx.compose\", name = \"compose-bom\", version.ref = \"compose-bom\" }\r\n```\r\n\r\n## Convention Plugin 추가\r\n이제 convention 모듈에서 build.gradle 설정 plugin인 `AndroidApplicationPlugin`, `AndroidApplicationComposePlugin` 파일을 추가해 준다.\r\n\r\n\r\n<img src=\"https://github.com/ppeper/Kotlin_Algorithm/assets/63226023/524a0acb-2727-49b4-a832-842eb3349fc3\">\r\n\r\n```kotlin\r\n// AndroidApplicationPlugin.kt\r\nclass AndroidApplicationPlugin: Plugin<Project> {\r\n    override fun apply(target: Project) {\r\n        with(target) {\r\n            with(pluginManager) {\r\n                apply(\"com.android.application\")\r\n                apply(\"org.jetbrains.kotlin.android\")\r\n            }\r\n\r\n            extensions.configure<ApplicationExtension> {\r\n                // 앞서 생성한 Android setting을 도와주는 extention\r\n                configureKotlinAndroid(this)\r\n                defaultConfig {\r\n                    versionCode = 1\r\n                    versionName = \"1.0\"\r\n                    targetSdk = 34\r\n                }\r\n            }   \r\n        }\r\n    }\r\n}\r\n\r\n// AndroidApplicationComposePlugin.kt\r\nclass AndroidApplicationComposePlugin: Plugin<Project> {\r\n    override fun apply(target: Project) {\r\n        with(target) {\r\n            pluginManager.apply(\"com.android.application\")\r\n\r\n            extensions.configure<ApplicationExtension> {\r\n                // 앞서 생성한 Compose setting을 도와주는 extension\r\n               configureAndroidCompose(this)\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n이번 예제에서는 두 가지의 Plugin들만 추가하였지만 여러가지 Hilt, Room과 같은 라이브러리들을 관리해주도록 필요할 때마다 추가하여 관리하면 된다.\r\n\r\n이제 만들어진 Plugin들을 build.gradle파일에 세팅을 해주면 사용준비가 완료된다!\r\n\r\n```kotlin\r\n.\r\n.\r\ndependencies {\r\n    compileOnly(libs.android.gradlePlugin)\r\n    compileOnly(libs.android.tools.common)\r\n    compileOnly(libs.kotlin.gradlePlugin)\r\n}\r\n\r\ngradlePlugin {\r\n    plugins {\r\n        register(\"AndroidApplicationPlugin\") {\r\n            id = \"ppeper.example.application\"\r\n            implementationClass = \"AndroidApplicationPlugin\"\r\n        }\r\n    }\r\n    plugins {\r\n        register(\"AndroidApplicationComposePlugin\") {\r\n            id = \"ppeper.example.compose\"\r\n            implementationClass = \"AndroidApplicationComposePlugin\"\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n여기서 id의 값은 플러그인 이름으로 사용하고 싶은 이름으로 지정하면 되고, implementationClass는 매칭되는 해당 Class의 이름이다.\r\n\r\n## 사용하기\r\napp 모듈에서 Android, Compose 세팅을 위해 생성한 Plugin을 도입하면 아래와 같이 사용할 수 있다.\r\n```kotlin\r\n// Before\r\n@Suppress(\"DSL_SCOPE_VIOLATION\") // TODO: Remove once KTIJ-19369 is fixed\r\nplugins {\r\n    alias(libs.plugins.com.android.application)\r\n    alias(libs.plugins.org.jetbrains.kotlin.android)\r\n}\r\n\r\nandroid {\r\n    namespace = \"com.ppeper.conventionplugin\"\r\n    compileSdk = 34\r\n\r\n    defaultConfig {\r\n        applicationId = \"com.ppeper.conventionplugin\"\r\n        minSdk = 24\r\n        targetSdk = 34\r\n        versionCode = 1\r\n        versionName = \"1.0\"\r\n\r\n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\r\n        vectorDrawables {\r\n            useSupportLibrary = true\r\n        }\r\n    }\r\n\r\n    buildTypes {\r\n        release {\r\n            isMinifyEnabled = false\r\n            proguardFiles(\r\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\r\n                \"proguard-rules.pro\"\r\n            )\r\n        }\r\n    }\r\n    compileOptions {\r\n        sourceCompatibility = JavaVersion.VERSION_17\r\n        targetCompatibility = JavaVersion.VERSION_17\r\n    }\r\n    kotlinOptions {\r\n        jvmTarget = \"1.8\"\r\n    }\r\n    buildFeatures {\r\n        compose = true\r\n    }\r\n    composeOptions {\r\n        kotlinCompilerExtensionVersion = \"1.4.3\"\r\n    }\r\n    packaging {\r\n        resources {\r\n            excludes += \"/META-INF/{AL2.0,LGPL2.1}\"\r\n        }\r\n    }\r\n}\r\n\r\ndependencies {\r\n\r\n    implementation(libs.core.ktx)\r\n    implementation(libs.lifecycle.runtime.ktx)\r\n    implementation(libs.activity.compose)\r\n    implementation(platform(libs.compose.bom))\r\n    implementation(libs.ui)\r\n    implementation(libs.ui.graphics)\r\n    implementation(libs.ui.tooling.preview)\r\n    implementation(libs.material3)\r\n    testImplementation(libs.junit)\r\n    androidTestImplementation(libs.androidx.test.ext.junit)\r\n    androidTestImplementation(libs.espresso.core)\r\n    androidTestImplementation(platform(libs.compose.bom))\r\n    androidTestImplementation(libs.ui.test.junit4)\r\n    debugImplementation(libs.ui.tooling)\r\n    debugImplementation(libs.ui.test.manifest)\r\n}\r\n\r\n// plugin 적용 후\r\n@Suppress(\"DSL_SCOPE_VIOLATION\") // TODO: Remove once KTIJ-19369 is fixed\r\nplugins {\r\n    id(\"ppeper.example.application\")\r\n    id(\"ppeper.example.compose\")\r\n}\r\n\r\nandroid {\r\n    namespace = \"com.ppeper.conventionplugin\"\r\n\r\n    buildTypes {\r\n        release {\r\n            isMinifyEnabled = false\r\n            proguardFiles(\r\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\r\n                \"proguard-rules.pro\"\r\n            )\r\n        }\r\n    }\r\n    packaging {\r\n        resources {\r\n            excludes += \"/META-INF/{AL2.0,LGPL2.1}\"\r\n        }\r\n    }\r\n}\r\n\r\ndependencies {\r\n    // 기존에 있는 compose 라이브러리들은 삭제 가능\r\n    implementation(libs.core.ktx)\r\n    implementation(libs.lifecycle.runtime.ktx)\r\n    testImplementation(libs.junit)\r\n    androidTestImplementation(libs.androidx.test.ext.junit)\r\n    androidTestImplementation(libs.espresso.core)\r\n    androidTestImplementation(libs.ui.test.junit4)\r\n}\r\n```\r\n\r\nConvention Plugin들을 생성하고 적용해 보면서 멀티모듈을 구성할때 각 필요한 라이브러리를 plugin들로 관리하면 새로운 모듈이 추가될때 재사용성 있고 중복코드 없이 관리 할 수 있어 한번 적용을 해보면 좋겠다 생각이 들었다.\r\n\r\n- - -\r\n# References\r\n- [https://brunch.co.kr/@purpledev/46](https://brunch.co.kr/@purpledev/46)\r\n- [https://github.com/android/nowinandroid](https://github.com/android/nowinandroid)"},{"excerpt":"WebView 모바일 앱을 사용하다 보면 웹으로 리다이렉트 하거나 웹 페이지를 보여주는 화면들을 많이 볼 수 있다. 앱에서 웹페이지를 보여줄 수 있는 웹뷰를 사용하기 위해서는 안드로이드에서 WebView 를 사용하여 여러가지 옵션을 설정하고 웹 페이지와 상호작용 할 수 있다. 기본적으로 WebView를 사용하기 위해서는 안드로이드에서 Internet 퍼미…","fields":{"slug":"/android-webview/"},"frontmatter":{"date":"November 20, 2023","title":"안드로이드 WebView로 웹과 놀기","tags":["Android","Webview"]},"rawMarkdownBody":"# WebView\r\n모바일 앱을 사용하다 보면 웹으로 리다이렉트 하거나 웹 페이지를 보여주는 화면들을 많이 볼 수 있다. 앱에서 웹페이지를 보여줄 수 있는 웹뷰를 사용하기 위해서는 안드로이드에서 __WebView__ 를 사용하여 여러가지 옵션을 설정하고 웹 페이지와 상호작용 할 수 있다.\r\n\r\n기본적으로 WebView를 사용하기 위해서는 안드로이드에서 Internet 퍼미션을 설정해야 한다. WebView는 간단하게 xml에서 WebView tag를 추가해 주면 된다.\r\n\r\n```xml\r\n<uses-permission android:name=\"android.permission.INTERNET\" />\r\n\r\n<WebView\r\n    android:id=\"@+id/wvContent\"\r\n    android:layout_width=\"0dp\"\r\n    android:layout_height=\"0dp\"\r\n    app:layout_constraintBottom_toBottomOf=\"parent\"\r\n    app:layout_constraintEnd_toEndOf=\"parent\"\r\n    app:layout_constraintStart_toStartOf=\"parent\"\r\n    app:layout_constraintTop_toTopOf=\"parent\" />\r\n```\r\n\r\nWebView를 사용하기 위한 준비는 간단하게 끝났다. 하지만 결국 WebView에서 모바일의 특정 화면을 보여주거나 다른 인터렉션들의 기능들이 필요할 것 이다. 안드로이드에서는 `WebViewClient`, `WebChromeClient`, `Settings` 을 통해 다양한 옵션들과 기능을 사용할 수 있다.\r\n\r\n> WebViewClient: 웹페이지를 로딩할 때 생기는 콜백함수로 구성\r\n> - onPageStarted: 페이지가 처음 로딩될 떄 호출된다.\r\n> - onPageFinished: 페이지 로딩이 끝나면 호출된다.\r\n> - shouldOverridingUrlLoading: 웹뷰에서 URL이 로딩이 될 때 호출된다. 해당 함수로 URL을 앱에서 제어 할수 있다.\r\n\r\n> WebChromeClient: 웹페이지에서 일어나는 액션을 관리\r\n> - onCreateWindow: 웹에서 새 창을 열때 호출된다.\r\n> - onCloseWindow: 웹뷰가 창을 닫을 때 호출된다.\r\n> - onProgressChanged: 페이지가 로딩되는 중간에 호출된다.\r\n\r\n> Settings: 다양한 웹뷰에 관한 설정 가능 (ex: javaScriptEnabled)\r\n\r\n지금까지 살펴본 웹뷰를 간단하게 웹에서 버튼을 눌러 안드로이드에서 Toast 메시지를 보여주는 예시를 통해 알아보자.\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    private val binding by lazy {\r\n        ActivityMainBinding.inflate(layoutInflater)\r\n    }\r\n\r\n    @SuppressLint(\"SetJavaScriptEnabled\")\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(binding.root)\r\n        binding.wvContent.apply {\r\n            settings.javaScriptEnabled = true // 자바스크립트를 사용하기 위한 설정 값\r\n        }\r\n    }\r\n    private fun toast() {\r\n        Toast.makeText(this, \"test\", Toast.LENGTH_SHORT).show()\r\n    }\r\n    \r\n}\r\n```\r\n\r\n## 🌉 브릿지\r\n웹에서도 다양한 버튼과 이벤트들을 호출해주는 View가 있을 것이다. 해당하는 웹뷰와 웹 페이지 간에 상호 작용을 도와 주는 메커니즘을 __브릿지__ 라고 한다.\r\n\r\nWebView에서는 네이티브 코드와 웹 페이지의 JavaScript 코드 간의 통신을 지원하기 위해 브릿지를 사용한다. 브릿지는 `@JavascriptInterface` 어노테이션을 함수에 붙여 생성하고 이에 대한 브릿지 함수를 `addJavascriptInterface` 함수를 통해 브릿지를 설정할 수 있다.\r\n\r\n모바일과 웹뷰간에 인터렉션을 처리하기 위해서는  __@JavascriptInterface__ 어노테이션을 통하여 웹 페이지 간에 상호작용을 할 수 있다. 이를 통해 JavaScript 코드에서 안드로이드의 Kotlin 코드를 호출하거나, 반대릐 경우를 호출할 수 있다. 예시로 안드로이드에서 toast 메시지를 띄우기 위해 다음과 같이 코드를 작성해 준다.\r\n\r\n```kotlin\r\nclass WebBridge(\r\n    private val onClickMessage: () -> Unit\r\n) {\r\n\r\n    @JavascriptInterface\r\n    fun showMessage() {\r\n        onClickMessage.invoke()\r\n    }\r\n}\r\n.\r\n.\r\n.\r\n@SuppressLint(\"SetJavaScriptEnabled\")\r\noverride fun onCreate(savedInstanceState: Bundle?) {\r\n    super.onCreate(savedInstanceState)\r\n    setContentView(binding.root)\r\n    binding.wvContent.apply {\r\n        settings.javaScriptEnabled = true // 자바스크립트를 사용하기 위한 설정 값\r\n        addJavascriptInterface(WebBride(::toast), \"Android\")\r\n    }\r\n}\r\n```\r\n\r\n해당 코드는 예시로 사용하기 위해 안드로이드의 `assets` 폴더에 `toast.html` 로 넣어 둔다.\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n    <head>\r\n        <meta name=\"viewport\" content=\"initial-scale=1.0\">\r\n        <meta charset=\"utf-8\">\r\n    </head>\r\n    <body>\r\n        <input type=\"button\" value=\"토스트 버튼\" onClick=\"showAndroidToast()\"/>\r\n        <script type=\"text/javascript\">\r\n            function showAndroidToast() {\r\n                Android.showMessage();\r\n            }\r\n        </script>\r\n    </body>\r\n</html>\r\n```\r\n\r\n위에서 addJavaScriptInterface 함수에서 지정하였던 \"Android\" 와 함수의 이름과 맞게 호출하면 된다.\r\n\r\n<img src=\"https://github.com/ppeper/Kotlin_Algorithm/assets/63226023/a4bc6aaa-3a3c-4f2c-8c61-d6381b86cf03\">\r\n\r\n- - -\r\n# References\r\n- [WebView에서 웹 앱 개발](https://developer.android.com/develop/ui/views/layout/webapps/webview?hl=ko)"},{"excerpt":"안드로이드에서는 gradle 파일을 통하여 버전관리를 하고 있다. 프로젝트를 진행하면서 같은 implement를 해야하는 라이브러리들을 관리를 하지 못하여 유지보수에 좋지 못하다는 점에 있어서 공통된 파일로 관리하면 좋겠다는 생각이 들었다. 이번에 Gradle 7.0에서 추가된 가 있다는 것을 알게되어 이를 통하여 간편하게 버전관리를 하는 방법을 공부하고…","fields":{"slug":"/android-version-catalog/"},"frontmatter":{"date":"October 30, 2023","title":"안드로이드 Version Catalog 도입하기","tags":["Android","Version Catalog"]},"rawMarkdownBody":"<img src=\"https://github.com/ppeper/Cellification/assets/63226023/acb3db44-6459-43b8-918c-3e49e7f6c204\">\r\n\r\n안드로이드에서는 gradle 파일을 통하여 버전관리를 하고 있다. 프로젝트를 진행하면서 같은 implement를 해야하는 라이브러리들을 관리를 하지 못하여 유지보수에 좋지 못하다는 점에 있어서 공통된 파일로 관리하면 좋겠다는 생각이 들었다.\r\n\r\n이번에 Gradle 7.0에서 추가된 `Version Catalog`가 있다는 것을 알게되어 이를 통하여 간편하게 버전관리를 하는 방법을 공부하고 내용을 정리해 보려고 한다.\r\n\r\n# Version Catalog\r\nVersion Catalog는 하나의 파일로 버전을 관리하여 여러 프로젝트나 모듈들의 의존성을 통합하여 관리할 수 있다는 장점이 있다.\r\n\r\n> 최근에 업데이트된 안드로이드 스튜디오 Giraffe 버전에서는 __Kotlin DSL__ 을 기본 빌드 방식으로 Recommend하여 groovy가 아닌 Kotlin 언어로 빌드를 하도록 하고 있다.\r\n\r\nVersion Catalog는 파일형식으로 `TOML`를 사용하여 기본적으로 `키 = 값` 쌍, `[섹션 이름]` 과 `#`을 통한 주석을 관리한다. Version Catalog에서 사용하는 섹션 이름은 아래와 같다.\r\n\r\n- `[versions]` : 라이브러리의 버전들에 대한 명시\r\n- `[plugins]` : 플러그인에 대한 명시\r\n- `[libraries]` : 각각의 라이브러리 의존성에 대한 명시\r\n- `[bundles]` : 라이브러리를 묶어서 한 번에 선언이 가능하도록 하는 명시\r\n\r\n## 생성하기\r\n먼저 `gradle` 폴더에 `libs.versions.toml` 파일을 생성한다.\r\n\r\n<img src=\"https://github.com/ppeper/ppeper/assets/63226023/666efcc3-b1eb-4d34-84a4-4370634c5909\">\r\n\r\nVersion Catalog는 Gradle 7.4 버전부터 정식으로 지원되어, 이전 버전을 사용한다면 수동으로 toml 파일을 찾아서 지정을 해줘야한다.\r\n\r\n```kotlin\r\n// In settins.gradle.kts\r\n\r\nenableFeaturePreview(\"VERSION_CATALOGS\")\r\n\r\ndependencyResolutionManagement {\r\n    versionCatalogs {\r\n        create(\"libs\") {\r\n            files(files(\"libs.versions.toml\"))\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n> 파일을 gradle 폴더의 루트 디렉토리에 생성하면 경로를 명시하지 않아도 된다.\r\n\r\n```toml\r\n[versions]\r\nactivityCompose = \"1.7.2\"\r\nandroidGradlePlugin = \"8.1.1\"\r\nkotlin = \"1.8.10\"\r\nandroidxActivity = \"1.7.2\"\r\nandroidxLifecycle = \"2.6.1\"\r\nandroidxHiltNavigationCompose = \"1.0.0\"\r\nandroidxNavigation = \"2.7.1\"\r\nandroidxAppCompat = \"1.6.1\"\r\nandroidxArchCore = \"2.2.0\"\r\nandroidxCoreSplashscreen = \"1.0.0\"\r\nandroixPagingCompose = \"1.0.0-alpha18\"\r\nandroidxComposeBom = \"2023.09.00\"\r\nandroidxComposeCompiler = \"1.4.3\"\r\nandroidXComposeUiGraphics = \"1.5.1\"\r\nandroidxComposeMaterial3 = \"1.2.0-alpha07\"\r\nandroidxComposeRuntimeTracing = \"1.0.0-alpha01\"\r\nandroidxCore = \"1.9.0\"\r\nkapt = \"1.8.10\"\r\nksp = \"1.8.10-1.0.9\"\r\njunit4 = \"4.13.2\"\r\nandroidxTestExtJunit = \"1.1.5\"\r\nandroidxTestCore = \"1.4.0\"\r\nandroidxTestExt = \"1.1.5\"\r\nandroidxEspresso = \"3.5.1\"\r\nlifecycleRuntimeKtx = \"2.6.1\"\r\nmaterial = \"1.8.0\"\r\nparcelize = \"1.8.0\"\r\nsdp = \"1.1.0\"\r\nhilt = \"2.45\"\r\nhiltJavax = \"1\"\r\nhiltCompiler = \"2.45\"\r\nkotlinxCoroutines = \"1.7.1\"\r\nokhttp = \"4.10.0\"\r\nretrofit = \"2.9.0\"\r\nroom = \"2.5.2\"\r\ncoil = \"2.4.0\"\r\nlottie = \"6.1.0\"\r\n\r\n[libraries]\r\n\r\n# Android\r\nandroidx-appcompat = { group = \"androidx.appcompat\", name = \"appcompat\", version.ref = \"androidxAppCompat\" }\r\nandroidx-core-ktx = { group = \"androidx.core\", name = \"core-ktx\", version.ref = \"androidxCore\" }\r\nandroidx-lifecycle-runtime-ktx = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-ktx\", version.ref = \"androidxLifecycle\" }\r\nmaterial = { group = \"com.google.android.material\", name = \"material\", version.ref = \"material\" }\r\n\r\n# Compose\r\nandroidx-compose-material3 = { group = \"androidx.compose.material3\", name = \"material3\", version.ref = \"androidxComposeMaterial3\" }\r\n\r\nandroidx-navigation-compose = { group = \"androidx.navigation\", name = \"navigation-compose\", version.ref = \"androidxNavigation\" }\r\nandroidx-lifecycle-runtime-compose = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-compose\", version.ref = \"androidxLifecycle\" }\r\n\r\nandroidx-activity-compose = { group = \"androidx.activity\", name = \"activity-compose\", version.ref = \"androidxActivity\" }\r\nandroidx-compose-bom = { group = \"androidx.compose\", name = \"compose-bom\", version.ref = \"androidxComposeBom\" }\r\nandroidx-compose-ui = { group = \"androidx.compose.ui\", name = \"ui\" }\r\nandroidx-compose-ui-graphics = { group = \"androidx.compose.ui\", name = \"ui-graphics\", version.ref = \"androidXComposeUiGraphics\" }\r\nandroidx-compose-ui-tooling = { group = \"androidx.compose.ui\", name = \"ui-tooling\" }\r\nandroidx-compose-ui-tooling-preview = { group = \"androidx.compose.ui\", name = \"ui-tooling-preview\" }\r\nandroidx-compose-runtime = { group = \"androidx.compose.runtime\", name = \"runtime\" }\r\nandroidx-compose-runtime-livedata = { group = \"androidx.compose.runtime\", name = \"runtime-livedata\" }\r\nandroidx-lifecycle-viewmodel-compose = { group = \"androidx.lifecycle\", name = \"lifecycle-viewmodel-compose\", version.ref = \"androidxLifecycle\" }\r\nandroidx-paging-compose = { group = \"androidx.paging\", name = \"paging-compose\", version.ref = \"androixPagingCompose\" }\r\n\r\n#OKHTTP\r\nokhttp-bom = { group = \"com.squareup.okhttp3\", name = \"okhttp-bom\", version.ref = \"okhttp\" }\r\nokhttp = { group = \"com.squareup.okhttp3\", name = \"okhttp\" }\r\nokhttp-logging-interceptor = { group = \"com.squareup.okhttp3\", name = \"logging-interceptor\" }\r\n\r\n#RETROFIT\r\nretrofit = { group = \"com.squareup.retrofit2\", name = \"retrofit\", version.ref = \"retrofit\" }\r\nretrofit-converter-gson = { group = \"com.squareup.retrofit2\", name = \"converter-gson\", version.ref = \"retrofit\" }\r\n\r\n#ROOM\r\nroom-ktx = { group = \"androidx.room\", name = \"room-ktx\", version.ref = \"room\" }\r\nroom-compiler = { group = \"androidx.room\", name = \"room-compiler\", version.ref = \"room\" }\r\nroom-paging = { group = \"androidx.room\", name = \"room-paging\", version.ref = \"room\" }\r\nroom-runtime = { group = \"androidx.room\", name = \"room-runtime\", version.ref = \"room\" }\r\n\r\n#TEST\r\nandroidx-arch-core-testing = { group = \"androidx.arch.core\", name = \"core-testing\", version.ref = \"androidxArchCore\" }\r\nandroidx-test-core = { group = \"androidx.test\", name = \"core\", version.ref = \"androidxTestCore\" }\r\nandroidx-test-espresso-core = { group = \"androidx.test.espresso\", name = \"espresso-core\", version.ref = \"androidxEspresso\" }\r\nandroidx-compose-ui-test = { group = \"androidx.compose.ui\", name = \"ui-test-junit4\" }\r\nandroidx-compose-ui-test-manifest = { group = \"androidx.compose.ui\", name = \"ui-test-manifest\" }\r\nandroidx-test-ext-junit = { group = \"androidx.test.ext\", name = \"junit\", version.ref = \"androidxTestExt\" }\r\njunit4 = { group = \"junit\", name = \"junit\", version.ref = \"junit4\" }\r\n\r\n# Hilt\r\nhilt-android = { group = \"com.google.dagger\", name = \"hilt-android\", version.ref = \"hilt\" }\r\nhilt-compiler = { group = \"com.google.dagger\", name = \"hilt-android-compiler\", version.ref = \"hilt\" }\r\nhilt-navigation-compose = { group = \"androidx.hilt\", name = \"hilt-navigation-compose\", version.ref = \"androidxHiltNavigationCompose\" }\r\nhilt-javax = { group= \"javax.inject\", name = \"javax.inject\", version.ref = \"hiltJavax\" }\r\n\r\n#COROUTINE\r\nkotlinx-coroutines-android = { group = \"org.jetbrains.kotlinx\", name = \"kotlinx-coroutines-android\", version.ref = \"kotlinxCoroutines\" }\r\nkotlinx-coroutines-test = { group = \"org.jetbrains.kotlinx\", name = \"kotlinx-coroutines-test\", version.ref = \"kotlinxCoroutines\" }\r\n\r\n#Sdp\r\nsdp = { group = \"com.github.Kaaveh\", name = \"sdp-compose\", version.ref = \"sdp\" }\r\n\r\n#Coil\r\ncoil = { group = \"io.coil-kt\", name = \"coil-compose\", version.ref = \"coil\" }\r\ncoil-gif = { group = \"io.coil-kt\", name = \"coil-gif\", version.ref = \"coil\" }\r\n\r\n#Lottie\r\nlottie = { group = \"com.airbnb.android\", name = \"lottie-compose\", version.ref = \"lottie\" }\r\n\r\n[plugins]\r\n\r\nandroid-application = { id = \"com.android.application\", version.ref = \"androidGradlePlugin\" }\r\nandroid-library = { id = \"com.android.library\", version.ref = \"androidGradlePlugin\" }\r\nandroid-test = { id = \"com.android.test\", version.ref = \"androidGradlePlugin\" }\r\nkotlin-android = { id = \"org.jetbrains.kotlin.android\", version.ref = \"kotlin\" }\r\nkapt = { id = \"org.jetbrains.kotlin.kapt\", version.ref = \"kapt\" }\r\nksp = { id = \"com.google.devtools.ksp\", version.ref = \"ksp\" }\r\nkotlin-jvm = { id = \"org.jetbrains.kotlin.jvm\", version.ref = \"kotlin\" }\r\nhilt = { id = \"com.google.dagger.hilt.android\", version.ref = \"hilt\" }\r\nparcelize = { id = \"org.jetbrains.kotlin.plugin.parcelize\", version.ref = \"parcelize\" }\r\n\r\n[bundles]\r\nokhttp = [\"okhttp\", \"okhttp-bom\", \"okhttp-logging-interceptor\"]\r\nretrofit = [\"retrofit\", \"retrofit-converter-gson\"]\r\ncoil = [\"coil\", \"coil-gif\"]\r\n```\r\n\r\n- toml에서 각 versions, libraries, bundles들을 관리할 수 있다.\r\n\r\n```groovy\r\ndependencies {\r\n\r\n    implementation(libs.androidx.core.ktx)\r\n    implementation(libs.androidx.lifecycle.runtime.ktx)\r\n    implementation(libs.androidx.activity.compose)\r\n    implementation(libs.androidx.navigation.compose)\r\n    implementation(platform(libs.androidx.compose.bom))\r\n    implementation(libs.androidx.compose.ui)\r\n    implementation(libs.androidx.compose.ui.graphics)\r\n    implementation(libs.androidx.compose.ui.tooling.preview)\r\n    implementation(libs.androidx.compose.material3)\r\n    testImplementation(libs.junit4)\r\n    androidTestImplementation(libs.androidx.test.ext.junit)\r\n    androidTestImplementation(libs.androidx.test.espresso.core)\r\n    androidTestImplementation(platform(libs.androidx.compose.bom))\r\n    androidTestImplementation(libs.androidx.compose.ui.test)\r\n    debugImplementation(libs.androidx.compose.ui.test.manifest)\r\n    debugImplementation(libs.androidx.compose.ui.tooling)\r\n    // Hilt\r\n    implementation(libs.hilt.android)\r\n    implementation(libs.hilt.navigation.compose)\r\n    kapt(libs.hilt.compiler)\r\n    // ViewModel\r\n    implementation(libs.androidx.lifecycle.viewmodel.compose)\r\n    // collectWithLifeCycle\r\n    implementation(libs.androidx.lifecycle.runtime.compose)\r\n    // Compose Paging\r\n    implementation(libs.androidx.paging.compose)\r\n    // Coil\r\n    implementation(libs.bundles.coil)\r\n    // Sdp\r\n    implementation(libs.sdp)\r\n    // lottie\r\n    implementation(libs.lottie)\r\n}\r\n```\r\n\r\n> 위의 적용한 부분을 보게 되면 version에 대해서는 통합하여 관리를 할 수 있지만 여전히 gradle 파일 내에서만 라이브러리 의존성을 정의해야 한다는 것을 볼 수 있다.\r\n\r\n# References\r\n- [https://docs.gradle.org/current/userguide/platforms.html](https://docs.gradle.org/current/userguide/platforms.html)\r\n- [https://ko.wikipedia.org/wiki/TOML](https://ko.wikipedia.org/wiki/TOML)"},{"excerpt":"Side Effect Sife Effect(부수 효과)는 컴포지블 외부에서 발생하는 앱의 상태 변경사항을 말한다. Compose에서는 Side Effect를 처리하기 위해 아래의 동작을 실행할 수 있는 를 사용할 수 있다. LaunchedEffect LaunchedEffect: 컴포저블에서 suspend fun을 실행하기 위해 사용된다. 컴포저블에서 시작…","fields":{"slug":"/compose-side-effect/"},"frontmatter":{"date":"August 25, 2023","title":"안드로이드 Side Effect란?","tags":["Android","Compose","Side Effect"]},"rawMarkdownBody":"<img src=\"https://github.com/ppeper/Kotlin_Algorithm/assets/63226023/3ee7a814-cc90-42ba-9411-6a20ff29c970\">\r\n\r\n# Side Effect\r\nSife Effect(부수 효과)는 컴포지블 외부에서 발생하는 앱의 상태 변경사항을 말한다. Compose에서는 Side Effect를 처리하기 위해 아래의 동작을 실행할 수 있는 `Effect API`를 사용할 수 있다.\r\n\r\n## LaunchedEffect\r\n\r\n```kotlin\r\n@Composable\r\nfun LaunchedEffect(\r\n\tkey1 : Any?,\r\n\tblock : suspend CorountineScope.() -> Unit\r\n)\r\n```\r\n\r\n- __LaunchedEffect__: 컴포저블에서 suspend fun을 실행하기 위해 사용된다.\r\n    - 컴포저블에서 시작하면 매개변수로 전달된 블록이 코루틴으로 시작된다.\r\n    - 컴포지션을 __종료하면 실행중인 코루틴이 취소__ 된다.\r\n    - key값이 다른 키로 리컴포지션되면 __기존 코루틴은 취소되고 새 코루틴에서 suspend 함수가 실행__ 된다.\r\n\r\n이외에도 LaunchedEffect에서는 여러개의 key값을 매개변수로 받아 재실행할 수 있다.\r\n\r\n```kotlin\r\n@Composable\r\nfun LaunchedEffect(\r\n\tkey1 : Any?,\r\n\tkey2 : Any?,\r\n\tblock : suspend CorountineScope.() -> Unit\r\n)\r\n\r\n@Composable\r\nfun LaunchedEffect(\r\n\tvararg : Any?,\r\n\tblock : suspend CorountineScope.() -> Unit\r\n)\r\n```\r\n\r\n## DisposableEffect\r\n\r\n```kotlin\r\n@Composable\r\nfun DisposableEffect(\r\n\tkey1 : Any?,\r\n\teffect : DisposableEffectScope.() -> DisposableEffectResult\r\n) {\r\n\tremember(key1) { DisposableEffectImpl(effect) }\r\n}\r\n```\r\n\r\n- __DisposableEffect__: 컴포저블이 Dispose될 때 정리되어야 할 Side Effect를 정의하기 위해 사용된다. \r\n\r\n실제로 사용시 재수행 되는것을 결정하는 key값과 함께 `onDispose{}` 블록에서 초기화 로직을 호출한다.\r\n\r\n```kotlin\r\n@Composable\r\nfun HomeScreen(\r\n    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current,\r\n    onStart: () -> Unit, // Send the 'started' analytics event\r\n    onStop: () -> Unit // Send the 'stopped' analytics event\r\n) {\r\n    // Safely update the current lambdas when a new one is provided\r\n    val currentOnStart by rememberUpdatedState(onStart)\r\n    val currentOnStop by rememberUpdatedState(onStop)\r\n\r\n    // If `lifecycleOwner` changes, dispose and reset the effect\r\n    DisposableEffect(lifecycleOwner) {\r\n        // Create an observer that triggers our remembered callbacks\r\n        // for sending analytics events\r\n        val observer = LifecycleEventObserver { _, event ->\r\n            if (event == Lifecycle.Event.ON_START) {\r\n                currentOnStart()\r\n            } else if (event == Lifecycle.Event.ON_STOP) {\r\n                currentOnStop()\r\n            }\r\n        }\r\n\r\n        // Add the observer to the lifecycle\r\n        lifecycleOwner.lifecycle.addObserver(observer)\r\n\r\n        // When the effect leaves the Composition, remove the observer\r\n        onDispose {\r\n            lifecycleOwner.lifecycle.removeObserver(observer)\r\n        }\r\n    }\r\n\r\n    /* Home screen content */\r\n}\r\n```\r\n\r\n위의 예시에서 onStart에서 시작하여 onStop에서 정리되어야 하는 경우에 `rememberUpdateState` 를 사용하여 각 매개변수의 onStart, onStop에 대한 state를 저장하고 lifecycle이 바뀔 때마다 새로운 observer가 lifecycle에 붙어 구독하고 `onDispose` 블록을 통하여 컴포저블이 제거될때 observer를 삭제할 수 있다.\r\n\r\n## SifeEffect\r\n\r\n- __SideEffect__: 컴포저블 State를 Compose에서 관리하지 않는 객체와 공유하기 위해 사용된다.\r\n\r\n```kotlin\r\n@Composable\r\nfun BackHandler(\r\n    backDispatcher: OnBackPressedDispatcher,\r\n    enabled: Boolean = true, // Whether back events should be intercepted or not\r\n    onBack: () -> Unit\r\n) {\r\n    /* ... */\r\n    val backCallback = remember { /* ... */ }\r\n\r\n    // On every successful composition, update the callback with the `enabled` value\r\n    // to tell `backCallback` whether back events should be intercepted or not\r\n    SideEffect {\r\n        backCallback.isEnabled = enabled\r\n    }\r\n\r\n    /* Rest of the code */\r\n}\r\n```\r\n\r\n위의 예시에서 BackHandler의 callback을 enable 할지 말지 통신을 하기위해 SideEffect를 사용해서 값을 업데이트한다.\r\n\r\n이외에 위의 3가지와 함께 사용할 수 있는 CoroutineScope와 State관련 함수를 제공한다.\r\n\r\n- `rememberCoroutineScope`: 컴포저블의 코루틴 스코프를 참조하여 외부에서 실행할 수 있도록 한다.\r\n- `rememberUpdatedState`: LaunchedEffect에서 State 변경시 재실행되지 않아도 되는 State를 정의하기 위해 사용한다.\r\n- `produceState`: Compose State가 아닌 것을 Compose State로 변환하기 위해 사용한다.\r\n- `deriveStateOf`: State를 다른 State로 변환하기 위해 사용한다.\r\n- `snapshotFlow`: 컴포저블의 State를 Flow형태로 변환한다.\r\n\r\n- - -\r\n# 정리\r\nCompose에서 새로운 내용들이 많아 적용하고 한번 정리해 볼 시간이 필요하였는데 몰랐던 내용들을 많이 알고 가는 것 같다. 개념들을 알아보면서 실제로 서비스에 적용될 때 파악하고 쓰는 것이 중요할 것 같다.\r\n\r\nCompose를 처음 프로젝트에 적용하고 개발할 때 공부하는데 어려움이 많았는데 개념들을 정리해 보면서 꾸준히 공부해 나가야겠다! 🥲\r\n\r\n- - -\r\n# References\r\n- [Compose의 부수 효과](https://developer.android.com/jetpack/compose/side-effects?hl=ko)"},{"excerpt":"Stateful vs Stateless Compose에서는 의 상태를 트리거하여 리컴포지션을 통해 화면을 갱신한다. 여기서 remember와 mutableStateOf를 써서 객체를 저장하는 컴포저블은 내부 상태를 생성해서 컴포저블을 Stateful 로 만든다. Stateless Composable은 상태를 가지지 않는 컴포저블 이다. Stateless가…","fields":{"slug":"/compose-state-hoisting/"},"frontmatter":{"date":"August 23, 2023","title":"안드로이드 Compose 상태 호이스팅","tags":["Android","Compose","State Hoisting"]},"rawMarkdownBody":"<img src=\"https://github.com/ppeper/Kotlin_Algorithm/assets/63226023/3ee7a814-cc90-42ba-9411-6a20ff29c970\">\r\n\r\n# Stateful vs Stateless\r\nCompose에서는 `State`의 상태를 트리거하여 리컴포지션을 통해 화면을 갱신한다. 여기서 remember와 mutableStateOf를 써서 객체를 저장하는 컴포저블은 __내부 상태를 생성해서 컴포저블을 Stateful__ 로 만든다.\r\n\r\n__Stateless Composable은 상태를 가지지 않는 컴포저블__ 이다. Stateless가 되기위한 쉬운 방법으로는 `상태 호이스팅`을 사용하는 것이다. 즉 상태를 상위 컴포넌트로 이동하여 내부적으로 상태를 가지지 않는 것이다. 상태 호이스팅을 이용하면 불필요한 상태가 중복되는것을 막을 수 있고, 버그 발생도 방지가 가능하다.\r\n\r\n하지만 Caller가 컴포저블 함수의 상태를 알 필요가 없을 때는 상태 호이스팅 할 필요가 없다.\r\n\r\n```kotlin\r\n@Composable\r\nfun ChatBubble(\r\n    message: Message\r\n) {\r\n    var showDetails by rememberSaveable { mutableStateOf(false) } // Define the UI element expanded state\r\n\r\n    ClickableText(\r\n        text = message.content,\r\n        onClick = { showDetails = !showDetails } // Apply simple UI logic\r\n    )\r\n\r\n    if (showDetails) {\r\n        Text(message.timestamp)\r\n    }\r\n}\r\n```\r\n\r\n위에서 `showDetails`는 해당 컴포저블 UI 요소의 내부 상태이다. 이 변수는 이 컴포저블에서만 읽고 수정이 되기 때문에 이러한 경우에는 상태를 호이스팅해도 별 다른 이득이 없기 때문에 내부에 유지할 수 있다.\r\n\r\n## 상태 호이스팅\r\n\r\n```kotlin\r\n@Preview\r\n@Composable\r\nfun ButtonEx() {\r\n    var count by remember { mutableStateOf(0) }\r\n    Button(\r\n        onClick = { count += 1 },\r\n        contentPadding = PaddingValues(16.dp)\r\n    ) {\r\n        Text(text = \"Count: $count\")\r\n    }\r\n}\r\n\r\n```\r\n<img src=\"https://github.com/ppeper/Kotlin_Algorithm/assets/63226023/199a8c1b-ff11-444c-bd31-73f86fc49517\" width=\"30%\">\r\n\r\n버튼을 클릭하면 count값이 증가하여 Button에 보여주는 컴포저블 함수가 있다. 이 함수는 내부적으로 count를 가지고 있어 Stateful하게 되어있다.\r\n\r\n상태를 끌어올리기 위해서는 상태를 두 변수로 나누는 방식으로 끌어올리게 된다.\r\n\r\n- __value: T__ (값)\r\n- __onValueChange: (T) -> Unit__ (변경하도록 요청하는 함수)\r\n\r\n```kotlin\r\n@Composable\r\nfun ButtonEx(\r\n    count: Int,\r\n    onValueChange: (Int) -> Unit\r\n) {\r\n    Button(\r\n        onClick = { onValueChange(count) },\r\n        contentPadding = PaddingValues(16.dp)\r\n    ) {\r\n        Text(text = \"Count: $count\")\r\n    }\r\n}\r\n\r\n@Preview\r\n@Composable\r\nfun ButtonStateless() {\r\n    var count by remember { mutableStateOf(0) }\r\n    ButtonEx(\r\n        count = count,\r\n        onValueChange = { count = it + 1}\r\n    )\r\n    // 마지막 매개변수에 들어간 함수는 람다로 가능\r\n    ButtonEx(\r\n        count = count,\r\n    ) {\r\n        count = it + 1\r\n    }\r\n}\r\n```\r\n\r\n<p align=\"center\"><img src=\"https://github.com/ppeper/Kotlin_Algorithm/assets/63226023/03de1614-ea05-4198-b2c3-e327ba10c9b8\" width=\"70%\"></p>\r\n\r\n위에서 내부에 있던 상태를 외부로 이동하고 ButtonEx 컴포저블 함수에서는 이벤트와 값만을 받아 Stateless하게 바뀐 것을 볼 수 있다.\r\n\r\n\r\n- - -\r\n# References\r\n- [상태를 호이스팅할 대상 위치](https://developer.android.com/jetpack/compose/state-hoisting?hl=ko)"},{"excerpt":"컴포지션(Composition) Jetpack Compose는 처음 컴포저블을 실행할때 생성되는 것으로 일종의 트리 구조로 되어 있다. 컴포지션에서 UI를 그리기 위해 호출한 한다.  컴포지션은 초기 컴포지션을 통해서만 생성 되고 리컴포지션을 통해서만 업데이트될 수 있다. 따라서 컴포지션을 수정하는 유일한 방법은 리컴포지션을 통하는 것이다. 📍 컴포저블의…","fields":{"slug":"/compose-lifecycle/"},"frontmatter":{"date":"August 22, 2023","title":"안드로이드 Compose 수명 주기","tags":["Android","Compose","State"]},"rawMarkdownBody":"<img src=\"https://github.com/ppeper/Kotlin_Algorithm/assets/63226023/3ee7a814-cc90-42ba-9411-6a20ff29c970\">\r\n\r\n# 컴포지션(Composition)\r\nJetpack Compose는 처음 컴포저블을 실행할때 생성되는 것으로 일종의 트리 구조로 되어 있다. 컴포지션에서 UI를 그리기 위해 호출한 `컴포저블을 추적`한다. \r\n\r\n컴포지션은 초기 컴포지션을 통해서만 생성 되고 리컴포지션을 통해서만 업데이트될 수 있다. 따라서 컴포지션을 수정하는 유일한 방법은 리컴포지션을 통하는 것이다.\r\n\r\n> 📍 컴포저블의 수명주기는 __1. 컴포지션 시작__, __2. 0회 이상 리컴포지션__, __3. 컴포지션 종료 이벤트__ 로 정의된다.\r\n안드로이드에서 Compose에서는 `State`를 통해서 관리를 한다.  \r\n\r\n<img src=\"https://github.com/ppeper/Kotlin_Algorithm/assets/63226023/c237ff4e-ead6-49ae-a8e8-11f5c2c36b9e\">\r\n\r\n- - -\r\n\r\n# State\r\n\r\n리컴포지션은 일반적으로 `State<T>`가 변경되면 트리게 된다. 즉 Compose에서는 앱의 상태가 변경되면 Jetpack Compose는 `리컴포지션`을 예약하고 변경 되어야 할 UI를 반영하도록 컴포지션을 업데이트 한다.\r\n\r\n```kotlin\r\n@Preview\r\n@Composable\r\nfun Greeting() {\r\n    var expanded = false\r\n    Surface(\r\n        modifier = Modifier.padding(vertical = 4.dp),\r\n        color = MaterialTheme.colorScheme.secondary\r\n    ) {\r\n        Row(\r\n            modifier = Modifier\r\n                .padding(24.dp)\r\n                .fillMaxWidth(),\r\n            horizontalArrangement = Arrangement.SpaceBetween\r\n        ) {\r\n            Text(\r\n                modifier = Modifier.align(Alignment.CenterVertically),\r\n                text = \"Compose State Expanded\"\r\n            )\r\n            Button(\r\n                onClick = { expanded = !expanded },\r\n                modifier = Modifier.align(Alignment.CenterVertically)\r\n            ) {\r\n                Text(if (expanded) \"Show Less\" else \"Show More\")\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n<img src=\"https://github.com/ppeper/Kotlin_Algorithm/assets/63226023/0504e579-ea4e-422f-a233-ec5eb5f59c40\">\r\n\r\nexpanded 라는 변수를 선언해서 Text의 내용을 변경하지만, 동작하지 않는다.\r\n\r\n상태가 바뀌면 compose가 UI를 업데이트 하지만, 이렇게 선언된 변수는 기본적으로 모니터링 하지 않는다.\r\n\r\n> Compose에서는 `mutableStateOf()` 함수를 사용해서 내부 상태를 모니터링하게 할 수 있다.\r\n\r\n## mutableStateOf, remember\r\nComposable 내부에 `mutableStateOf()`를 할당하면 동작할 것 같으나, 이 값은 Composable이 다시 만들어질때 false값이 assign된다.\r\n\r\n> 상태값을 유지하기 위해서는 `remember`를 사용해서 변경가능한 상태를 기억해야 한다.\r\n\r\n```kotlin\r\n@Preview\r\n@Composable\r\nfun Greeting() {\r\n    var expanded = remember { mutableStateOf(false) }\r\n    .\r\n    .\r\n    .\r\n            Button(\r\n                onClick = { expanded.value = !expanded.value },\r\n                modifier = Modifier.align(Alignment.CenterVertically)\r\n            ) {\r\n                Text(if (expanded.value) \"Show Less\" else \"Show More\")\r\n            }\r\n}\r\n```\r\n- expanded의 data type은 MutableState<Boolean> 이다.\r\n- 값을변경하려면 `.value` 로 속성에 접근해야 한다.\r\n\r\n<img src=\"https://github.com/ppeper/Kotlin_Algorithm/assets/63226023/4b0a301b-2c34-4acd-8070-232ab3c81e12\">\r\n\r\n## by를 통한 위임\r\n- immutable 을 위임하기 위해서는 (val)\r\n    - getValue(thisRef: R, property: KProperty<*>)를 제공해야 한다.\r\n- mutable을 위임하기 위해서는 (var)\r\n    - setValue(thisRef: R, property: KProperty<*>, value: T)를 추가로 제공해야 한다.\r\n\r\n```kotlin\r\n@Preview\r\n@Composable\r\nfun Greeting() {\r\n    var expanded by remember { mutableStateOf(false) }\r\n    .\r\n    .\r\n    .\r\n            Button(\r\n                onClick = { expanded = !expanded },\r\n                modifier = Modifier.align(Alignment.CenterVertically)\r\n            ) {\r\n                Text(if (expanded) \"Show Less\" else \"Show More\")\r\n            }\r\n}\r\n```\r\n## State 유지 - rememberSaveable\r\n일반적인 rememeber 함수는 컴포지션 내에서 컴포저블 객체들이 유지될때만 동작한다. 따라서 화면이 회전과 같이 환경구성이 변경되거나 프로세스가 죽는 경우 Activity가 재시작 되기 때문에 모든 상태를 잃게 된다.\r\n\r\n이러한 경우 remember대신에 `rememberSaveable`을 사용하면 상태를 보존할 수 있게 된다.\r\n- - -\r\n# References\r\n- [상태 및 Jetpack Compose](https://developer.android.com/jetpack/compose/state?hl=ko#state-in-composables)"},{"excerpt":"최근에 Compose를 적용하여 프로젝트를 진행하면서 하나씩 만들어 보았는데 해당 내용들을 정리해 보려고 한다. Compose Compose는 Kotlin언어를 사용하여  방식으로 UI를 그리는 방식으로 기존의 xml의 방식과는 차이가 있다. Compose를 사용하면 아래와 같은 장점이 있다. 코드 감소 Kotlin, xml로 나눠서 개발하는 것이 아닌 …","fields":{"slug":"/compose-start/"},"frontmatter":{"date":"August 21, 2023","title":"안드로이드 Compose 알아보기","tags":["Android","Compose"]},"rawMarkdownBody":"<img src=\"https://github.com/ppeper/Kotlin_Algorithm/assets/63226023/16e97d30-b69e-4621-b022-94f1e8184b24\">\r\n\r\n최근에 Compose를 적용하여 프로젝트를 진행하면서 하나씩 만들어 보았는데 해당 내용들을 정리해 보려고 한다.\r\n- - -\r\n# Compose\r\nCompose는 Kotlin언어를 사용하여 `선언형 프로그래밍` 방식으로 UI를 그리는 방식으로 기존의 xml의 방식과는 차이가 있다.\r\n\r\nCompose를 사용하면 아래와 같은 장점이 있다.\r\n- __코드 감소__\r\n    - Kotlin, xml로 나눠서 개발하는 것이 아닌 Kotlin 언어만으로 개발이 가능하다.\r\n- 선언적 API를 사용하여 __직관적__ 이다.\r\n- __빠른 개발 과정__\r\n    - Compose는 기존의 모든 코드와 호환되고 Compose에서 Views를, Views에서 Compose 코드를 호출할 수 있다.\r\n- __강력한 성능__\r\n\r\n## @Composable\r\n- 구성가능한 함수는 @Composable annotation이 달린 일반함수\r\n- Compose 함수는 대문자로 시작하도록 가이드 한다.\r\n\r\n## @Preview\r\n- 적용된 화면을 미리보기 가능\r\n\r\n# Row, Column, Box\r\n\r\n<img src=\"https://github.com/ppeper/Kotlin_Algorithm/assets/63226023/35e94a8a-b88e-4385-8984-219535d9b570\">\r\n\r\n\r\n\r\nCompose의 기본적인 Layout은 다음과 같이 세가지가 있다. `Row`와 `Column`은 xml에서 LinearLayout,   \r\n`Box`는 FrameLayout으로 볼 수 있다.\r\n\r\n## Row\r\n- Row는 행으로 UI가 배치되는 Layout이다.\r\n\r\n```kotlin\r\n@Preview\r\n@Composable\r\nfun PreviewMyRow() {\r\n    Row {\r\n        Text(text = \"Test1\")\r\n        Text(text = \"Test2\")\r\n        Text(text = \"Test3\")\r\n    }\r\n}\r\n```\r\n\r\n<img src=\"https://github.com/ppeper/Kotlin_Algorithm/assets/63226023/f23f636d-dbd1-4d9e-87ae-dd504564f40b\">\r\n\r\n## Column\r\n- Colunm는 열로 UI가 배치되는 Layout이다.\r\n\r\n```kotlin\r\n@Preview\r\n@Composable\r\nfun PreviewMyColumn() {\r\n    Column {\r\n        Text(text = \"Test1\")\r\n        Text(text = \"Test2\")\r\n        Text(text = \"Test3\")\r\n    }\r\n}\r\n```\r\n\r\n<img src=\"https://github.com/ppeper/Kotlin_Algorithm/assets/63226023/c524cd0b-8796-4f23-92fe-48f7023ae14a\">\r\n\r\n## Box\r\n- Box는 위젯을 다른 화면 위에 배치시키는 Layout이다.\r\n\r\n```kotlin\r\n@Preview\r\n@Composable\r\nfun PreviewMyBox() {\r\n    Box(\r\n        modifier = Modifier.fillMaxWidth() // 화면 너비 꽉 채우기\r\n            .height(200.dp) // 높이 200dp 설정\r\n    ) {\r\n        Text(modifier = Modifier.align(Alignment.TopStart), text = \"Test1\")\r\n        Text(modifier = Modifier.align(Alignment.Center), text = \"Test2\")\r\n        Text(modifier = Modifier.align(Alignment.BottomEnd), text = \"Test3\")\r\n    }\r\n}\r\n```\r\n\r\n<img src=\"https://github.com/ppeper/Kotlin_Algorithm/assets/63226023/65d9bbc1-5fa1-4e3d-81c4-e0c521326948\"/>\r\n\r\n> 🧐 위에서 Modifer와 align은 무엇일까?\r\n\r\n## Modifier\r\n- Surface, Text와 같은 대부분의 Compose UI Component는 modifier 매개변수를 선택적으로 허용한다.\r\n- Modifier는 상위 Component Layout내에서 UI요소가 배치되고 표시괴는 동작 방식을 지정한다.\r\n\r\n## 정렬 (Alignment)\r\n- Column, Row에서의 Alignment\r\n    - Column: `Start`, `CenterHorizontally`, `End`\r\n    - Row: `Top`, `CenterVertically`, `Bottom`\r\n- Box에서 Alignment\r\n    - `TopStart`\r\n    - `TopCenter`\r\n    - `TopEnd`\r\n    - `CenterStart`\r\n    - `Center`\r\n    - `CenterEnd`\r\n    - `BottomStart`\r\n    - `BottomCenter`\r\n    - `BottomEnd`\r\n\r\n## 배치 (Arrangement)\r\n\r\n<img src=\"https://github.com/ppeper/Kotlin_Algorithm/assets/63226023/0c49feda-906c-491f-8276-c075b901445f\">\r\n\r\n📌 정렬과 배치를 사용하면 원하는대로 UI를 구성할 수 있다.\r\n\r\n```kotlin\r\n@Composable\r\nfun MyRow() {\r\n    Row(\r\n        modifier = Modifier.size(200.dp),\r\n        horizontalArrangement = Arrangement.SpaceAround,\r\n        verticalAlignment = Alignment.Bottom\r\n    ) {\r\n        Text(text = \"Test1\")\r\n        Text(text = \"Test2\")\r\n        Text(text = \"Test3\")\r\n    }\r\n}\r\n```\r\n<img src=\"https://github.com/ppeper/Kotlin_Algorithm/assets/63226023/7dfc0090-c96d-4768-b9e0-d54f19cf2c29\">\r\n\r\n```kotlin\r\n@Preview\r\n@Composable\r\nfun PreviewMyColumn() {\r\n    Column(\r\n        modifier = Modifier.size(100.dp),\r\n        verticalArrangement = Arrangement.SpaceBetween,\r\n        horizontalAlignment = Alignment.Start\r\n    ) {\r\n        Text(text = \"Test1\")\r\n        Text(text = \"Test2\")\r\n        Text(text = \"Test3\")\r\n    }\r\n}\r\n```\r\n\r\n<img src=\"https://github.com/ppeper/Kotlin_Algorithm/assets/63226023/aac7917f-ee2c-4bbe-b7ef-3e217bbdc055\">\r\n\r\n- - -\r\n# References\r\n- [Jetpack Compose로 더 빠르게 더 나은 Android 앱 빌드](https://developer.android.com/jetpack/compose?gclid=CjwKCAjwloynBhBbEiwAGY25dNfCR8uKXeCY7EMNwc06CxF06lWnhhGDpVKV0SLdpeEGcB9cCrxnkhoCKn8QAvD_BwE&gclsrc=aw.ds&hl=ko)"},{"excerpt":"SAA (Single Activity Architecture) SAA는 Google IO 2018에 소개된 개념으로 하나 혹은 적은 수의 Activity로 애플리케이션을 개발하는 것을 말한다. Fragment에 비해 상대적으로 무거운 Activity의 사용을 자제하고, Navigation 을 사용하여 한 눈에 앱의 흐름을 보여주고 유연한 화면 구성을 할 …","fields":{"slug":"/android-navigation/"},"frontmatter":{"date":"July 01, 2023","title":"안드로이드 Navigation 사용하기","tags":["MediatorLiveData","Navigation","SafeArgs"]},"rawMarkdownBody":"# SAA (Single Activity Architecture)\r\nSAA는 Google IO 2018에 소개된 개념으로 하나 혹은 적은 수의 Activity로 애플리케이션을 개발하는 것을 말한다.\r\n\r\nFragment에 비해 상대적으로 무거운 Activity의 사용을 자제하고, __Navigation__ 을 사용하여 한 눈에 앱의 흐름을 보여주고 유연한 화면 구성을 할 수 있다.\r\n\r\n- Google IO 2018에 소개된 개념\r\n- 하나 혹은 적은 수의 Activity로 어플리케이션을 개발\r\n- Fragment에 비해서 무거운 Activity 사용을 자제하고, Navigation을 사용한 유연한 화면 구성\r\n\r\n## 📌Navigation 구성 요소\r\n\r\n- `Navigation Graph`\r\n    - Navigation 정보들을 한 곳에 모은 XML 리소스이다. 앱에서 진행될 수 있는 모든 흐름을 보여주고 앱 내 Fragment를 한 눈에 확인하기 쉽다.\r\n\r\n- `Navigation Controller`\r\n    - Navigation Host에서 App Navigation을 관리해주는 객체이다. 앱에서 그래프대로 이동할 때 Navigation Host에서 컨텐츠 전환을 담당한다.\r\n\r\n- `Navigation Host`\r\n    - Navigation Graph에서 대상을 표시하는 빈 컨테이너이다. 대상 구성요소에는 Fragment 대상을 표시하는 기본 Navigation Host 구현인 NavHostFragment가 포함된다.\r\n\r\n\r\n`Navigation Graph`에서 특정 경로를 따라 이동하거나 특정 대상으로 직접 이동하는 등 `Navigation Controller`에서 전달하고 Navigation Controller가 `Navigation Host`에 적절한 대상을 표시한다.\r\n\r\n---\r\n\r\n### 의존성 설정\r\n\r\n```gradle\r\n// Jetpack Navigation Kotlin\r\ndef nav_version = \"latest_version\"\r\nimplementation \"androidx.navigation:navigation-fragment-ktx:$nav_version\"\r\nimplementation \"androidx.navigation:navigation-ui-ktx:$nav_version\"\r\n```\r\n\r\n### 시작화면\r\nSAA로 MainActivity의 FragmentContinerView를 가지는 xml코드 예시는 아래와 같다.\r\n\r\n\r\nNavigation을 사용하기 위해 `app:navGraph` 속성에 navigation graph xml을 지정한다. \r\n\r\n```xml\r\n<FrameLayout\r\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    android:background=\"@android:color/background_light\">\r\n\r\n    <androidx.fragment.app.FragmentContainerView\r\n            android:id=\"@+id/my_nav_host_fragment\"\r\n            android:name=\"androidx.navigation.fragment.NavHostFragment\"\r\n            android:layout_width=\"match_parent\"\r\n            android:layout_height=\"match_parent\"\r\n            app:defaultNavHost=\"true\"\r\n            app:layout_constraintBottom_toBottomOf=\"parent\"\r\n            app:layout_constraintEnd_toEndOf=\"parent\"\r\n            app:layout_constraintStart_toStartOf=\"parent\"\r\n            app:layout_constraintTop_toTopOf=\"parent\"\r\n            app:navGraph=\"@navigation/navigation\"/>\r\n</FrameLayout>\r\n```\r\n\r\n### navigation.xml\r\n\r\n위와 같이 안드로이드 스튜디오에서 새로운 Fragment들을 추가할 수 있다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/235952947-f5387b1d-286b-416a-95ff-11f9dbef9061.png\">\r\n\r\n화면의 시작 위치를 시정하기 위해 `startDestination` 속성으로 처음위치를 지정한다.\r\n\r\n```xml\r\n<navigation xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n            xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n            xmlns:tools=\"http://schemas.android.com/tools\"\r\n            app:startDestination=\"@+id/title_screen\">\r\n```\r\n\r\n생성된 Fragment들은 Navigation Graph에서 drag 하여 관계를 설정할 수 있다.\r\n<img src=\"https://user-images.githubusercontent.com/63226023/235955778-b56365ff-915e-44b3-b92a-27d007433e14.png\">\r\n\r\nxml에서 생성되는 코드를 보게되면 `action` 태그에 destination이 생성되는 것을 볼 수 있다.\r\n```xml\r\n<fragment\r\n        android:id=\"@+id/title_screen\"\r\n        android:label=\"fragment_title_screen\"\r\n        tools:layout=\"@layout/fragment_title_screen\">\r\n    <action\r\n        android:id=\"@+id/action_title_screen_to_leaderboard\"\r\n        app:destination=\"@id/leaderboard\" />\r\n</fragment>\r\n...\r\n```\r\n\r\n## 화면이동\r\nTitleScreenFragment에서 해당 action 명으로 `findNavController`로 navigationController를 찾아와서 navigate method를 사용한다.\r\n\r\n```kotlin\r\nclass TitleScreenFragment : Fragment() {\r\n    override fun onCreateView(\r\n        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?\r\n    ): View {\r\n        val binding = FragmentTitleScreenBinding.inflate(inflater, container, false)\r\n        \r\n        binding.leaderboardBtn.setOnClickListener {\r\n            Navigation.findNavController(binding.root).navigate(R.id.action_title_screen_to_leaderboard)\r\n        }\r\n        return binding.root\r\n    }\r\n}\r\n```\r\n\r\n# Safe Args를 이용한 값 전달\r\n\r\n- Safe Args: 값을 전달하고 탐색을 지원하는 Gradle plugin으로 기본의 bundle로 값을 전달하는 방식 대신에 사용이 가능하다.\r\n\r\n## 프로젝트 레벨의 plugin 설정\r\n\r\n```gradle\r\nplugins {\r\n    ...\r\n    // safeArgs\r\n    id 'androidx.navigation.safeargs' version '2.4.2' apply false\r\n}\r\n```\r\n\r\n## 모듈레벨의 plugin 설정\r\n\r\n```gradle\r\nplugins {\r\n    ...\r\n    id 'androidx.navigation.safeargs.kotlin'\r\n}\r\n```\r\n\r\n\r\n- 화면간 데이터를 전달할때는 많은 데이터를 전달하는 것보다는 최소한의 데이터를 전달하는 것이 좋다.\r\n    - 객체를 전달하지 않고, key만 전달하는것이 효과적이다.\r\n\r\n\r\n- navigation.xml에 argument 태그로 전달받을 값을 지정한다.\r\n\r\n\r\n- 보내는 클래스 설정: Bundle방식과 SafeArgs 방식\r\n\r\n```kotlin\r\n// 1. Bundle로 담기\r\nval bundle = bundleOf(\"userName\" to myDataset[position])\r\nNavigation.findNavController(holder.item)\r\n      .navigate(R.id.action_leaderboard_to_userProfile, bundle)\r\n\r\n// 받는 곳\r\nval name = arguments?.getString(\"userName\") ?: \"Ali Connors\" \r\n```\r\n\r\n- Safe Args 를 사용 설정하면 송신/수신을 위한 대상 파일과 메서드들이 만들어진다.\r\n- 생성된 클래스 이름에는 `Directions` 가 추가된다.\r\n\r\n```kotlin\r\n// 2. Safe Args.\r\nval action = LeaderboardDirections.actionLeaderboardToUserProfile(myDataset[position])\r\nNavigation.findNavController(holder.item).navigate(action)\r\n\r\n// 받는 곳\r\nval name = args.userName\r\n```\r\n\r\n## Arguments를 받는쪽\r\n\r\n```kotlin\r\nclass UserProfile : Fragment() {\r\n    // safe args 방식으로 받기\r\n    val args: UserProfileArgs by navArgs()\r\n    override fun onCreateView(\r\n        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?\r\n    ): View {\r\n        //safe args 방식\r\n        val name = args.userName\r\n    }\r\n}\r\n```\r\n\r\n## Popup Behavior\r\n\r\n- backstack에 쌓는 방식을 설정한다.\r\n- `popUpTo`\r\n    - 주어진 화면이 나올때까지 BackStack을 팝 하면서, 이동한 화면을 stack에 넣는다.\r\n- `popUpToInclusive`: true\r\n    - 주어진 화면이 나올때까지 BackStack을 팝 하면서, 현재 화면은 stack에 넣지 않는다.\r\n\r\n<p align=\"center\"><img src=\"https://github.com/ppeper/Cellification/assets/63226023/bf6454d5-161b-4f66-b7aa-c57213743a0b\" width=\"50%\"></p>\r\n\r\n- - -\r\n# References \r\n- [NavigationUI로 UI 구성요소 업데이트](https://developer.android.com/guide/navigation/navigation-ui?hl=ko)"},{"excerpt":"안드로이드에서 LiveData를 데이터를 저장하고 변화를 관찰 할 수 있는 객체이다.이번에는 LiveData를 조금 더 유연하게 사용하는 방법에 대해 몰랐던 내용을 알아보려고 한다. MediatorLiveData 지금까지 하나의 LiveData는 Observer 인터페이스를 구현하는 객체를 생성하여 LiveData 값이 변경될 때 호출되는  메소드를 통해…","fields":{"slug":"/livedata-transform/"},"frontmatter":{"date":"May 02, 2023","title":"안드로이드 MediatorLiveData와 Transformations","tags":["MediatorLiveData","Transformations","LiveData"]},"rawMarkdownBody":"안드로이드에서 [LiveData](https://ppeper.github.io/android/android-livedata/)를 데이터를 저장하고 변화를 관찰 할 수 있는 객체이다.이번에는 LiveData를 조금 더 유연하게 사용하는 방법에 대해 몰랐던 내용을 알아보려고 한다.\r\n\r\n# MediatorLiveData\r\n지금까지 하나의 LiveData는 Observer 인터페이스를 구현하는 객체를 생성하여 LiveData 값이 변경될 때 호출되는 `onChange()` 메소드를 통해 관찰 할 수 있었다.\r\n\r\n```kotlin\r\nliveString.observe(this, object : Observer<String> {\r\n    override fun onChanged(liveString: String?) {\r\n        Log.d(TAG, \"value : $liveString\")\r\n        text.text = liveString\r\n    }\r\n})\r\n// 람다식으로 변환\r\nliveString.observe(this) { liveString ->\r\n    Log.d(TAG, \"value : $liveString\")\r\n    text.text = liveString\r\n}\r\n```\r\n\r\n`MediatorLiveData`는 여러 LiveData 객체들을 `observe`할 수 있도록 하는 LiveData의 하위 클래스이다. 즉 서로다른 Data Source들을 각각 관찰하는 것이 아닌 한번에 모두 관찰할 수 있다.\r\n\r\n```kotlin\r\nval emailLiveData: MutableLiveData<String> = MutableLiveData()\r\nval pwdLiveData: MutableLiveData<String> = MutableLiveData()\r\nval repwdLiveData: MutableLiveData<String> = MutableLiveData()\r\nval nameLiveData: MutableLiveData<String> = MutableLiveData()\r\nval isValidLiveData: MediatorLiveData<Boolean> = MediatorLiveData<Boolean>().apply {\r\n    // 입력이 valid 하지않으면 버튼 disabled\r\n    this.value = false\r\n\r\n    addSource(emailLiveData) {\r\n        this.value = validateForm()\r\n    }\r\n\r\n    addSource(pwdLiveData) {\r\n        this.value = validateForm()\r\n    }\r\n\r\n    addSource(repwdLiveData) {\r\n        this.value = validateForm()\r\n    }\r\n\r\n    addSource(nameLiveData) {\r\n        this.value = validateForm()\r\n    }\r\n\r\n}\r\nprivate fun validateForm(): Boolean {\r\n    return !emailLiveData.value.isNullOrBlank() && !pwdLiveData.value.isNullOrBlank()\r\n            && !repwdLiveData.value.isNullOrBlank() && !nameLiveData.value.isNullOrBlank()\r\n}\r\n```\r\n\r\n`EditText`의 입력값으로 받는 LiveData들에 대하여 입력되지 않은 값이 없을때만 버튼을 활성화 하기 위해 `addSource` 메소드로 `LiveData`와 콜백을 설정해준다. \r\n\r\n해당하는 LiveData들이 변경될 때 `validateForm()` 메서드가 호출되어 하나의 MediatorLiveData만 observe 하더라도 다른 LiveData의 변경사항이 observe되어 모든 EditText가 입력되었을 때 `isValidLiveData` 의 상태가 true로 변경될 것이다.\r\n\r\n# Transformations\r\n이름과 같이 `LiveData` 를 변환하고자 할 때 사용된다.\r\n\r\n## map()\r\n\r\n```kotlin\r\n@MainThread\r\npublic static <X, Y> LiveData<Y> map(\r\n        @NonNull LiveData<X> source,\r\n        @NonNull final Function<X, Y> mapFunction) {\r\n    final MediatorLiveData<Y> result = new MediatorLiveData<>();\r\n    result.addSource(source, new Observer<X>() {\r\n        @Override\r\n        public void onChanged(@Nullable X x) {\r\n            result.setValue(mapFunction.apply(x));\r\n        }\r\n    });\r\n    return result;\r\n}\r\n```\r\n`map()` 함수는 `MediatorLiveData`를 내부적으로 사용하여 `addSource` 메소드를 통해 Observer를 등록해 주고 `onChanged()` 에서 `mapFunction` 를 통해 파라미터로 받은 X를 Y로 변환해 주어 result값을 set해준다.\r\n\r\n예시로 LiveData인 count의 숫자 값에 따라 계산 결과를 보여주는 times 문자열 변수는 일반적으로 하면 값이 변화할 때마다 옵저빙 하기 어렵다. 따라서 count변수의 LiveData를 변경하여 새로운 LiveData형으로 만들어 줄 수 있다.\r\n\r\n```kotlin\r\nclass NewActivityViewModel:ViewModel() {\r\n    // 사용자의 클릭 수를 세는 변수\r\n    private var _count = MutableLiveData<Int>().apply {\r\n        value = 0\r\n    }\r\n    val count: LiveData<Int>\r\n        get() = _count\r\n\r\n    // 숫자를 계산 결과를 보여주는 문자열로 보여주기 위한 Transformations.map 사용\r\n    val times = Transformations.map(count) {\r\n        \"$it x 2 = ${it * 2}\"\r\n    }\r\n}\r\n```\r\n\r\n## switchMap()\r\n\r\n```kotlin\r\n@MainThread\r\npublic static <X, Y> LiveData<Y> switchMap(\r\n        @NonNull LiveData<X> source,\r\n        @NonNull final Function<X, LiveData<Y>> switchMapFunction) {\r\n    final MediatorLiveData<Y> result = new MediatorLiveData<>();\r\n    result.addSource(source, new Observer<X>() {\r\n        LiveData<Y> mSource;\r\n\r\n        @Override\r\n        public void onChanged(@Nullable X x) {\r\n            LiveData<Y> newLiveData = switchMapFunction.apply(x);\r\n            if (mSource == newLiveData) {\r\n                return;\r\n            }\r\n            if (mSource != null) {\r\n                result.removeSource(mSource);\r\n            }\r\n            mSource = newLiveData;\r\n            if (mSource != null) {\r\n                result.addSource(mSource, new Observer<Y>() {\r\n                    @Override\r\n                    public void onChanged(@Nullable Y y) {\r\n                        result.setValue(y);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    });\r\n    return result;\r\n}\r\n```\r\n\r\n`switchMap()` 은 map과 비슷하지만 함수의 결과로 받은 `LiveData` 값이 같다면 아무 작업도 수행하지 않고, 다를 경우 map과 동일한 방식으로 추가해 준다."},{"excerpt":"안드로이드에서 UI 화면을 태블릿과 같은 큰 화면에서 역동적이고 유연한 디자인을 하기 위하여 Fragment가 나오게 되었다. Fragment는 Activity와 마찬가지로 자체적인 생명주기를 가지지만 Activity의 생명주기에 영향을 받기 때문에 좀 더 신경쓰고 조심해야 하는 부분들이 많다. 처음 적용하고 공부하였을 때 신경쓰지 못하였던 Fragmen…","fields":{"slug":"/android-fragment/"},"frontmatter":{"date":"April 12, 2023","title":"안드로이드 Fragment 조각내기","tags":["Android","FragmentTransaction","Fragment"]},"rawMarkdownBody":"안드로이드에서 UI 화면을 태블릿과 같은 큰 화면에서 역동적이고 유연한 디자인을 하기 위하여 Fragment가 나오게 되었다.\r\n\r\nFragment는 Activity와 마찬가지로 자체적인 생명주기를 가지지만 Activity의 생명주기에 영향을 받기 때문에 좀 더 신경쓰고 조심해야 하는 부분들이 많다. 처음 적용하고 공부하였을 때 신경쓰지 못하였던 Fragment의 내용을 보려고 한다. \r\n- - -\r\n# Fragment LifeCycle\r\n<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/231318855-b5603bfb-265c-4f08-bd2d-5eb5c868cc54.png\" width=\"50%\"/></p>\r\n\r\nFragment는 Activity와 다르게 View와 Fragment간의 LifeCycle이 다르다.\r\n\r\n<h4>onAttach()</h4>\r\n\r\n- Fragment가 Activity에 붙을(Attach) 때 호출된다.\r\n- 아직 Fragment가 완벽하게 생성된 단계는 아니다.\r\n\r\n<h4>onCreate()</h4>\r\n\r\n- 본격적으로 Fragment가 Activity의 호출을 받아 생성되는 단계\r\n- Fragment를 생성하면서 넘겨준 값들이 있다면, 이 단계에서 값을 꺼내 세팅한ㄷ.\r\n- UI 초기화는 진행할 수 없다.\r\n\r\n<h4>onCreateView()</h4>\r\n\r\n- Layout을 inflate하는 단계. 뷰바인딩을 진행한다.\r\n- View가 초기화되는 중이기 때문에, UI 초기화 작업을 진행하면 충돌이 일어날 수 있다.\r\n\r\n<h4>onViewCreate()</h4>\r\n\r\n- UI 초기화 진행\r\n- onViewCreated()는 View 생성이 완료되었을 때 호출되는 메서드\r\n\r\n<h4>onStart()</h4>\r\n\r\n- Fragment가 사용자에게 보여 지기 직전에 호출되는 단계\r\n- 해당 메서드가 호출되었을 때, Activity는 started 상태\r\n\r\n<h4>onResume()</h4>\r\n\r\n- 사용자와의 상호작용을 시작하는 단계\r\n- 특정 이벤트가 발생하여 포커스가 떠날 때까지 onResume 단계에 머무름\r\n- 프로그램이 일시정지되면 onPause()가 호출되고, 다시 재개되면 onResume()을 다시 호출함\r\n- Resume 상태로 전환될 때마다 진행해야 되는 초기화 작업들을 세팅\r\n\r\n<h4>onPause()</h4>\r\n\r\n- 사용자가 Fragment를 떠나면 가장 먼저 onPause()를 호출\r\n- Fragment가 사용자와의 상호작용을 중지하는 단계\r\n- 사용자가 해당 Fragment로 돌아오지 않을 수도 있으므로, 지속되어야 하는 변경사항을 onPause에서 저장\r\n\r\n<h4>onStop()</h4>\r\n\r\n- 다른 Activity가 화면을 완전히 가리거나, 화면이 더이상 보여지지 않게 되는 상황에서 호출된다.\r\n- 화면이 보이지 않을 때 실행할 필요가 없는 기능들을 정지시켜 줄 수 있다.\r\n\r\n<h4>onDestroyView()</h4>\r\n\r\n- Fragment와 연결된 View Layer가 제거되는 중일 때 호출되는 단계\r\n\r\n<h4>onDestroy()</h4>\r\n\r\n- Fragment가 제거되기 직전 단게\r\n- Fragment가 생성될 때 onCreate → onCreateView 순으로 호출된 것과 달리, 파괴는 onDestroyView에서 View를 제거한 후 onDestroy가 호출된다.\r\n\r\n## getViewLifecycleOwner() vs getLifecycleOwner()\r\n\r\n<h4>LifecycleOwner</h4>\r\nLifecycleOwner는 __Fragment의 생명주기__ 를 가지고 있는 클래스로 `onAttach()` ~ `onDestroy()`와 연결되어 있다.\r\n\r\n<h4>viewLifecycleOwner</h4>\r\nviewLifecycleOwner는 __Fragment View의 생명주기__ 를 가지고 있는 클래스로 `onCreateView()` ~ `onDestroyView()` 와 연결되어 있다.\r\n\r\n> 📍viewLifecycle은 Fragment LifeCycle 보다 생명주기가 짧다!\r\n\r\n\r\n이러한 서로 다른 생명주기에 따라 대표적으로 liveData를 사용할때 매개변수로 `this`로 넘겨주었다면 __경우에 따라 Fragment가 Destroy 되지 않았지만 새로운 observer가 등록되는 경우__ 생길 수 있다.\r\n\r\n```kotlin\r\n// onAttach() ~ onDestroy()\r\nliveData.observe(this) { it -> \r\n  // this(fragment) -> Destroy 되지 않았을 때 다시 불릴 가능성\r\n}\r\n\r\n// onCreateView() ~ onDestroyView()\r\nliveData.observe(viewLifecycleOwner) { it -> \r\n  ...\r\n}\r\n```\r\n\r\n구글에서 기본으로 제공하는 Fragment 클래스에서도 View와 Fragment의 생명주기가 달라 메모리 누수가 발생할 수 있기 때문에 이에 코드를 볼 수 있다.\r\n\r\n```kotlin\r\n  private var _binding: ResultProfileBinding? = null\r\n  // This property is only valid between onCreateView and\r\n  // onDestroyView.\r\n  private val binding get() = _binding!!\r\n\r\n  override fun onCreateView(\r\n      inflater: LayoutInflater,\r\n      container: ViewGroup?,\r\n      savedInstanceState: Bundle?\r\n  ): View? {\r\n      _binding = ResultProfileBinding.inflate(inflater, container, false)\r\n      val view = binding.root\r\n      return view\r\n  }\r\n\r\n  override fun onDestroyView() {\r\n      super.onDestroyView()\r\n      _binding = null\r\n  }  \r\n```\r\n\r\nFragment는 제거되지 않았지만 `onCreateView()`는 다시 사용할 수 있기 때문에 명시적으로 `onDestroyView()`에서 binding에 할당을 취소해 가비지 컬렉션이 되도록 해야한다. \r\n\r\n- - -\r\n# FragmentManager\r\n\r\n<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/231444667-211d675f-5ce3-4b11-8b55-f745849df216.png\" width=\"70%\"/></p>\r\n\r\n- FragmentManager 속성은 호출된 Fragment 계층 구조에서 어디에 있는지에 따라 어떤 FragmentManager에 액세스하는지 다르다.\r\n- FragmentManager는 Activity와 Fragment의 중간에서 서로를 이어주는 역할을 하여 Fragment Transaction 수행해 준다.\r\n- FragmentManager은 백 스택(Back Stack) 에 Fragment 추가/교체/삭제 작업에 의한 변경 사항을 push 및 pop 하는 작업을 담당한다.\r\n\r\n> - `findFragmentById()` : Fragment 컨테이너 내의 현재 Fragment 참조\r\n>    - UI를 제공하는 Fragment를 참조할 때 사용\r\n\r\n```kotlin\r\nval fragment = supportFragmentManager.findFragmentById(binding.fragmentContainer.id)\r\n```\r\n\r\n> - `findFragmentByTag()` : Fragment에 고유한 태그를 부여한 후 태그를 이용해 Fragment 참조\r\n\r\n```kotlin\r\nval fragment = supportFragmentManager.findFragmentByTag(\"my_fragment\")\r\n```\r\n- - -\r\n# Fragment Transaction\r\n\r\nFragment Transaction의 인스턴스는 FragmentManager의 beginTransaction() 메서드를 통해 얻을 수 있다\r\n\r\n```kotlin\r\nval manager = supportFragmentManager.beginTransaction()\r\n```\r\nAndroid Jetpack Fragment 라이브러리에서 제공하는 클래스로 Transaction 클래스는 Fragment 추가/교체/삭제 작업을 제공한다.\r\n\r\n- Fragment Transaction은 FragmentManager의 단일 수행 단위\r\n- 하나의 Fragment Transaction 단위 내에 Fragment Transaction 클래스가 제공하는 Fragment 추가/교체/삭제 작업 등을 명시하면 된다.\r\n- 하나의 Fragment Transaction 단위 내에 작성된 Fragment 조작 관련 작업들은 해당 Fragment Transaction 수행될 때 모두 실행된다.\r\n\r\n## Transaction 메소드\r\nFragment의 Transaction 메소드들은 `add()`, `replace()`, `commit()`, `commitAllowingStateloss()`, `remove()`, `addToBackStack()` 등이 있다.\r\n\r\n> __add()__\r\n> - 기존에 있던 Fragment를 지우는 것이 아니라 그 위에 다시 추가한다.\r\n>\r\n> __replace()__\r\n> - 기본에 있던 Fragment를 제거한 후 새로운 Fragment를 추가한다.\r\n>\r\n> __remove()__\r\n> - 기존에 있던 Fragment를 삭제한다.  \r\n  > - fragment를 찾기 위해 `findFragmentById()`, `findFragmentByTag()` 메서드로 제거할 fragment를 찾는다\r\n>\r\n> __commit()__\r\n> - FragmentTransaction을 생성하고 Fragment의 추가/교체/삭제 작업을 명시한 후 __반드시 마지막에 commit__ 을 해줘야 한다.\r\n>\r\n> __addToBackStack()__\r\n> - 해당 메소드를 해준 후 commit()을 하게 되면 하기 전까지의 모든 변경 내용이 하나의 Transaction으로 backStack에 들어간다.\r\n\r\n## 📌 commit() vs commitNow()\r\n\r\ncommit()에는 `Now` 가 붙은 메소드들이 있다. commit() 메서드는 __비동기로 처리되는 함수__ 이기 때문에 commit 함수 호출 시점에 바로 Transaction이 즉시 수행되는 것이 아니라 Main Thread에 예약된다.\r\n\r\n반면에 commitNow() 메서드는 호출 시점에 즉시 해당 Fragment Transaction이 __동기적으로 수행__ 된다.\r\n\r\n<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/231384985-1a4605eb-ce73-454a-8a91-f1069211ce45.png\" width=\"50%\"/></p>\r\n\r\n> commitNow()는 동기적으로 실행하기 때문에 `addToBackStack()` 를 통하여 백스택에 Transaction을 추가하려는 경우 프레임워크는 명령에 대한 보증을 할 수 없기 때문에 사용할 수 없다.\r\n\r\n## 📌 commit() vs commitAllowingStateLoss()\r\nFragment를 사용을 해보았다면 `onSaveInstanceState()` 이후 commit()을 수행할 수 없다는 `IllegalStateException` 을 봤을 것이다.\r\n\r\n<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/231441130-7a39f286-91f8-4994-bd48-2bcd813fcf59.png\"/></p>\r\n\r\n- Fragment Transaction은 호스트 Activity가 자신의 상태(RESUMED, STOPPED 등)를 저장하기 전에 생성되고 commit 되어야 한다.\r\n- 만약 호스트 Activity가 `onSaveInstanceState()` 메소드를 호출한 후에 Fragment Transaction이 commit 된다면 에러가 발생한다.\r\n    - Activity의 상태가 저장될 때 자신에서 __호스팅되어 있는 Fragment의 상태도 저장__ 하게 되는데, __이러한 상태 저장 후 Fragment Transaction에 의해 Fragment 추가/교체/삭제 작업이 일어나면 Activity가 저장한 Fragment 상태와 달라__ 지기 때문이다.\r\n\r\n> 📍`commitAllowingStateLoss()` 는 commit()과 거의 동일 하지만 상태와 달라질 수 있는(상태 손실)을 허용한다.\r\n\r\n---\r\n\r\n# References \r\n- [https://developer.android.com/guide/fragments?hl=ko](https://developer.android.com/guide/fragments?hl=ko)\r\n- [https://medium.com/hongbeomi-dev/%EB%B2%88%EC%97%AD-%EB%8B%A4%EC%96%91%ED%95%9C-%EC%A2%85%EB%A5%98%EC%9D%98-commit-8f646697559f](https://medium.com/hongbeomi-dev/%EB%B2%88%EC%97%AD-%EB%8B%A4%EC%96%91%ED%95%9C-%EC%A2%85%EB%A5%98%EC%9D%98-commit-8f646697559f)"},{"excerpt":"안드로이드의 4대 컴포넌트중에 하나인 Service의 구성은 과거에 한번 나누어 본적이 있다.  안드로이드에서 Activity/Fragment는 많이 사용하지만 실제로 Service를 사용을 하지 않아 이번에 서비스에 대한 예시로 Local  Service 의 동작 과정을 보려고 한다. Bind Service 안드로이드에서 바운드 서비스는 와는 달리 하나…","fields":{"slug":"/android-local-service/"},"frontmatter":{"date":"April 10, 2023","title":"안드로이드 Local Service 알아보기","tags":["Android","Service"]},"rawMarkdownBody":"안드로이드의 4대 컴포넌트중에 하나인 [Service의 구성](https://ppeper.github.io/android/service/)은 과거에 한번 나누어 본적이 있다. \r\n\r\n안드로이드에서 Activity/Fragment는 많이 사용하지만 실제로 Service를 사용을 하지 않아 이번에 서비스에 대한 예시로 __Local  Service__ 의 동작 과정을 보려고 한다.\r\n\r\n# Bind Service\r\n안드로이드에서 바운드 서비스는 `startService()`와는 달리 하나 이상의 클라이언트 컴포넌트 간의 통신이 구현 가능하다. \r\nService가 Background에서 실행되고 있을 때, Activity 및 Fragment에서 Service의 메서드를 호출/결과를 받아서 보여주는 경우에 사용할 수 있다.\r\n\r\n## bindService 생명주기\r\n<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/150674329-805df55b-0cde-4a26-915a-1cc42fb9343a.png\" width=\"40%\"></p>\r\n\r\n- 서비스가 __bindService()__ 함수로 시작되면 `onCreate()` -> `onBind()` 함수가 호출되면서 Running 상태가 된다.\r\n- `bindService()` 함수로 실행된 서비스는 `unbindService()` 함수로 종료하고, 종료하면서 `onUnbind()` -> `onDestroy()` 함수가 호출된다.\r\n\r\n## bindService 호출 방법\r\n\r\n- startService()를 통해 서비스를 실행시키고 클라이언트가 bindService()를 통해 이에 binding 할 수 도 있다.\r\n    - 1 이때는 바인딩을 모두 해제해도 서비스가 소멸되지 않으므로 `stopSelf()` 또는 `stopService()` 를 호출 해 주어야함\r\n    - 2 이런 서비스(서비스를 계속 실행하면서 바인딩도 제공해야하는 경우) `onStartCommand()` 와 `onBind()` 둘 다를 구현 해주어야 한다.\r\n\r\n## IPC / Binder\r\n<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/230884520-c4d718d9-696c-4d99-a7da-60a3ae834b87.png\" width=\"50%\"></p>\r\n\r\n- IPC (Inter Process Communication)\r\n    - 프로세스 통신, 리눅스 커널에서 Binder를 이용하여 프로세스간 메시지를 주고 받도록 구현되어 있다.\r\n    - 안드로이드는 리눅스 커널을 기반으로 만들어져 있으므로, process는 kernel 내부의 일정 공간을 공유하여 함수를 호출하며 이를 Binder Driver가 수행한다.\r\n\r\n- Binder는 데이터를 parcel 형태로 전달하기 때문에 안드로이드에서는 `parcelable` 클래스를 활용한다.\r\n\r\n---\r\n\r\n# Local Service\r\n- Local에서 사용할 `BoundService.kt`를 작성한다.\r\n\r\n```kotlin\r\nclass BoundService: Service() {\r\n    private lateinit var myBinder: MyLocalBinder\r\n\r\n    // Foreground Service가 아니면 Bind Serice에서 사용할 Binder를 리턴\r\n    override fun onBind(intent: Intent?): IBinder {\r\n        myBinder = MyLocalBinder()\r\n        return myBinder\r\n    }\r\n\r\n    // 부를 함수를 생성\r\n    fun getCurrentTime(): String {\r\n        val dateFormat = SimpleDateFormat(\"HH:mm:ss MM/dd/yyyy\", Locale.KOREA)\r\n        dateFormat.timeZone = TimeZone.getTimeZone(\"Asia/Seoul\")\r\n        return dateFormat.format(Date())\r\n    }\r\n\r\n    // 외부면 Binder로 할 수 없음\r\n    /**\r\n     * Binder 는 IBinder 의 구현체로 onBind 를 통해 서비스 클라이언트에게 전달\r\n     * 되며 클라이언트는 이 객체를 이용해 서비스에 선언된 기능을 호출\r\n     */\r\n    inner class MyLocalBinder: Binder() {\r\n        // 외부 객체인 BoundService 객체를 반환하는 함수\r\n        fun getService() = this@BoundService\r\n    }\r\n}\r\n```\r\n\r\n- service를 사용하기 위해 AndroidManifest.xml 파일에 service를 작성해 준다.\r\n\r\n```xml\r\n<service\r\n    android:name=\"com.test.service.BoundService\"\r\n    android:enabled=\"true\"\r\n    android:exported=\"true\" />\r\n```\r\n\r\n- 서비스를 바인딩하고자 하는 Activity 파일을 생성한다.\r\n\r\n```kotlin\r\nclass BindActivity : AppCompatActivity() {\r\n\r\n    private lateinit var myService: BoundService\r\n    private var isBound = false\r\n\r\n    /**\r\n     * 서비스가 반환한 바인더 객체(service: IBinder)를 이용하여\r\n     * 서비스에 접속하거나 접속을 종료하는 ServiceConnection 객체를 활용한다.\r\n     */\r\n    private val conn = object : ServiceConnection {\r\n        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {\r\n            val binder = service as BoundService.MyLocalBinder\r\n            myService = binder.getService()\r\n            isBound = true\r\n        }\r\n\r\n        override fun onServiceDisconnected(name: ComponentName?) {\r\n            isBound = false\r\n        }\r\n    }\r\n}\r\n```\r\n서비스에서 반환할 `IBinder` 객체를 사용하기 위해 __ServiceConnection__ 의 서브 클래스를 구현하여 서비스의 연결 및 종료하는 코드를 작성하여 사용할 수 있다.\r\n\r\n```kotlin\r\noverride fun onStart() {\r\n    super.onStart()\r\n    Intent(this, BoundService::class.java).also { intent ->\r\n        bindService(intent, conn, Context.BIND_AUTO_CREATE)\r\n    }\r\n}\r\n\r\noverride fun onDestroy() {\r\n    super.onDestroy()\r\n    if (isBound) {\r\n        unbindService(conn)\r\n        isBound = false\r\n    }\r\n}\r\n\r\nprivate lateinit var binding : ActivityBindBinding\r\noverride fun onCreate(savedInstanceState: Bundle?) {\r\n    super.onCreate(savedInstanceState)\r\n    binding = ActivityBindBinding.inflate(layoutInflater)\r\n    setContentView(binding.root)\r\n\r\n    binding.button.setOnClickListener {\r\n        // 서비스에 있는 함수인 getCurrentTime 가져오기\r\n        if (isBound) {\r\n            val result = myService.getCurrentTime()\r\n            binding.textView.text = result\r\n        }\r\n    }\r\n}\r\n```\r\n- onStart()에서 isBound가 아직 안되었자면 bindService()를 호출하여 생성한 BoundService를 연결 시켜 준다.\r\n- onDestroy()에서 Activity가 종료되었다면 unbindService로 바인딩된 서비스 연결을 해제한다.\r\n\r\n해당 xml의 버튼을 누르게 되면 서비스에서 getCurrentTime()을 호출하여 현재 시간을 보여주게 된다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/230888917-1be3b7b0-1a65-46dc-9830-6e56ee68442c.png\">"},{"excerpt":"Android Permission 안드로이드에서는 특정한 앱을 실행하기 위해서는 권한이 필요하다. 안드로이드 마시멜로 버전(API 23) 이전에는 앱 설치시 모든 권한이 요청되었지만 이후에는 일반 권한, 위험 권한 으로 나눠게 되었다. 따라서 API 23 이후 버전의 기기에서는 위험 권한은 기능이 동작할 때 사용자가 직접 권한을 허락하도록 런타임에 권한을…","fields":{"slug":"/android-permission/"},"frontmatter":{"date":"March 24, 2023","title":"안드로이드 Permission 가져오기","tags":["Android","Permission"]},"rawMarkdownBody":"# Android Permission\r\n안드로이드에서는 특정한 앱을 실행하기 위해서는 권한이 필요하다. 안드로이드 마시멜로 버전(API 23) 이전에는 앱 설치시 모든 권한이 요청되었지만 이후에는 __일반 권한__, __위험 권한__ 으로 나눠게 되었다.\r\n\r\n따라서 API 23 이후 버전의 기기에서는 위험 권한은 기능이 동작할 때 사용자가 직접 권한을 허락하도록 __런타임에 권한을 설정__ 해주어야 한다.\r\n\r\n<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/229967185-75cf1404-9f97-4728-bfca-1a10731d0bea.png\"></p>\r\n\r\n위에 해당하는 기능들은 런타임시 권한을 설정해 주어야 한다. 만약 권한이 없다면 앱을 종료시켜버린다.😅\r\n\r\n## ✅권한 체크\r\n__ContextCompat.checkSelfPermission(컨텍스트(), 퍼미션정보)__ 메서드를 사용하여 앱에 이미 권한을 부여 받았는지 확인 할 수 있다.\r\n\r\n이 메서드는 앱에 권한 여부에 따라 `PERMISSION_GRANTED` 또는 `PERMISSION_DENIED`를 반환 한다.\r\n\r\n## 👉권한 요청\r\n__Activity.requestPermissions(컨텍스트(),퍼미션 리스트,요청값)__ 메서드를 사용하여 퍼미션 정보들과 요청을 보내게 되면 해당 요청 값이 반환된다.\r\n\r\n## 📄요청 결과\r\n요청 결과는 __onRequestPermissionsResult()__ 가 호출된다. 이 메서드는 요청 값을 확인하여 권한 상태에 따라 결과를 처리 한다.\r\n\r\nAndroidManifest.xml에 위치 권한을 추가한다.\r\n\r\n```xml\r\n<!-- GPS 센서로 측정-->\r\n<uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\"/>\r\n<!-- 네트워크로 측정-->\r\n<uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" />\r\n```\r\n\r\n```kotlin\r\n// 받으려는 권한들\r\nval RUNTIME_PERMISSIONS = arrayOf(\r\n    Manifest.permission.ACCESS_COARSE_LOCATION,\r\n    Manifest.permission.ACCESS_FINE_LOCATION\r\n)\r\n// 권한 요청 코드\r\nval PERMISSION_REQUEST_CODE = 8;\r\n\r\n// 권한 체크\r\nval coarseResult = ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION)\r\nval fineResult = ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION)\r\n\r\n// 권한 획득했는지 체크\r\nif (coarseResult == PackageManager.PERMISSION_GRANTED &&\r\n        fineResult == PackageManager.PERMISSION_GRANTED ){\r\n    // 권한이 확인된 이후 작업\r\n} else {\r\n    //권한이 없을때 권한 요청창 띄우기\r\n    ActivityCompat.requestPermissions(this, RUNTIME_PERMISSIONS, PERMISSION_REQUEST_CODE);\r\n}\r\n\r\n// 요청 결과\r\noverride fun onRequestPermissionsResult(\r\n    requestCode: Int,\r\n    permissions: Array<String>,\r\n    grantResults: IntArray\r\n) {\r\n    super.onRequestPermissionsResult(requestCode, permissions, grantResults)\r\n    when (requestCode) {\r\n        PERMISSION_REQUEST_CODE -> {\r\n            var results = true\r\n            Log.d(TAG, \"onRequestPermissionsResult: 건수 : $grantResults\")\r\n            if (grantResults.size > 0) {\r\n                for (temp in grantResults) {\r\n                    if (temp == PackageManager.PERMISSION_DENIED) { //전체 권한 grant확인\r\n                        results = false\r\n                        break\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (results) { // 전체 권한 획득된 경우.\r\n                Toast.makeText(this, \"모든 권한이 허가되었습니다.\", Toast.LENGTH_SHORT).show()\r\n            } else { // 거절된 경우\r\n                Toast.makeText(this, \"권한이 필요합니다.\", Toast.LENGTH_SHORT).show()\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n<img src=\"https://user-images.githubusercontent.com/63226023/230065499-72f269c8-c236-4e9e-8b8a-63dcff8f34f8.png\">\r\n\r\n안드로이드에서 `onRequestPermissionsResult()` 메소드는 deprecated 되어 registerForActivityResult를 사용하도록 권고한다.\r\n\r\n권한 설정을 하기 위해선 ActivityResultConstracts의 `RequestPermission()` 으로 단일 권한을 요청할 수 있고, `RequestMultiplePermissions()` 으로 복수 권한을 요청할 수 있다.\r\n\r\n단일 권한의 콜백으로는 `Boolean` 값으로 권한 허용 여부를 알 수 있고, 복수 권한의 경우 `Map<String, Boolean>` 으로 각 권한들의 key에 따라 구분 된다.\r\n\r\n## ActivityResultConstracts 사용하기\r\n```kotlin\r\n// 단일 권한\r\nval RUNTIME_PERMISSION = Manifest.permission.ACCESS_COARSE_LOCATION,\r\n\r\nval requestPermission = registerForActivityResult(\r\n    ActivityResultContracts.RequestPermission()) { isGrant ->\r\n    when (isGrant) {\r\n        true -> {\r\n            Toast.makeText(this,\"권한 허가\",Toast.LENGTH_SHORT).show()\r\n        }\r\n        false -> {\r\n            Toast.makeText(this,\"권한 불가\",Toast.LENGTH_SHORT).show()\r\n        }\r\n    }\r\n}\r\n\r\n// 복수 권한\r\nval RUNTIME_PERMISSIONS = arrayOf(\r\n    Manifest.permission.ACCESS_COARSE_LOCATION,\r\n    Manifest.permission.ACCESS_FINE_LOCATION\r\n)\r\n\r\nval requestMultiplePermission = registerForActivityResult(\r\n    ActivityResultContracts.RequestMultiplePermissions()) { result ->\r\n    // result -> Map<String, Boolean>\r\n    for ((permission, isGrant) in result) {\r\n        Toast.makeText(this, \"$permission = $isGrant\", Toast.LENGTH_SHORT).show()\r\n    }\r\n}\r\n\r\n// 권한 획득했는지 체크\r\nif (coarseResult == PackageManager.PERMISSION_GRANTED &&\r\n        fineResult == PackageManager.PERMISSION_GRANTED ){\r\n    // 권한이 확인된 이후 작업\r\n} else {\r\n    //권한이 없을때 권한 요청창 띄우기\r\n    // ActivityCompat.requestPermissions(this, RUNTIME_PERMISSIONS, PERMISSION_REQUEST_CODE);\r\n\r\n    // 단일 권한\r\n    requestPermission.launch(RUNTIME_PERMISSION)\r\n    // 복수 권한\r\n    requestMultiplePermission.launch(RUNTIME_PERMISSIONS)\r\n}\r\n```\r\n\r\nToast 메시지로 복수 권한에 대한 결과를 확인 해 볼 수 있다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/230070042-b37cb500-777b-4d86-a378-c2c908aa3d77.png\" width=\"30%\"/> <img src=\"https://user-images.githubusercontent.com/63226023/230070044-3d9de587-2f16-46c7-8724-68044adbdf76.png\" width=\"30%\"/> <img src=\"https://user-images.githubusercontent.com/63226023/230070051-be83cf3d-445d-4877-85c1-e19caed21b08.png\" width=\"30%\"/>\r\n\r\n- - -\r\n# References \r\n- [https://developer.android.com/training/permissions/requesting?hl=ko](https://developer.android.com/training/permissions/requesting?hl=ko)"},{"excerpt":"안드로이드 앱 내부에 데이터를 저장하게 되면 Jetpack 라이브러리에 있는 Room을 사용하게 된다.  처음 안드로이드 개발을 할 시 Room에 대한 학습을 통해 SQLite를 내부적으로 사용을 하고 있다는 것을 알았지만 직접적으로 SQLite를 사용해보지 않아 이번에 SQLite를 직접 사용해 보려고 한다. SQLite SQLite를 사용하면 Loca…","fields":{"slug":"/android-sqlite/"},"frontmatter":{"date":"March 24, 2023","title":"안드로이드 내부 데이터 저장 SQLite","tags":["Android","SQLite"]},"rawMarkdownBody":"안드로이드 앱 내부에 데이터를 저장하게 되면 Jetpack 라이브러리에 있는 [Room](https://ppeper.github.io/android/room-database/)을 사용하게 된다. \r\n\r\n처음 안드로이드 개발을 할 시 Room에 대한 학습을 통해 SQLite를 내부적으로 사용을 하고 있다는 것을 알았지만 직접적으로 SQLite를 사용해보지 않아 이번에 SQLite를 직접 사용해 보려고 한다.\r\n\r\n# SQLite\r\n\r\n- SQLite를 사용하면 Local database 생성 할 수 있다.\r\n- 관계형 데이터 베이스 구조를 따른다.\r\n- 작은 규모의 안드로이드 앱에서 사용하기 적합한 데이터 베이스이다.\r\n- 기존의 SQL문과 동일하여 __insert, delete, update, select__ 문을 사용할 수 있다.\r\n\r\n## 클래스 및 메서드\r\n<h4>SQLiteDatabase</h4>\r\n\r\n- 데이터베이스를 다루는 작업(추가, 삽입, 삭제, 쿼리) 담당한다.\r\n\r\n<h4>SQLiteOpenHelper</h4>\r\n\r\n- 데이터베이스의 생성, 열기, 업그레이드 담당한다.\r\n\r\n<h4>ContentValues</h4>\r\n\r\n- 데이터 베이스에 자료 입력 할 때 사용하는 클래스\r\n\r\n<h4>Cursor</h4>\r\n\r\n- Cursor는 SQL을 실행하는 객체, 데이터는 테이블 형식\r\n- Cursor에는 현재 가리키고 있는 로우를 나타내는 위치가 있음\r\n- 처음 처서를 반환 받았을 때 커서의 위치는 -1번째 행을 가리킴\r\n    - 주요 메서드\r\n        - `moveToNext()`\r\n            - 다음 행으로 이동하는 메서드. 이동 성공 여부에 따라 true/false 리턴\r\n        - `moveToFirst()`\r\n            - 첫 번째 행으로 위치를 움직여주는 메서드\r\n        - `moveToLast()`\r\n            - 마지막 행으로 위치를 움직여주는 메서드\r\n        - `getColumnIndex(String heading)`\r\n            - 컬럼 헤딩을 넘겨주면 특정 컬럼의 인텍스를 가져오는 메서드\r\n\r\n<h3>DBHelper</h3>\r\n\r\n- SQLiteOpenHelper를 상속 받고 테이블 생성 및 쿼리 관련 기능 정의\r\n- MainActivity 에서 DBHelper를 이용해 테이블 구성 및 C/R/U/D 처리한다.\r\n- 라이프 사이클 메서드\r\n    - `onCreate` : 테이블 생성 등 초기 설정 처리\r\n    - `onOpen` : 구동될 DB가 있다면 실제 사용 그 DB를 사용\r\n    - `onUpgrade` : 만약 현재의 DB가 구 버전이라면 DB 업그레이드 처리(drop 후 create, alter table등으로 구현)\r\n- _id integer은 SQLite를 사용하기 위해서 무조건 필수인 column이다. (primary key)\r\n    - 없으면 column “_id”  does not exist라는 에러가 발생한다.\r\n\r\n# 스키마 정의\r\n안드로이드 공식문서에서는 Contract 클래스를 생성 후  `BaseColumns` 인터페이스를 구현체를 통하여 내부 클래스는 `_ID` 라는 기본 키 필드를 상속할 수 있도록 가이드 한다.\r\n\r\n```kotlin\r\nimport android.provider.BaseColumns\r\nimport android.provider.BaseColumns._ID\r\n\r\nobject MemoContract {\r\n    \r\n    object MemoEntry : BaseColumns {\r\n        private const val TABLE_NAME = \"MEMO\"\r\n        private const val COLUMN_TITLE = \"title\"\r\n        private const val COLUMN_CONTENT = \"content\"\r\n        private const val COLUMN_DATE = \"date\"\r\n        private const val CREATE_QUERY = \"\"\"\r\n            CREATE TABLE $TABLE_NAME (\r\n                $_ID INTEGER PRIMARY KEY AUTOINCREMENT,\r\n                $COLUMN_TITLE TEXT NOT NULL,\r\n                $COLUMN_CONTENT TEXT NOT NULL,\r\n                $COLUMN_DATE TEXT NOT NULL,\r\n            )\r\n        \"\"\"\r\n        private const val DROP_QUERY = \"DROP TABLE if exists $TABLE_NAME\"\r\n    }\r\n}\r\n```\r\n## DPHelper 생성\r\n```kotlin \r\nclass MemoDBHelper(\r\n    context: Context,\r\n) : SQLiteOpenHelper(context, DATABASE_NAME, null, DATABASE_VERSION) {\r\n    private lateinit var db: SQLiteDatabase\r\n\r\n    override fun onCreate(db: SQLiteDatabase) {\r\n        db.execSQL(CREATE_QUERY)\r\n    }\r\n\r\n    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {\r\n        db.execSQL(DROP_QUERY)\r\n        onCreate(db)\r\n    }\r\n\r\n    // 데이터베이스가 writeable, readable을 호출할 때 open이 된다.\r\n    override fun onOpen(db: SQLiteDatabase) {\r\n        super.onOpen(db)\r\n        this.db = db\r\n    }\r\n\r\n    //CRUD 메소드들\r\n\r\n    companion object {\r\n        private const val DATABASE_NAME = \"memo.db\"\r\n        private const val DATABASE_VERSION = 1\r\n    }\r\n\r\n}\r\n```\r\n\r\n## Select\r\n```kotlin\r\nfun selectAllMemos(): ArrayList<MemoDto> {\r\n    val memoList = ArrayList<MemoDto>()\r\n    val projection = arrayOf(COLUMN_TITLE, COLUMN_CONTENT, COLUMN_DATE)\r\n    val orderBy = \"$COLUMN_DATE ASC\"\r\n    val cursor = db.query(\r\n        TABLE_NAME, // 테이블 이름\r\n        projection, // 반환할 컬럼들 -> null이면 *과 동일\r\n        null, // WHERE문\r\n        null, // WHERE문에 들어갈 values\r\n        null, // groupBy\r\n        null, // having\r\n        orderBy, // orderBy\r\n        null // limit\r\n    )\r\n    with(cursor) {\r\n        while (moveToNext()) {\r\n            memoList.add(\r\n                MemoDto(\r\n                    getInt(0),\r\n                    getString(1),\r\n                    getString(2),\r\n                    getString(3)\r\n                )\r\n            )\r\n        }\r\n    }\r\n    return memoList\r\n}\r\n```\r\n데이터를 조회하는 방법은 `query` 메소드를 이용하면 쉽게 Cursor 구현체를 반환 받아 사용할 수 있다.\r\n\r\nParameter는 공식문서에 잘 나와 있어, 위의 순서대로 테이블 이름, 조회하려는 칼럼들을 배열로 정의하고 이외 selection, slectionArgs, groupBy, having, orderBy, limit 등으로 다양한 조건을 추가 할 수 있다.\r\n\r\n```kotlin\r\nfun selectAllMemos(): ArrayList<MemoDto> {\r\n    val memoList = ArrayList<MemoDto>()\r\n    db.rawQuery(\"select * from $TABLE_NAME\", null).use { cursor ->\r\n        with(cursor) {\r\n            while (moveToNext()) {\r\n                memoList.add(\r\n                    MemoDto(\r\n                        getInt(0),\r\n                        getString(1),\r\n                        getString(2),\r\n                        getString(3)\r\n                    )\r\n                )\r\n            }\r\n        }\r\n    }\r\n    return memoList\r\n}\r\n```\r\n다른 방법으로는 SQL문을 직접 사용하는 `rawQuery` 메소드를 사용하여 원하는 쿼리 결과를 얻을 수도 있다.\r\n\r\n`use` 키워드는 코틀린 1.2에서 제공된 AutoCloseable 을 제공해 주는 extension 메서드로 try/catch/finally를 모두 포함하고 있다.\r\n\r\n```kotlin\r\n@InlineOnly\r\npublic inline fun <T : Closeable?, R> T.use(block: (T) -> R): R {\r\n    contract {\r\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\r\n    }\r\n    var exception: Throwable? = null\r\n    try {\r\n        return block(this)\r\n    } catch (e: Throwable) {\r\n        exception = e\r\n        throw e\r\n    } finally {\r\n        when {\r\n            apiVersionIsAtLeast(1, 1, 0) -> this.closeFinally(exception)\r\n            this == null -> {}\r\n            exception == null -> close()\r\n            else ->\r\n                try {\r\n                    close()\r\n                } catch (closeException: Throwable) {\r\n                    // cause.addSuppressed(closeException) // ignored here\r\n                }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## Insert\r\n데이터를 추가하기 위해서는 `insert` 메서드를 사용할 수 있다.\r\n\r\n```kotlin\r\nfun insertMemo(memo: MemoDto): Long {\r\n    val contentValues = ContentValues()\r\n        .apply {\r\n            put(COLUMN_TITLE, memo.title)\r\n            put(COLUMN_CONTENT, memo.content)\r\n            put(COLUMN_DATE, memo.date)\r\n        }\r\n    return db.insert(TABLE_NAME, null, contentValues)\r\n}\r\n```\r\n\r\nSQLiteDatabase 클래스 내에서는 다양한 메서드를 제공하여 추가할 데이터를 `ContentValue` 에 key-value의 형태로 저장할 수 있다.\r\n\r\n두 번째 인자는 ContentValues에 어떤 값도 삽입하지\r\n 않았을 때 실행할 작업을 알려주는 것이다.\r\n \r\n위에서와 같이 `null`을 지정하면 값이 없을 때는 행을 삽입하지 않는다.\r\n\r\ninsert() 메서드는 새로 생성된 행의 ID를 반환하거나 데이터 삽입 시 데이터의 충돌과 같은 오류가 발생하면 -1을 반환한다.\r\n\r\n## Update\r\n데이터의 수정은 `update` 메서드를 통하여 수정하려는 행에 대한 selection과 selectionArgs를 지정하고 바꾸려는 contentValues를 생성하여 인자로 넘겨준다.\r\n\r\nupdate 메서드는 데이터베이스에서 영향을 받은 행의 수가 반환된다.\r\n\r\n```kotlin\r\nfun updateMemo(memo: MemoDto): Int {\r\n    val selection = \"$_ID=?\"\r\n    val selectionArgs = arrayOf(memo.id.toString())\r\n    val contentValues = ContentValues()\r\n        .apply {\r\n            put(COLUMN_TITLE, memo.title)\r\n            put(COLUMN_CONTENT, memo.content)\r\n            put(COLUMN_DATE, memo.date)\r\n        }\r\n    return db.update(TABLE_NAME,\r\n        contentValues,\r\n        selection,\r\n        selectionArgs)\r\n}\r\n```\r\n\r\n## Delete\r\n데이터의 삭제는 `delete` 메서드를 통하여 update와 마찬가지로 where 조건절을 설정한 후 호출한다.\r\n\r\ndelete 메서드는 데이터베이스에서 삭제된 행의 수가 반환 된다.\r\n\r\n```kotlin\r\nfun deleteMemo(id: Int): Int {\r\n    val selection = \"$_ID=?\"\r\n    val selectionArgs = arrayOf(id.toString())\r\n    return db.delete(TABLE_NAME, selection, selectionArgs)\r\n}\r\n```\r\n## Activity에서 사용하기\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n    private val binding by lazy { ActivityMainBinding.inflate(layoutInflater) }\r\n    // DB 선언\r\n    private lateinit var memoDBHelper: MemoDBHelper\r\n    private lateinit var database: SQLiteDatabase\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(binding.root)\r\n        initDatabase()   \r\n    }\r\n\r\n\r\n    private fun initDatabase() {\r\n        memoDBHelper = MemoDBHelper(this)\r\n        // getWriteableDatabase/getReadbleDatabase를 호출 시 onOpen 메서드 실행\r\n        // database = memoDBHelper.readableDatabase\r\n        database = memoDBHelper.writableDatabase\r\n    }\r\n\r\n    override fun onDestroy() {\r\n        memoDBHelper.close()\r\n        super.onDestroy()\r\n    }\r\n\r\n}\r\n```\r\n데이터베이스가 닫혀 있을 때 `getWriteableDatabase` 및 `getReadbleDatabase` 메서드가 호출 시에는 리소스가 많이 사용되기 때문에 최대한 데이터베이스 연결을 하도록 하고, 사용이 끝나면 `onDestroy()` 에서 데이터베이스를 받는 것이 좋다.\r\n\r\n---\r\n\r\n# References\r\n- [https://developer.android.com/training/data-storage/sqlite?hl=ko](https://developer.android.com/training/data-storage/sqlite?hl=ko)"},{"excerpt":"안드로이드 Menu 안드로이드에서는 다양한 Menu들을 제공하여 편하게 옵션들을 보여줄 수 있다. 최근에는 사용자 경험이 바뀌어 Menu들을 통하여 옵션 세트들을 보여주는 방식이 변경이 되었지만 기본이 되는 Menu들의 각 차이점과 사용법을 알아 보려고 한다. 안드로이드에서 Menu는 크게 , , 로 구현할 수 있다. Menu 안드로이드에서 Menu를 X…","fields":{"slug":"/android-menu/"},"frontmatter":{"date":"March 10, 2023","title":"안드로이드 다양한 Menu들 사용하기","tags":["Android","Menu"]},"rawMarkdownBody":"# 안드로이드 Menu\r\n안드로이드에서는 다양한 Menu들을 제공하여 편하게 옵션들을 보여줄 수 있다. 최근에는 사용자 경험이 바뀌어 Menu들을 통하여 옵션 세트들을 보여주는 방식이 변경이 되었지만 기본이 되는 Menu들의 각 차이점과 사용법을 알아 보려고 한다.\r\n\r\n안드로이드에서 Menu는 크게 `Option`, `Context`, `Popup`로 구현할 수 있다.\r\n\r\n<h3>Options Menu</h3>\r\n화면 상단의 툴바의 흔히 점 3개로 볼 수 있는 버튼을 누르면 나타나는 Menu이다.\r\n<h3>Context Menu</h3>\r\nView를 길게 눌렀을 때 나타나는 Floating Menu이다.\r\n<h3>Popup Menu</h3>\r\nView를 눌렀을 때 나타나는 Floating Menu이다.\r\n\r\n- - -\r\n# Menu\r\n안드로이드에서 Menu를 XML 파일에서 정의하고 Acitivty나 Fragment에서 Menu 리소스를 객체로 로드하여 사용할 수 있다.\r\n\r\nMenu를 정의하기 위해서는 프로젝트의 `res/menu` directory에서 XML파일을 생성하고 해당 Menu에서 사용하는 요소들은 다음과 같다.\r\n\r\n> - __&lt;menu&gt;__\r\n>    - &lt;item&gt;, &lt;group&gt;을 하위 요소로 가지는 메뉴 항목의 컨테이너이다.\r\n> - __&lt;item&gt;__\r\n>    - Menu 내 단일 요소를 나타내며 속성들을 지정하여 여러가지 설정이 가능하다.\r\n>    - Attribute\r\n>        - id : item의 고유의 id값으로 요소를 구분할 때 사용\r\n>        - showAsAction : v3.x 이상을 사용하며, 메뉴를 ActionBar나 ToolBar 에 보여줄지 여부를 지정 (ifRoom, always, never, withText)\r\n>        - menuCategory : menu category를 정의하는 데 사용\r\n>        - title : menu에 보여줄 이름 문자열\r\n>        - titleCondensed : 이름 문자열이 너무 길었을 때 사용하는 문자열\r\n>        - icon : drawable icon\r\n> - __&lt;group&gt;__\r\n>    - &lt;item&gt;을 분류하기 위한 투명한 컨테이너이다. (선택사항) group을 통하여 분류된 item들의 가시성 등 여러 속성을 공유할 수 있다.\r\n\r\n메뉴파일을 생성하기 위해서는 `res` -> `new` -> `Android Resource File` 로 생성 할 수 있다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/224061580-725fce7a-401b-48f0-a1a5-a5b3de5b6a92.png\" width=\"60%\">\r\n\r\nmenu xml에서 item 태그 안에 menu를 중첩하여 __sub menu__ 또한 구성이 가능하다.\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<menu xmlns:android=\"http://schemas.android.com/apk/res/android\">\r\n    <item\r\n        android:id=\"@+id/example_item\"\r\n        android:title=\"안녕 메뉴아이템\" />\r\n    <group android:id=\"@+id/example_group\">\r\n        <item\r\n            android:id=\"@+id/example_item2\"\r\n            android:title=\"그룹 내부 아이템 1\" />\r\n        <item\r\n            android:id=\"@+id/example_item3\"\r\n            android:title=\"그룹 내부 아이템 2\" />\r\n    </group>\r\n    <item android:id=\"@+id/example_submenu\" android:title=\"상위 메뉴\">\r\n        <menu>\r\n            <item android:id=\"@+id/item_exit\" android:title=\"종료\" />\r\n        </menu>\r\n    </item>\r\n</menu>\r\n```\r\n- - -\r\n\r\n## Option Menu\r\nOption Menu는 __onCreateOptionsMenu()__ 와 __onCreateOptionsMenu()__ 콜백을 통하여 등록할 수 있다.\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n    private val binding by lazy { ActivityMainBinding.inflate(layoutInflater) }\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(binding.root)\r\n    }\r\n\r\n    // Menu xml을 생성 한다.\r\n    override fun onCreateOptionsMenu(menu: Menu?): Boolean {\r\n        val inflater = menuInflater\r\n        inflater.inflate(R.menu.optionmenu, menu)\r\n        return super.onCreateOptionsMenu(menu)\r\n    }\r\n\r\n    // 각 요소는 고유의 등록한 id값으로 체크하여 사용한다.\r\n    override fun onOptionsItemSelected(item: MenuItem): Boolean {\r\n        if (item.itemId == R.id.item_exit) {\r\n            finish()\r\n        } else {\r\n            Toast.makeText(this, \"Hello Menu, ${item.title}\", Toast.LENGTH_SHORT).show()\r\n        }\r\n        return super.onOptionsItemSelected(item)\r\n    }\r\n}\r\n```\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/224072847-8c19d520-34d5-43ab-90c4-48742ead5bf1.png\" width=\"30%\"> <img src=\"https://user-images.githubusercontent.com/63226023/224072860-f88e87c2-a918-4365-9e7e-9ca6e13b3609.png\" width=\"30%\">\r\n\r\n## Context Menu\r\nContext Menu는 버튼과 같은 특정 뷰를 사용자가 길게 눌렀을 때 활성화 된다. \r\n\r\nContext Menu는 Option Menu와 유사하게 __onCreateContextMenu()__ 와 __onContextItemSelect()__ 콜백을 등록하지만 __registerForContextMenu(getListView())__ 를 통하여 Context Menu와 연결해야하는 `View` 를 등록한다.\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n    private val binding by lazy { ActivityMainBinding.inflate(layoutInflater) }\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(binding.root)\r\n        // Context Menu를 View에 등록한다.\r\n        registerForContextMenu(binding.contextMenuBtn)\r\n    }\r\n\r\n    // Menu xml을 생성 한다.\r\n    override fun onCreateContextMenu(menu: ContextMenu?, v: View?, menuInfo: ContextMenu.ContextMenuInfo?) {\r\n        super.onCreateContextMenu(menu, v, menuInfo)\r\n        \r\n        menuInflater.inflate(R.menu.contextmenu, menu)\r\n    }\r\n\r\n    override fun onContextItemSelected(item: MenuItem): Boolean = with(binding) {\r\n        when(item.itemId){\r\n            R.id.context_menu_blue -> contextMenuBtn.setTextColor(Color.BLUE)\r\n            R.id.context_menu_red -> contextMenuBtn.setTextColor(Color.RED)\r\n            R.id.context_menu_green -> contextMenuBtn.setTextColor(Color.GREEN)\r\n        }\r\n        return super.onContextItemSelected(item)\r\n    }\r\n}\r\n```\r\n<img src=\"https://user-images.githubusercontent.com/63226023/224073041-5a238c30-4638-4f08-8718-dc13aee54727.png\" width=\"30%\"> <img src=\"https://user-images.githubusercontent.com/63226023/224073053-8c7710df-ffbe-448d-bbe1-f51a96e96091.png\" width=\"30%\">\r\n\r\n## Popup Menu\r\nPopup Menu는 특정 View를 눌렀을 때 활성화 된다.\r\n\r\nOption, Context와는 다르게 `PopupMenu` 를 인스턴스화 하여 View에 생성하여 사용한다. PopupMenu를 보여주기 위해서는 `show()` 를 호출해야 한다.\r\n\r\nPopupMenu에서는 __PopupMenu.OnMenuItemClickListener__ 인터페이스를 구현한 후 `setOnMenuItemclickListener()` 를 호출하여 PopupMenu에 등록하여 사용자가 항목을 누르면 __onItemClick()__ 콜백을 호출하도록 한다.\r\n\r\n```kotlin\r\n// Implement OnMenuItemClickListener\r\nclass MainActivity : AppCompatActivity(), OnMenuItemClickListener {\r\n    private val binding by lazy { ActivityMainBinding.inflate(layoutInflater) }\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(binding.root)\r\n\r\n        with(binding) {\r\n            // Popup Menu 생성\r\n           PopupMenu(this@MainActivity, binding.popupMenuBtn).apply { \r\n                inflate(R.menu.popupmenu)\r\n                setOnMenuItemClickListener(this@MainActivity)\r\n                show()\r\n            }\r\n        }\r\n    }\r\n\r\n    override fun onMenuItemClick(menuItem: MenuItem): Boolean {\r\n        when (menuItem.itemId) {\r\n            R.id.popup_menu1 -> {\r\n                Toast.makeText(this@MainActivity, \"메뉴 1 클릭\", Toast.LENGTH_SHORT).show()\r\n            }\r\n            R.id.popup_menu2 -> {\r\n                Toast.makeText(this@MainActivity, \"메뉴 2 클릭\", Toast.LENGTH_SHORT).show()\r\n            }\r\n            else -> {\r\n                Toast.makeText(this@MainActivity, \"메뉴 3 클릭\", Toast.LENGTH_SHORT).show()\r\n            }\r\n        }\r\n        return false\r\n    }\r\n}\r\n```\r\n\r\n두 번째 방법으로는 Popup Menu를 생성하하고 `setOnMenuItemClickListener()` 를 호출하여 사용할 수 있다.\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n    private val binding by lazy { ActivityMainBinding.inflate(layoutInflater) }\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(binding.root)\r\n\r\n        with(binding) {\r\n            popupMenuBtn.setOnClickListener {\r\n                val popupMenu = PopupMenu(this@MainActivity, it)\r\n                menuInflater.inflate(R.menu.pupupmenu, popupMenu.menu)\r\n                // 콜백 메소드 구현\r\n                popupMenu.setOnMenuItemClickListener { menuItem ->\r\n                    when (menuItem.itemId) {\r\n                        R.id.popup_menu1 -> {\r\n                            Toast.makeText(this@MainActivity, \"메뉴 1 클릭\", Toast.LENGTH_SHORT).show()\r\n                        }\r\n                        R.id.popup_menu2 -> {\r\n                            Toast.makeText(this@MainActivity, \"메뉴 2 클릭\", Toast.LENGTH_SHORT).show()\r\n                        }\r\n                        else -> {\r\n                            Toast.makeText(this@MainActivity, \"메뉴 3 클릭\", Toast.LENGTH_SHORT).show()\r\n                        }\r\n                    }\r\n                    false\r\n                }\r\n                // show() 를 호출하여 Popup Menu를 보여준다.\r\n                popupMenu.show();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/224073190-1c82e3d2-a0c0-48de-8628-4441b8a720f2.png\" width=\"30%\">\r\n\r\n---\r\n# References\r\n- [https://developer.android.com/guide/topics/ui/menus?hl=ko#groups](https://developer.android.com/guide/topics/ui/menus?hl=ko#groups)"},{"excerpt":"기존의 startActivityForResult 안드로이드에서 일반적으로 Activity를 전환하기 위해서는 startActivity() 를 사용하지만 화면 전환 이후에 해당 Activity에서의 결과값을 전달 받기 위해서는 startActivityForResult() 과 onActivityResult() 를 사용 하였다. // 결과를 받는 FromAct…","fields":{"slug":"/android-launcher/"},"frontmatter":{"date":"February 27, 2023","title":"안드로이드에서 Launcher를 통한 결과 전달","tags":["Android","registForActivityResult"]},"rawMarkdownBody":"# 기존의 startActivityForResult\r\n안드로이드에서 일반적으로 Activity를 전환하기 위해서는 __startActivity()__ 를 사용하지만 화면 전환 이후에 해당 Activity에서의 결과값을 전달 받기 위해서는 __startActivityForResult()__ 과 __onActivityResult()__ 를 사용 하였다.\r\n\r\n```kotlin\r\n// 두 번째 인자인 requestCode는 어떤 Activity인지 식별해주는 값\r\nstartActivityForResult(Intent(this@FromActivity, ToActivity.class.java), 101)\r\n```\r\n\r\n<h4>setResult()</h4>\r\n해당하는 ToActivity의 종료 시점에 작성하여 Activity가 종료되면 해당 메서드를 통해 호출한 Activity에 데이터를 되돌려 줄 수 있다.\r\n\r\n```kotlin\r\n// 호출당한 ToActivity\r\nval intent = Intent()\r\nintent.putExtra(\"result\", \"some data\");\r\nsetResult(RESULT_OK, intent)\r\nfinish()\r\n```\r\n\r\n<h4>onActivityResult()</h4>\r\n```kotlin\r\n\r\n// 결과를 받는 FromActivity\r\noverride fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\r\n    super.onActivityResult(requestCode, resultCode, data)\r\n    if (requestCode == 101) {\r\n        if (resultCode == Activity.RESULT_OK) {\r\n            val result = data?.getStringExtra(\"result\")\r\n            ...\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n# 새로운 API\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/223721056-cb480e59-aa90-4b29-a149-633276f74475.png\">\r\n\r\n해당하는 startActivityForResult API는 2020년 5월에 deprecated 되었다고 한다. 구글에서는 새로운 AndroidX Activity와 Fragment에 도입된 __Activity Result API__ 사용을 적극 권장한다.\r\n\r\n<h4>deprecated 된 이유와 새로운 API</h4>\r\n안드로이드에서 메모리 부족으로 인해 프로세스와 Activity가 사라질 수 있다. 기존의 방식은 같은 곳에서 `startActivityForResult`와 `onActivityResult`에서 콜백을 처리해야 했다. \r\n\r\n만약 Activity가 종료되고 다시 만들어 진다면 Activity에게 Result를 기다린다고 다시 알려주어야 한다. 따라서 호출과 콜백을 따로 분리해서 만들어 주어야 하는데 이에 대한 역할을 해주는 것이 __ActivityResultLauncher__ 이다.\r\n\r\n`registActivityForResult()` 메소드는 ActivityResultContract 및 ActivityResultCallback 을 가져와서 다른 활동을 실행하는 데 사용할 ActivityResultLauncher를 반환해 준다.\r\n\r\nregistActivityForResult()는 콜백을 등록해 주는 역할을 해주어 Activity가 종료되었다가 다시 생성이 되어도 결과를 기다리고 있다고 알려줄 수 있다.\r\n\r\n> 기존의 방식 \r\n> - A -> B를 호출하다 A가 종료된다.\r\n> - B에서는 setResult()로 결과값을 반환한다.\r\n> - 다시 돌아와서 보니 A가 종료 되었다가 다시 생성되어 결과값을 요청한지 모름\r\n>\r\n> 새로운 API\r\n> - A -> B를 호출하다 A가 종료된다.\r\n> - B에서는 setResult()로 결과값을 반환한다.\r\n> - A가 다시 생성되도 registForActivityResult() 메소드가 다시 콜백을 등록해 주기 떄문에 결과값을 받아 올 수 있다.\r\n\r\n```kotlin\r\n// 호출하는 부분 기존\r\nstartActivityForResult(Intent(this@FromActivity, ToActivity.class.java), 101)\r\n// 새로운 API -> launch() 로 시작\r\nresult.launch(Intent(this@FromActivity, ToActivity::class.java))\r\n\r\n// Contract 및 결과를 받기 위한 Callback 등록 \r\nprivate val result = registerForActivityResult(\r\n    ActivityResultContracts.StartActivityForResult()) {\r\n    if (it.resultCode == Activity.RESULT_OK) {\r\n        val intent = it.data\r\n        val data = intent?.getStringExtra(\"result\")\r\n        ...\r\n    }\r\n}\r\n```\r\n\r\n기존에서와 다르게 result라는 __ActivityResultLauncher__ 를 생성하여 콜백을 등록한다. 함수의 첫 번째 인자인 Contract는 현재 결과를 받을 Activity를 실행하는 함수인 `ActivityResultContracts.StartActivityForResult()`를 등록한다. launch()를 통하여 이동한 Activity에서는 동일하게 __setResult()__ 함수를 그대로 사용하면 된다.\r\n\r\n>📍requestCode가 필요없는 이유\r\n> - 원하는 Activity의 요청 마다 registForAcitivtyResult를 실행하여 콜백을 분리하였기 때문에 기존처럼 Acitivity를 구분할 필요가 없어졌다.\r\n\r\n---\r\n# References\r\n- [https://developer.android.com/training/basics/intents/result?hl=ko](https://developer.android.com/training/basics/intents/result?hl=ko)"},{"excerpt":"기존의 자바에서의 데이터베이스의 연결은 JDBC를 사용하여 Connection과 Statement를 가져와 SQL문을 전송하고 결과값을 받았었다. 이러한 코드를 통해 기존에는 JDBC의 연동과정과 자바 코드안에 SQL문이 들어가기 때문에 코드가 복잡하였다. 이에 대한 편의성을 제공해 주는 MyBatis Framework에 대해서 정리해 보려고 한다.(My…","fields":{"slug":"/mybatis/"},"frontmatter":{"date":"February 25, 2023","title":"Spring + MyBatis 사용하기","tags":["Spring","MyBatis"]},"rawMarkdownBody":"기존의 자바에서의 데이터베이스의 연결은 JDBC를 사용하여 Connection과 Statement를 가져와 SQL문을 전송하고 결과값을 받았었다.\r\n\r\n이러한 코드를 통해 기존에는 JDBC의 연동과정과 자바 코드안에 SQL문이 들어가기 때문에 코드가 복잡하였다. 이에 대한 편의성을 제공해 주는 __MyBatis__ Framework에 대해서 정리해 보려고 한다.[(MyBatis 시작하기)](https://mybatis.org/mybatis-3/ko/getting-started.html)\r\n- - -\r\n<img src=\"https://user-images.githubusercontent.com/63226023/218615605-d818077a-1d12-4077-91f3-134bd4481407.png\">\r\n\r\n# MyBatis\r\nMyBatis는 `Java Object`와 `SQL`문 사이의 자동 Mapping 기능을 지원하는 __ORM (Object Relational Mapping) Framework__ 이다.\r\n\r\n- MyBatis는 SQL을 별도의 파일로 분리해서 관리한다.\r\n- Object와 SQL 사이의 `parameter mapping` 작업을 자동으로 해준다.\r\n- SQL을 그대로 이용하면서 도메인 객체나 VO 객체를 중심을 개발이 가능하다.\r\n\r\n> MyBatis는 데이터베이스의 연동을 도와주어 SQL문과 분리해 주는 Framework이다.\r\n\r\n<h4>MyBatis의 특징</h4>\r\n\r\n- 쉬운 접근성과 코드의 간결함\r\n\t- 가장 간단한 persistence framework이다\r\n\t- JDBC의 모든 기능을 MyBatis가 대부분 제공\r\n\t- JDBC 관련 코드를 걷어내어 소스코드가 간결해짐.\r\n\t- 수동적인 parameter 설정과 Query 결과에 대한 mapping 구문을 제거\r\n- SQL문과 프로그래밍 코드의 분리\r\n\t- SQL에 변경이 있을 때마다 자바 코드를 수정하거나 컴파일 하지 않아도 된다.\r\n- 다양한 프로그래밍 언어로 구현가능\r\n    - JAVA, C#, .NET, Ruby, …\r\n\r\n<h4>MyBatis를 사용한 DB Access Architecture</h4>\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/221234211-60dd3f6f-0bbf-417d-b04b-d6600e13a74e.png\">\r\n\r\n## MyBatis 3의 주요 Component\r\n\r\n<h4>MyBatis의 주요 Component의 Data Access</h4>\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/221233890-8679c44f-b977-4c6b-8aa0-8a160f70f84c.png\">\r\n\r\n| 파일                                        | 설명                                                                                                                                                   |\r\n| ------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| MyBatis 설정 파일 <br> (mybatis-config.xml) | 데이터데이스의 접속 주소 정보나 객체의 alias, Mapping 파일의 경로 등의 고정된 환경 정부를 설정한다.                                                    |\r\n| SqlSessionFactoryBuilder                    | MyBatis 설정 파일을 바탕으로 SqlSessionFactory를 생성한다.                                                                                             |\r\n| SqlSessionFactory                           | SqlSession을 생성한다.                                                                                                                                 |\r\n| SqlSession                                  | 핵심적인 역할을 하는 Class로 __SQL 실행 및 Transaction 관리를 실행__ 한다.<br>SqlSession 객체는 Thread-safe 하지 않아 thread마다 필요에 따라 생성한다. |\r\n| mapping 파일<br>(member.xml)                | SQL 문과 ORMMapping을 설정한다. |\r\n\r\n## 기본 사용\r\n```xml\r\n<dependency>\r\n\t<groupId>org.mybatis</groupId>\r\n\t<artifactId>mybatis</artifactId>\r\n\t<version>x.x.x</version>\r\n</dependency>\r\n```\r\n\r\n<h4>Java Config를 통하여 SqlSessionFactory 파일 설정</h4>\r\n\r\n```java\r\nimport java.io.IOException;\r\nimport java.io.Reader;\r\n\r\nimport org.apache.ibatis.io.Resources;\r\nimport org.apache.ibatis.session.SqlSession;\r\nimport org.apache.ibatis.session.SqlSessionFactory;\r\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\r\n\r\npublic class SqlMapConfig {\r\n\r\n\tprivate static SqlSessionFactory factory;\r\n\r\n\tstatic {\r\n\t\tString resource = \"mybatis-config.xml\";\r\n\t\ttry {\r\n\t\t\tReader reader = Resources.getResourceAsReader(resource);\r\n\t\t\tfactory = new SqlSessionFactoryBuilder().build(reader);\r\n\t\t} catch (IOException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static SqlSession getSqlSession() {\r\n\t\treturn factory.openSession();\r\n\t}\r\n}\r\n```\r\n\r\nSqlSessionFactory를 빌드한 후 `openSession()` 메소드를 통하여 SqlSession을 가져올 수 있다. SqlSession은 데이터베이스에 대해 SQL 명령문을 실행하기 위한 모든 메소드들을 가지고 있다.\r\n\r\n```java\r\ntry (SqlSession session = SqlMapConfig.getSqlSession()) {\r\n  Blog blog = session.selectOne(\"org.mybatis.example.BlogMapper.selectBlog\", 101);\r\n}\r\n```\r\n\r\n# Mapper Interface\r\nMapper Interface는 mapping 파일에 기재된 SQL을 호출하기 위한 Interface이다.\r\n- Mapper Interface는 SQL을 호출하는 프로그램을 Type Safe하게 기술하기 위해 `MyBatis 3.x` 부터 등장하였다.\r\n- Mapping 파일에 있는 SQL을 __java interface를 통해 호출__ 할 수 있도록 해준다.\r\n\r\nMapper Interface를 사용하지 않았을 경우에는 SQL을 호출하는 프로그램은 SqlSession의 메소드의 인자로 __namespace.(SQL ID)__ 으로 지정 해야한다.\r\n\r\n```xml\r\n<mapper namespace=\"com.test.UserDao\">\r\n\t<select id=\"search\" parameterType=\"String\">\r\n\t...\r\n</mapper>\r\n```\r\n\r\nDAO에서 사용할때는 `sqlSession.selectOne(\"com.test.UserDao.search\", userid)` 로 사용\r\n\r\nMapper Interface를 사용하지 않는다면 문자열로 지정하기때문에 오타에 의한 버그가 생기거나, IDE에서 제공하는 code assist를 사용할 수 없다.\r\n\r\n<h3>Mapper Interface를 사용했을 경우</h3>\r\n\r\nMapper Interface를 사용할 경우 __UserMapper Interface__ 는 개발자가 작성해 준다.\r\n\r\nnamespace 속성에는 package를 포함한 Mapper Interface의 이름을 작성하고 SQL ID에는 __mapping하는 method의 이름과 같게 지정해 주어야한다.__\r\n\r\n```xml\r\n<mapper namespace=\"com.test.dao.UserMapper\">\r\n\t<select id=\"search\" parameterType=\"String\">\r\n\t...\r\n</mapper>\r\n```\r\n\r\n```java\r\n// UserMapper 인터페이스\r\npublic interface UserMapper {\r\n\t// 메소드 이름과 id의 이름이 동일하다.\r\n\tpublic UserDto search(userid: String)\r\n}\r\n\r\n```\r\n\r\n해당 Mapper Interface는 구현할 필요없이 `mapper.search(userid);` 로 사용이 가능하다.\r\n- - -\r\n# MyBatis - Spring\r\n- MyBatis를 Stand alone 형태로 사용하는 경우에는 , `SqlSessionFactory` 객체를 직접 사용한다.\r\n- Spring을 사용하는 경우, Spring Container에 MyBatis 관련 `Bean` 을 등록하여 MyBatis를 사용한다.\r\n- MyBatis를 Spring과 연동하기 위해서는 MyBatis에서 제공하는 Spring 연동 라이브러리가 필요하다.\r\n\r\n## dependency 추가하기\r\nMaven 프로젝트에서의 dependency를 추가해준다.\r\n\r\n```xml\r\n<dependency>\r\n\t<groupId>org.mybatis</groupId>\r\n\t<artifactId>mybatis</artifactId>\r\n\t<version>x.x.x</version>\r\n</dependency>\r\n\r\n<!-- mybatis와 spring 연동 -->\r\n<dependency>\r\n\t<groupId>org.mybatis</groupId>\r\n\t<artifactId>mybatis-spring</artifactId>\r\n\t<version>x.x.x</version>\r\n</dependency>\r\n\r\n<!-- spring에서 db와 transaction 처리 -->\r\n<dependency>\r\n\t<groupId>org.springframework</groupId>\r\n\t<artifactId>spring-tx</artifactId>\r\n\t<version>${org.springframework-version}</version>\r\n</dependency>\r\n\r\n<!-- database 처리 -->\r\n<dependency>\r\n\t<groupId>org.springframework</groupId>\r\n\t<artifactId>spring-jdbc</artifactId>\r\n\t<version>${org.springframework-version}</version>\r\n</dependency>\r\n```\r\n\r\n## DataSource 설정\r\n스프링을 사용하는 경우, 스프링에서 DataSource를 관리하므로 MyBatis 설정파일에서는 일부 설정을 생략한다.\r\n\r\n스프링 환경 설정파일(application-context.xml) 에 DataSource를 설정 한다. MyBatis와 스프링을 연동하면 데이터베이스 설정과 트랜잭션 처리는 스프링에서 관리한다.\r\n\r\n- 일반 Connection 설정\r\n\r\n```xml\r\n<bean id=\"ds\" class=\"org.springframework.jdbc.datasource.SimpleDriverDataSource\" destroy-method=\"close\"> \r\n\t<property name=\"driverClass\" value=\"com.mysql.cj.jdbc.Driver\"></property> \r\n\t<property name=\"url\" value=\"jdbc:mysql://localhost:3306/mydb?serverTimezone=UTC&amp;useUniCode=yes&amp;characterEncoding=UTF-8\"/> \r\n\t<property name=\"username\" value=\"id\"/>\r\n\t<property name=\"password\" value=\"pw\"/>\r\n</bean>\r\n```\r\n\r\n- Connection Pool 설정\r\n\t- 시스템 자원인 Connection을 pool 형태로 관리하여, 연결하고 반납할때의 시간을 절약.\r\n\t- 서버당 Connection의 수를 통제하여 전체 시스템 장애로 전파되는것을 방지한다.\r\n\t- apache common dbcp2, hikari dbcp 등이 있다.\r\n\r\n```xml\r\n<bean id=\"ds\"\r\n\tclass=\"org.apache.commons.dbcp2.BasicDataSource\"\r\n\tdestroy-method=\"close\">\r\n\t<property name=\"driverClassName\"\r\n\t\tvalue=\"com.mysql.cj.jdbc.Driver\" />\r\n\t<property name=\"url\"\r\n\t\tvalue=\"jdbc:mysql://localhost:3306/mydb?serverTimezone=UTC&amp;useUniCode=yes&amp;characterEncoding=UTF-8\" />\r\n\t<property name=\"username\" value=\"id\" />\r\n\t<property name=\"password\" value=\"pw\" />\r\n\t<!-- connection pool 크기 설정 -->\r\n\t<property name=\"initialSize\" value=\"10\" />\r\n\t<property name=\"maxTotal\" value=\"10\" />\r\n\t<property name=\"maxIdle\" value=\"10\" />\r\n\t<property name=\"minIdle\" value=\"10\" />\r\n\t<!-- connection pool에 여유가 없을때 대기시간 -->\r\n\t<property name=\"maxWaitMillis\" value=\"3000\" />\r\n</bean>\r\n```\r\n\r\n## 트랜잭션 관리자 설정\r\ntransactionManager 아이디를 가진 빈은 트랜잭션을 관리하는 객체이다. MyBatis는 JDBC를 그대로 사용하기 때문에 __DataSourceTransactionManager__ 타입의 빈을 사용한다.\r\n\r\n`tx:annotation-driven` 요소는 트랜잭션 관리방법을 어노테이션으로 선언하도록 설정하여 스프링은 메소드, 클래스에 __@Transactional__ 이 선언되어 있으면, AOP를 통해 트랜잭션을 처리한다.\r\n\r\n```xml\r\n<bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\r\n\t<property name=\"dataSource\" ref=\"ds\"/>\r\n</bean>\r\n```\r\n\r\n<h4>어노테이션 기반 트랜잭션 설정</h4>\r\n\r\n```xml\r\n<tx:annotation-driven transaction-manager=\"transactionManager\"/>\r\n```\r\n\r\n## SqlSessionFactoryBean\r\nMyBatis 애플리케이션은 SqlSessionFactory를 중심으로 수행하여 스프링에서 객체를 생성하기 위해서는 빈으로 __SqlSessionFactoryBean__ 를 등록해야 한다.\r\n\r\n해당 SqlSessionFactoryBean을 등록할 때, 사용할 DataSource 및 mybatis의 설정파일 정보가 필요하다.\r\n\r\n```xml\r\n<bean id=\"ds\"\r\n\tclass=\"org.apache.commons.dbcp2.BasicDataSource\"\r\n\tdestroy-method=\"close\">\r\n\t...\r\n</bean>\r\n<!-- MyBatis-Spring 설정 -->\r\n<bean id=\"sqlSessionFactoryBean\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\r\n\t<property name=\"dataSource\" ref=\"ds\"/>\r\n\t<property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/>\r\n\t<property name=\"mapperLocations\">\r\n\t\t<list>\r\n\t\t\t<value>classpath:guestbook.xml</value>\r\n\t\t\t<value>classpath:member.xml</value>\r\n\t\t</list>\r\n\t</property>\r\n</bean>\r\n```\r\n\r\n해당하는 dataSource, configuration을 설정하고 `mapperLocations` 로 해당하는 SQL문이 있는 mapping파일을 각각 등록해 줄 수 있다.\r\n\r\n__classpath:__ 의 경로는 default로 `projectname/src/main/resources/`, `projectname/src/main/java/` 의 두 곳을 의미하고 있다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/221350133-e3de69e0-0ad2-4725-b7d1-e76d5fbdd54b.png\">\r\n\r\nmapper 파일들이 많아질 경우 일일이 다 등록을 해주기에 번거로울 수 있으므로 __mapper scanner__ 를 사용하여 자동으로 등록할 수 있다.\r\n\r\n```xml\r\n<!-- bace-package 하위의 모든 매퍼 인터페이스가 자동으로 등록된다. -->\r\n<mybatis-spring:scan base-package=\"com.test.mapper\"/>\r\n```\r\n\r\n## MyBatis Configuration (mybatis-config.xml)\r\n스프링을 사용하면 DB 접속정보 및 Mapper 관련 설정은 스프링 빈으로 등록하여 관리하므로 MyBatis 환경설정 파일에서는 스프링에서 관리하지 않는 일부 정보만 설정한다. (ex. typeAlias, typeHandler..)\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \r\n    \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\r\n    \r\n<configuration>\r\n    <typeAliases>\r\n        <typeAlias type=\"com.xxx.model.MemberDto\" alias=\"member\" />\r\n    </typeAliases>\r\n</configuration>\r\n```\r\n\r\n## Mapper 파일\r\nmapper 파일들에서 위의 typeAlias로 설정한 name으로 사용이 가능하다.\r\n\r\n```xml\r\n<mapper namespace=\"com.xxx.mapper.UserDao\">\r\n\r\n    <select id=\"login\" parameterType=\"map\" resultType=\"member\">\r\n        select *\r\n        from mydb\r\n        where userid = #{userid} and userpwd = #{userpwd}\r\n    </select>\r\n    \r\n</mapper>\r\n```\r\n\r\n<h4>위에서 Mapper Interface에서 보았던 SQL ID는 mapping하는 메소드이름과 동일해야 한다.</h4>\r\n\r\n```java\r\npublic interface UserDao {\r\n    public MemberDto login(Map<String, String> map) throws SQLException;\r\n}\r\n```\r\n\r\n<h4>Mapper가 설정이 완료 되었으면 어노테이션을 통하여 사용하려는 Mapper Interface를 데이터접근 객체와 의존관계를 설정하여 사용한다.</h4>\r\n\r\n```java\r\n@Service\r\npublic class UserServiceImpl implements UserService {\r\n    \r\n   @Autowired\r\n   private UserDao dao;\r\n    \r\n    @Override\r\n    public MemberDto login(Map<String, String> map) throws Exception {\r\n        if(map.get(\"userid\") == null || map.get(\"userpwd\") == null)\r\n            return null;\r\n       return dao.login(map);\r\n    }\r\n}\r\n```"},{"excerpt":"스프링 부트 기존의 스프링은 자바 기반의 프레임워크로 애플리케이션을 개발하려면 사전에 많은 작업(library, dependency 추가등) 을 해야 했다. 스프링 부트는 개발자들이 더욱 쉽게 스프링 애플리케이션을 개발할 수 있도록 도와준다. 스프링 부트는 스프링 프레임워크와 마찬가지로 이나 과 같은 빌드 도구를 사용하고, Tomcat, Jetty, Un…","fields":{"slug":"/springboot/"},"frontmatter":{"date":"February 25, 2023","title":"스프링을 편하게 스프링 부트를 사용해보자","tags":["Spring Boot"]},"rawMarkdownBody":"<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/219384293-26ebb15a-3b13-45c8-abf8-57622c2d0eee.png\"></p>\r\n\r\n# 스프링 부트\r\n기존의 스프링은 자바 기반의 프레임워크로 애플리케이션을 개발하려면 사전에 많은 작업(library, dependency 추가등) 을 해야 했다. 스프링 부트는 개발자들이 더욱 쉽게 __스프링 애플리케이션을 개발할 수 있도록 도와준다.__\r\n\r\n<h5>스프링 부트의 장점</h5>\r\n- project에 따라 자주 사용되는 library 들이 미리 조합되어 있다.\r\n- 복잡한 설정을 자동으로 처리해 준다.\r\n- WAS에 배포하지 않고도 실행할 수 있는 JAR파일로 웹 애플리케이션을 개발 할 수 있다.\r\n\r\n스프링 부트는 스프링 프레임워크와 마찬가지로 `Maven`이나 `Gradle`과 같은 빌드 도구를 사용하고, __Tomcat, Jetty, Undertow 등의 웹 서버를 내장하고 있어 별도로 웹 서버를 설치하거나 설정할 필요가 없다.__\r\n\r\n| 이름         | 서블릿 버전 | 자바 버전 |\r\n| ------------ | ----------- | --------- |\r\n| Tomcat 8     | 3.1         | Java 7+   |\r\n| Tomcat 7     | 3.0         | Java 6+   |\r\n| Jetty 9      | 3.1         | Java 7+   |\r\n| Jetty 8      | 3.0         | Java 6+   |\r\n| Undertow 1.1 | 3.1         | Java 7+   |\r\n\r\n- - -\r\n# 스프링 부트 시작하기\r\n\r\n스프링 프레임워크의 경우 configuration설정을 할 때에 어노테이션, 빈 등록등의 설정을 해주어야 했다. 이에 반해 스프링 부트의 경우 `application.properties` 파일이나 `application.yml` 파일에 설정하면 된다.\r\n\r\n스프링 부트는 [Spring initializr](https://start.spring.io) 또는 이클립스, 인텔리제이로 쉽게 시작할 수 있다. 스프링 부트를 생성하면 메인 클래스가 생성되고 실행하게 되면 내장된 톰켓 서버가 동작한다.\r\n\r\n## 프로젝트 구조\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/221412311-6974b62c-698e-4ba3-a718-49286573024d.png\">\r\n\r\n| 프로젝트의 주요 파일   | 설명                                                                                                                   |\r\n| ---------------------- | ---------------------------------------------------------------------------------------------------------------------- |\r\n| src/main/java          | 자바 소스 코드들이 있는 directory.                                                                                     |\r\n| SpringbootApplication  | application을 시작할 수 있는 main method가 존재하는 스프링 구성 메인 클래스이다.<br>최상위 패키지에 두는것을 권장한다. |\r\n| static                 | css, js, img등의 정적 리소스들의  directory.                                                                           |\r\n| templates              | SpringBoot에서 사용 가능한 여러가지 View Template(Thymeleaf, Velocity, FreeMarker등) 위치한다.                         |\r\n| application.properties | application 및 스프링의 설정 등에서 사용할 여러 가지 property를 정의한 파일이다.                                       |\r\n| src/main               | jsp등이 위치한 directory                                                                                               |\r\n\r\n## 의존성 관리\r\n- 스프링 부트는 여러 의존성들을 관리해준다.\r\n- `pom.xml`에 parent로 설정되어 있는 `spring-boot-starter-parent`를 살펴보면 관리해주는 의존성들의 version이 나와있는 것을 알 수 있다.\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n\t<modelVersion>4.0.0</modelVersion>\r\n\t<parent>\r\n\t\t<groupId>org.springframework.boot</groupId>\r\n\t\t<artifactId>spring-boot-starter-parent</artifactId>\r\n\t\t<version>2.7.9</version>\r\n\t\t<relativePath/> <!-- lookup parent from repository -->\r\n\t</parent>\r\n\t<groupId>com.example</groupId>\r\n\t<artifactId>springboot</artifactId>\r\n\t<version>0.0.1-SNAPSHOT</version>\r\n\t<name>springboot</name>\r\n\t<description>Demo project for Spring Boot</description>\r\n\t<properties>\r\n\t\t<java.version>1.8</java.version>\r\n\t</properties>\r\n```\r\n\r\n## @SpringBootApplication\r\n\r\n```java\r\nimport org.springframework.boot.SpringApplication;\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\n\r\n@SpringBootApplication\r\npublic class SpringbootApplication {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tSpringApplication.run(SpringbootApplication.class, args);\r\n\t}\r\n\r\n}\r\n```\r\n\r\n> @SpringBootApplication 어노테이션은 스프링 부트에서 설정을 도와준다.<br>이 어노테이션을 제거하고 프로그램을 실행하게 되면, 일반적인 자바 프로그램과 같이 동작하게 된다.<br>해당 어노테이션 덕분에 외부 라이브러리, 내장 서버등이 실행이 가능하다.\r\n\r\n<h4>SpringbootApplication 실행</h4>\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/221411738-cd5eeef5-89a7-4099-a1ae-a0add6fff551.png\">\r\n\r\n- - -\r\n\r\n```java\r\n@Target(ElementType.TYPE)\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Documented\r\n@Inherited\r\n@SpringBootConfiguration\r\n@EnableAutoConfiguration\r\n@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\r\n\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\r\npublic @interface SpringBootApplication {\r\n```\r\n\r\n- 메인 클래스에 붙어 있는 `@SpringBootApplication`은 자동 설정을 해주기 위한 어노테이션으로 크게 3개가 합쳐진 것이라고 생각할 수 있다.\r\n1. `@SpringBootConfiguration`\r\n2. `@ComponentScan`\r\n3. `@EnableAutoConfiguration`\r\n\r\n@SpringBootApplication은 Bean을 2번 등록한다. 처음에 ComponentScan으로 등록하고, EnableAutoConfiguration으로 추가적인 Bean을 읽어서 등록한다.\r\n\r\n## @SpringBootConfiguration\r\n- @SpringBootConfiguration은 스프링의 @Configuration을 대체하는 스프링 부트 전용 어노테이션이다.\r\n- 테스트 어노테이션을 사용할 때 이 어노테이션을 찾기 때문에 스프링부트에서는 필수 어노테이션이다.\r\n\r\n## @ComponentScan\r\n- @ComponentScan은 해당 패키지에서 @Component 어노테이션을 가진 `Bean` 들을 스캔해서 등록한다.\r\n  - @Component\r\n  - @Configuration\r\n  - @Repository\r\n  - @Service\r\n  - @Controller\r\n  - @RestController\r\n  - ....\r\n\r\n## @EnableAutoConfiguration\r\n- 이름에서와 같이 `Bean` 을 등록하는 자바 설정 파일이다.\r\n`spring-boot-autoconfigure/MEFA-INF/spring.factories` 에 정의되어 있는 configuration 대상 클래스들을 빈으로 등록한다.\r\n\r\n`spring.factories`를 열어 보게되면 수 많은 자동 설정 조건에 따라 적용되어 Bean들이 생성된다.\r\n```\r\n# Initializers\r\norg.springframework.context.ApplicationContextInitializer=\\\r\norg.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\\\r\norg.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener\r\n\r\n# Application Listeners\r\norg.springframework.context.ApplicationListener=\\\r\norg.springframework.boot.autoconfigure.BackgroundPreinitializer\r\n...\r\n```\r\n\r\n이 리스트에 있는 클래스들은 `@Configuration` 어노테이션이 없어도 자동으로 Bean으로 등록되어 스프링에서의 해줘야했던 작업들을 자동으로 해준다.\r\n\r\n## 내장 서버\r\n스프링 부트의 특징 중 하나는 `톰캣 서버`가 내장되어 있다는 것으로 톰캣 내장 서버는 자동 설정의 일부로, 스프링 부트에서는 톰캣과 서블릿 서버가 자동으로 설정되어 있다.\r\n\r\n따라서 스프링 부트 애플리케이션을 실행하면 톰캣이 생성되고 서블릿이 추가가 되면서 애플리케이션이 작동하게 된다.\r\n\r\n서블릿 웹 서버 생성 설정 파일인 `org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration`을 찾을 수 있다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/221413811-6b84f5b7-da5a-4633-8f80-6d847e3c083e.png\">\r\n"},{"excerpt":"Model-View-Controller (MVC) MVVM과 MVC의 패턴의 차이를 알아보면서 간단히 보았던 MVC 아키텍처 패턴은 애플리케이션의 확장을 위해 세가지 영역(Model, View, Controller)으로 분리 한 것으로 이러한 Model 2(Web MVC) 아키텍처 패턴은 화면과 비지니스 로직을 분리해서 작업하기 때문에 확장성이 뛰어나고,…","fields":{"slug":"/spring-mvc/"},"frontmatter":{"date":"February 22, 2023","title":"Spring Web MVC 프레임워크 보기","tags":["Spring","MVC"]},"rawMarkdownBody":"# Model-View-Controller (MVC)\r\n[MVVM과 MVC의 패턴의 차이](https://ppeper.github.io/android/android-acc/#-mvc-vs-mvvm)를 알아보면서 간단히 보았던 MVC 아키텍처 패턴은 애플리케이션의 확장을 위해 세가지 영역(Model, View, Controller)으로 분리 한 것으로 이러한 Model 2(Web MVC) 아키텍처 패턴은 화면과 비지니스 로직을 분리해서 작업하기 때문에 __확장성이 뛰어나고__, 표준화된 코드를 사용하여 공동작업이 용이하고 __유지보수성이 좋다.__\r\n\r\n# 스프링 MVC\r\n스프링 프레임워크는 자바 언어 기반의 프레임워크 이지만 이중 __웹 애플리케이션을 개발__ 할 때 사용할 수 있는 Servlet 기반의 WEB 개발을 위한 MVC 프레임워크를 제공하여  Model2 Architecture, Front Controller Pattern을 프레임워크 차원에서 제공한다. 스프링 MVC 프레임워크는 스프링을 기반으로 하여 스프링에서 제공하는 DI나 AOP 기능들과 함께 웹 MVC 개발하기 용이하게 해준다.\r\n\r\n<h5>스프링 MVC 구조</h5>\r\n<img src=\"https://user-images.githubusercontent.com/63226023/220362426-46d6197a-2eeb-4dbc-8be9-cd61c5c0980f.png\">\r\n\r\n<h5>요청 순서</h5>\r\n\r\n1. 클라이언트가 HTTP 요청을 서버에 보내면 DispatcherServlet이 요청을 받는다.\r\n2. HandlerMapping이 클라이언트가 요청한 URL과 매핑된 Controller를 찾는다.\r\n3. 해당 Controller가 요청을 처리하고 Model을 반환한다.\r\n4. ViewResolver가 Controller에서 반환한 논리적인 View 이름을 물리적인 View 파일 경로로 변환한다.\r\n5. View가 생성되고 처리되면 DispatcherServlet은 처리된 응답을 클라이언트에 보낸다.\r\n\r\n## 구성 요소\r\n- <h5>DispatcherServlet (Front Controller)</h5>\r\n    - 모든 클라이언트의 요청을 전달 받는다.\r\n    - Controller에게 클라이언트 요청을 전달하고, Controller가 리턴한 결과값을 View에게 전달하여 알맞은 응답을 생성한다.\r\n- <h5>HandlerMapping</h5>\r\n    - 클라이언트의 요청 URL을 어떤 Controller가 처리할지를 결정한다.\r\n    - URL과 요청 정보를 기준으로 어떤 핸들러 객체를 사용할지 결정하는 객체이며, DispatcherServlet은 하나 이상의 핸들러 매핑을 가질 수 있다.\r\n- <h5>Controller</h5>\r\n    - 클라이언트의 요청을 처리한 뒤, Model을 호출한 후 그 결과를 DispatcherServlet에 반환한다.\r\n- <h5>ModelAndView</h5>\r\n    - Controller가 처리한 데이터 및 화면에 대한 정보를 보유한 객체이다.\r\n- <h5>ViewResolver</h5>\r\n    - Controller가 반환한 이름을 기반으로 Controller의 처리 결과를 보여줄 View를 결정한다.\r\n- <h5>View</h5>\r\n    - Controller의 처리결과를 보여줄 화면을 생성한다.\r\n\r\n- - -\r\n# 스프링 Web MVC 구현\r\n- 스프링 MVC를 이용한 Application 구현의 순서는 다음과 같다.\r\n    - `web.xml` 에 DispatcherServlet과 스프링 설정파일을 등록한다.\r\n    - 설정 파일에 HandlerMapping을 설정한다.\r\n    - Controller 구현 및 `servlet-context.xml`에 등록한다.\r\n    - Controller와 View(JSP)의 연결을 위해 `View Resolver`를 설정해 준다.\r\n    - 클라이언트가 볼 View(JSP) 코드를 작성한다.\r\n\r\n## 스프링 MVC 프로젝트 생성해보기\r\n스프링 STS를 통하여 `Spring Legacy Project` 의 템플릿에 있는 `Spring MVC Project`를 생성하면 다음과 같은 프로젝트 구조를 볼 수 있다. \r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/220368311-15d90709-6e23-4dd2-a51d-7d0dd8469bb9.png\">\r\n\r\n## web.xml\r\n기본적인 `web.xml` 파일의 전체 구성은 다음과 같다.\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<web-app>\r\n\r\n    <!-- 스프링에서 사용할 객체(빈)들을 등록한 최상위 xml -->\r\n    <context-param>\r\n      <param-name>contextConfigLocation</param-name>\r\n      <param-value>/WEB-INF/spring/root-context.xml</param-value>\r\n    </context-param>\r\n\r\n    <listener>\r\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\r\n    </listener>\r\n\r\n    <servlet>\r\n        <!-- 서블릿의 이름을 appServlet으로 지정하고 DispatcherServlet 로 정의한다-->\r\n        <servlet-name>appServlet</servlet-name>\r\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\r\n        <!-- 위의 DispatcherServlet이 알아야하는 환경설정들이 있는 servlet-context.xml의 위치를 알려준다. -->\r\n        <init-param>\r\n            <param-name>contextConfigLocation</param-name>\r\n            <param-value>/WEB-INF/spring/appServlet/servlet-context.xml</param-value>\r\n        </init-param>\r\n        <load-on-startup>1</load-on-startup>\r\n    </servlet>\r\n\r\n  <!-- / 로 들어오는 요청은 appServlet 라는 이름의 servlet 이 처리한다 -> 위에서의 DispatcherServlet-->\r\n  <servlet-mapping>\r\n    <servlet-name>appServlet</servlet-name>\r\n    <url-pattern>/</url-pattern>\r\n  </servlet-mapping>\r\n</web-app>\r\n```\r\n\r\n### Root Context\r\n```xml\r\n<!-- 스프링에서 사용할 객체(빈)들을 등록한 최상위 xml -->\r\n<context-param>\r\n    <param-name>contextConfigLocation</param-name>\r\n    <param-value>/WEB-INF/spring/root-context.xml</param-value>\r\n</context-param>\r\n\r\n<listener>\r\n    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\r\n</listener>\r\n```\r\n먼저 Context 파일들을 로드하기 위해 ContextLoaderListener를 설정한다. 리스너가 설정이 되면 해당하는 `<context-param>`으로 표현된 `/WEB-INF/spring/root-context.xml` 파일을 읽어서 공통적으로 사용되는 최상위 Context를 생성한다.\r\n\r\n이외에 다른 Context 파일들을 최상위 애플리케이션 Context로 로드하기 위해서는 `<param-value>` 태그 안에 추가하면 된다.\r\n\r\n### DispatcherServlet\r\n```xml\r\n<servlet>\r\n    <!-- 서블릿의 이름을 appServlet으로 지정하고 DispatcherServlet 로 정의한다-->\r\n    <servlet-name>appServlet</servlet-name>\r\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\r\n    <!-- 위의 DispatcherServlet이 알아야하는 환경설정들이 있는 servlet-context.xml의 위치를 알려준다. -->\r\n    <init-param>\r\n        <param-name>contextConfigLocation</param-name>\r\n        <param-value>/WEB-INF/spring/appServlet/servlet-context.xml</param-value>\r\n    </init-param>\r\n    <load-on-startup>1</load-on-startup>\r\n</servlet>\r\n\r\n<!-- / 로 들어오는 요청은 appServlet 라는 이름의 servlet 이 처리한다 -> 위에서의 DispatcherServlet-->\r\n<servlet-mapping>\r\n    <servlet-name>appServlet</servlet-name>\r\n    <url-pattern>/</url-pattern>\r\n</servlet-mapping>\r\n```\r\n이후에는 `DispatcherServlet`을 설정을 해주어야 한다. `<init-param>` 을 성정 하지 않으면 기본적으로 `<servlet-name>-servlet.xml` 파일에서 ApplicationContext의 정보를 로드하게 된다.\r\n\r\n스프링 컨테이너는 설정파일의 내용을 읽고 ApplicationContext 객체를 생성하게 된다. Servlet이므로 1개 이상의 DispatcherServlet을 설정이 가능하고, `<url-pattern>` 에서 `/`로 설정하여 __/book__, __/list__ 와 같은 요청이 들어오면 __appServlet__ 이 요청을 처리하게 된다.\r\n\r\n### servlet-context.xml\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans:beans xmlns=\"http://www.springframework.org/schema/mvc\"\r\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n\txmlns:beans=\"http://www.springframework.org/schema/beans\"\r\n\txmlns:context=\"http://www.springframework.org/schema/context\"\r\n\txsi:schemaLocation=\"http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\r\n\t\thttp://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\r\n\t\thttp://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\">\r\n\r\n\t<!-- DispatcherServlet Context: defines this servlet's request-processing infrastructure -->\r\n\t\r\n\t<!-- Enables the Spring MVC @Controller programming model -->\r\n\t<annotation-driven />\r\n\r\n\t<!-- Handles HTTP GET requests for /resources/** by efficiently serving up static resources in the ${webappRoot}/resources directory -->\r\n\t<resources mapping=\"/resources/**\" location=\"/resources/\" />\r\n\r\n\t<!-- Resolves views selected for rendering by @Controllers to .jsp resources in the /WEB-INF/views directory -->\r\n\t<beans:bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\r\n\t\t<beans:property name=\"prefix\" value=\"/WEB-INF/views/\" />\r\n\t\t<beans:property name=\"suffix\" value=\".jsp\" />\r\n\t</beans:bean>\r\n\t\r\n</beans:beans>\r\n```\r\n`servlet-context.xml` 파일을 보게되면 `ViewResolver` 가 설정되어 있는 것을 볼 수 있다. 이로 인하여 ViewResolver에게  문자열 __\"book\"__ 이 전달 된다고 가정하면 prefix의 경로 `/WEB-INF/views/`를 앞에 더하고 suffix `.jsp` 를 통하여 __/WEB-INF/views/book.jsp__ 파일을 보여 주게 된다.\r\n\r\n<p class=\"notice--info\">📍따라서 이 경로에 해당하는 파일이 있는지 확인해야한다</p>\r\n\r\n## root-servlet vs servlet-context\r\n설정파일을 보게되면 root-servlet과 servlet-context 두곳에서 빈에 대한 설정을 하는 것을 볼 수 있다. \r\n\r\n여기서 __ApplicationContext는 ContextLoaderListener 클래스__ 에 의해 만들어지고, __WebApplicationContext는 DispatcherServlet 클래스__ 에 의해 만들어 진다. 해당 Context들의 관계는 다음과 같다.\r\n\r\n<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/220616153-acc474b3-2554-466a-a725-2c2e37ba2488.png\" width=\"50%\"></p>\r\n\r\n> __ApplicationContext__\r\n>   - 최상위 컨텍스트로 `root-context`에서 등록되는 빈들은 모든 컨텍스트에서 사용이 가능하다. (공유 가능)\r\n>   - 따라서 서로 다른 서블릿 컨텍스트에서 공유해야 하는 빈들을 등록해 놓고 사용이 가능하다.\r\n>   - __servlet-context 내 빈들은 사용이 불가능하다.__\r\n\r\n> __WebApplicationContext__\r\n>   - servlet-context에 등록되는 빈들은 해당 컨텍스트에서만 사용이 가능하다.\r\n>   - DispatcherServlet이 직접 사용하는 Controller를 포함한 웹 관련 빈들을 등록하는 데 사용한다.\r\n>   - __root-context 내 빈들을 사용이 가능하다.__\r\n\r\n- - -\r\n# @Controller\r\n클래스파일 내에 `@Controller` 어노테이션이 적용된 클래스는 클라이언트의 요청을 처리한다. \r\n```java\r\n@Controller\r\npublic class HomeController {\r\n\r\n    @RequestMapping(value = \"/test\", method = RequestMethod.GET)\r\n    public String home(Locale locale, Model model) {\r\n        model.addAttribute(\"hello\", \"Hello Spring\");\r\n        return \"home\";\r\n    }\r\n\t\r\n}\r\n```\r\n`@Controller` 어노테이션은 스프링에서 관리해야할 빈 객체인 것을 알아야한다. 빈을 등록하기 위해서는 빈을 설정하는 방법과 자동 스캔을 통한 방법이 있다.\r\n```xml\r\n<!-- servlet-context.xml -->\r\n<beans:bean id=\"myController\" class=\"com.spring.mvc.controller.HomeController\">\r\n    <!-- property에 서비스등을 사용하고 있다면 -->\r\n    <beans:property name=\"myService\" ref=\"MyService\">\r\n    ...\r\n</beans:bean>\r\n<!-- 자동 스캔을 통하여 해당 패키지 아래에 있는 component들을 모두 등록한다.-->\r\n<context:component-scan base-package=\"com.spring.mvc\" />\r\n```\r\n위에서의 간단한 예시를 보게되면 RequestMapping의 `/test` 로 GET 요청이 들어오면 view에서 사용할 model에 `\"hello\"`의 이름에 __Hello Spring__ 문자열이 담겨 `home` 이라는 이름의 View를 반환한다.\r\n\r\n`home`은 위에서 보았던 __ViewResolver__ 가 경로에 맞는 __home.jsp__ 파일을 찾아 보여주게 된다.\r\n\r\n```jsp\r\n<html>\r\n<head>\r\n    <title>Home</title>\r\n</head>\r\n<body>\r\n<h1> Message: ${hello}. </h1>\r\n</body>\r\n</html>\r\n```\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/220625753-87adb565-52a7-4f9b-ac39-0fa903dc7958.png\">\r\n\r\n## @RequestMapping\r\n클래스타입과 메소드에 설정이 가능하며 __요청 URL mapping 정보를 설정할 때 사용__ 할 수 있으며 HTTP 메소드에 따라 서로 다른 메소드를 mapping 할 수 있다.\r\n\r\n```java\r\n@RequestMapping(value = \"/test\", method = RequestMethod.GET)\r\n@RequestMapping(value = \"/test\", method = RequestMethod.POST)\r\n---\r\n```\r\n> 이외에도 컨트롤러 메소드 parameter로 다양한 Object를 받을 수 있다.\r\n\r\n| Parameter Type                                           | 설명                                                                                                                                         |\r\n| -------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| HttpServletRequest<br>HttpServletResponse<br>HttpSession | 필요시 Servlet API를 사용할 수 있다.                                                                                                         |\r\n| @PathVariable                                            | URI 템플릿 변수에 접근 할 때 사용한다.                                                                                                       |\r\n| @RequestParam                                            | HTTP 요청 파라미터를 매핑한다.                                                                                                               |\r\n| @RequestHeader                                           | HTTP 요청 헤더를 매핑한다.                                                                                                                   |\r\n| @CookieValue                                             | HTTP 쿠키를 매핑한다.                                                                                                                        |\r\n| @RequestBody                                             | HTTP 요청의 body 내용에 접근할 때 사용한다.                                                                                                  |\r\n| Map, Model, ModelMap                                     | View에 전달한 model data를 설정할 때 사용 (예시에선 Model 사용)                                                                              |\r\n| DTO                                                      | HTTP 요청 parameter를 저장한 객체이다.<br>기본적으론 클래스 이름을 모델명으로 사용한다.<br>@ModelAttribute 설정으로 모델명을 설정할 수 있다. |\r\n\r\n> 반환하는 타입또한 다양하게 줄 수 있다.\r\n\r\n| Return Type   | 설명                                                                                                                                                                                                           |\r\n| ------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| ModelAndView  | Model 정보 및 View 정보를 담고 있는 ModelAndView 객체이다.                                                                                                                                                     |\r\n| Model, Map    | View에 전달할 객체 정보를 담고 있는 Model/Map 객체이다.<br>이때 View 이름은 요청 URL로부터 결정된다.(RequestToViewNameTranslator)                                                                              |\r\n| String        | View의 이름을 반환한다.                                                                                                                                                                                        |\r\n| void          | Method가 ServletResponse나 HttpServletResponse 타입의 parameter를 갖는 경우 method가 직접 응답을 처리한다고 가정한다. 그렇지 않을 경우 요청 URL로부터 결정된 View를 보여준다.<br>(RequestToViewNameTranslator) |\r\n| @ResponseBody | Method에서 @ResponseBody 어노테이션이 적용된 경우, 반환 객체를 HTTP 응답으로 전송한다.<br>HttpMessageConverter를 이용해서 객체를 HTTP 응답 스트림으로 변환한다.                                                |\r\n\r\n\r\n- - -\r\n# References \r\n- [https://kingofbackend.tistory.com/78](https://kingofbackend.tistory.com/78)"},{"excerpt":"IoC(제어의 역전) Dependency Injection 에서 보았던 자바에서의 객체 간의 결합도가 강하게 되면 클래스와 결합된 다른 클래스도 같이 유지보수 되어야 할 가능성이 높아지게 된다. IoC(제어의 역전)은 이름과 같이 제어하는 주체가 바뀌었다는 의미로 프로그램의 제어 흐름을 개발자가 제어권을 갖지 않고 외부에서 결정 하는 것을 말한다. 이러한…","fields":{"slug":"/spring-ioc/"},"frontmatter":{"date":"February 19, 2023","title":"스프링 IoC와 컨테이너 알아보기","tags":["Java","Spring"]},"rawMarkdownBody":"# IoC(제어의 역전)\r\n[Dependency Injection](https://ppeper.github.io/cs/dependency-Injection/) 에서 보았던 자바에서의 객체 간의 결합도가 강하게 되면 __클래스와 결합된 다른 클래스도 같이 유지보수__ 되어야 할 가능성이 높아지게 된다.\r\n\r\nIoC(제어의 역전)은 이름과 같이 제어하는 주체가 바뀌었다는 의미로 __프로그램의 제어 흐름을 개발자가 제어권을 갖지 않고 외부에서 결정__ 하는 것을 말한다.\r\n\r\n이러한 IoC의 구현 방법 중 하나가 의존성 주입(Dependency Injection)으로 객체에서 필요로 하는 다른 객체를 외부에서 주입 받아 사용하게 되어 객체간의 결합도를 낮추고 유연성과 재사용성을 높일 수 있다.\r\n- - -\r\n# 스프링 컨테이너\r\n`컨테이너`는 객체의 생성, 사용, 소멸에 해당하는 라이프사이클을 담당하여 이러한 라이프사이클을 기본으로 애플리케이션의 사용에 필요한 주요 기능을 제공한다.\r\n\r\n스프링에서는 자바 객체를 `빈(Bean)`이라고 불리며 기존의 개발자가 객체의 생성, 사용, 소멸에 대한 것을 직접 해주었다면 Ioc, DI의 개념이 들어간 __스프링 컨테이너가 이 역할을 대신해 주며, 객체들 간의 의존 관계를 스프링 컨테이너가 런타임 과정에서 결정해 준다.__\r\n\r\n## 스프링 컨테이너 종류\r\n스프링 컨테이너에는 `BeanFactory` 와 `ApplicationContext` 가 있다.\r\n\r\n### BeanFactory vs ApplicationContext\r\n`BeanFactory`는 빈을 등록, 생성, 조회, 반환하는 기능을 담당하고 `getBean()` 메소드를 통하여 빈을 인스턴스화 할 수 있다.\r\n\r\n`ApplicationContext`는 BeanFactory를 확장한 인테페이스로 IoC 컨테이너로 빈을 동록하고 관리하는 기본적인 기능들은 BeanFactory와 동일하다.\r\n\r\n둘의 차이점은 __BeanFactory는 빈을 사용할 때(getBean() 호출)마다 빈을 생성__ 하지만 __ApplicationContext는 Context를 초기화 할 시점에 빈을 미리 로드하고 캐시에 저장__ 하기 때문에, BeanFactory보다 빠른 애플리케이션 시작 시간을 제공할 수 있다.\r\n\r\n또한 ApplicationContext는 BeanFactory의 모든 기능 이외 다국어 처리, 이벤트 발행 및 구독, AOP(Aspect-Oriented Programming) 등의 기능을 지원한다.\r\n- - -\r\n# 스프링에서 Bean 의존관계\r\n스프링에서 자바 객체(Bean)을 사용하기 위한 방법으로는 크게 3가지가 있다.\r\n1. XML로 빈 설정\r\n2. Annotation으로 빈 설정\r\n3. Java 코드로 빈 설정\r\n\r\n## 1. XML 문서이용\r\n- Application에서 사용할 Spring 자원들을 설정하는 파일이다.\r\n- 스프링 컨테이너는 설정파일에 설정된 내용들을 읽어 Application에서 필요한 기능들을 제공한다.\r\n- Root tag는 `<beans>`\r\n\r\n빈 객체 생성 및 주입의 기본 설정은 아래와 같다.\r\n> 주입할 객체를 설정파일에 설정\r\n> - &lt;bean&gt; : 스프링 컨테이너가 관리할 빈 객체를 설정한다.\r\n> 기본속성\r\n> - name : 주입 받을 곳에서 호출할 이름을 설정한다.\r\n> - id : 주입 받을 곳에서 호출할 이름을 설정한다 (유일 값이어야한다.)\r\n\r\n자바 객체파일에서 필요한 주입 받을 dataSource\r\n```java\r\npublic class Some1DaoImpl implements Some1Dao {\r\n    \r\n    private DataSource dataSource;\r\n\r\n    // set을 통한 주입\r\n    public void setDataSource(DataSource dataSource) {\r\n        this.dataSource = dataSource;\r\n    }\r\n}\r\n\r\npublic class Some2DaoImpl implements Some2Dao {\r\n    \r\n    private DataSource dataSource;\r\n\r\n    // set을 통한 주입\r\n    public void Some2DaoImpl(DataSource dataSource) {\r\n        this.dataSource = dataSource;\r\n    }\r\n}\r\n```\r\n\r\nbeans 설정 파일에 `<bean>` 들을 등록\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n\t<bean id=\"ds\" class=\"org.springframework.jdbc.datasource.SimpleDriverDataSource\">\r\n\t\t<property name=\"driverClass\" value=\"com.mysql.cj.jdbc.Driver\"></property>\r\n\t\t<property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3306/mydb\"></property>\r\n\t\t<property name=\"username\" value=\"id\"></property>\r\n\t\t<property name=\"password\" value=\"pw\"></property>\r\n\t</bean>\r\n\r\n        <!-- 라이프 사이클을 Spring이 대신해준다. -->\r\n\t<bean id=\"dao1\" class=\"패키지위치\">\r\n\t\t<!-- 위에서 만든 id ds를 setDataSource를 호출하라는 의미 -->\r\n\t\t<property name=\"dataSource\" ref=\"ds\"></property>\r\n\t</bean>\r\n\t\r\n\t<!-- 라이프 사이클을 Spring이 대신해준다. -->\r\n\t<bean id=\"dao2\" class=\"패키지위치\">\r\n\t\t<!-- 생성자를 호출 -> 이름은 같을것으로 ref만 설정 -->\r\n\t\t<constructor-arg ref=\"ds\"></constructor-arg>\r\n\t</bean>\r\n</beans>\r\n```\r\n`<property>`, `<constructor-arg>` tag등을 통해여 속성, 생성자를 통한 주입을 해 줄 수 있다. 해당하는 빈 객체들은 __ClassPathXmlApplicationContext__ 로 context를 생성하여 설정한 빈 들을 주입 받을 수 있다.\r\n\r\n```java\r\nimport java.io.IOException;\r\n\r\npublic class GuestBookMain {\r\n\r\n    public static void main(String[] args) throws IOException {\r\n        \r\n        ApplicationContext context = new ClassPathXmlApplicationContext(xml이 있는 패키지 + xml이름.xml);\r\n        \r\n        // bean 설정파일의 id(유일 값)으로 지정한 이름으로 주입\r\n        Some1Dao some1Dao = context.getBean(\"dao1\", Some1DaoImpl.class);\r\n        Some2Dao some1Dao = context.getBean(\"dao2\", Some1DaoImpl.class);\r\n    }\r\n}\r\n```\r\n## 2. Annotation으로 빈 설정\r\n스프링에 프레임워크에서는 __Stereotype annotation__ 을 통하여 컴포넌트 스캔을 할 수 있다. 기본적으로 제공하는 어노테이션은 `@Component`, `@Controller`, `@Service`, `@Repository` 이 있다.\r\n\r\n| StereoType   | 적용 대상                                                  |\r\n| ------------ | ---------------------------------------------------------- |\r\n| @Repository | Data Access Layer의 DAO 또는 Repository 클래스에 사용한다. |\r\n| @Service     | Service Layer 클래스에 사용한다.                           |\r\n| @Controller  | Presentation Layer의 MVC에서 컨트롤러 역할을 수행하는 클래스에 사용한다. |\r\n| @Component   | 위의 Layer 구분하기 어려운 일반적인 경우에 사용한다.       |\r\n\r\n```java\r\n@Target({ElementType.TYPE})\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Documented\r\n@Component\r\npublic @interface Repository {\r\n\r\n\t/**\r\n\t * The value may indicate a suggestion for a logical component name,\r\n\t * to be turned into a Spring bean in case of an autodetected component.\r\n\t * @return the suggested component name, if any (or empty String otherwise)\r\n\t */\r\n\t@AliasFor(annotation = Component.class)\r\n\tString value() default \"\";\r\n\r\n}\r\n```\r\n위의 어노테이션들은 모두 __@Component__ 와 연관 되어 해당하는 어노테이션을 클래스에 명시하면 스프링 컨테이너에서 __컴포넌트 스캔을 통하여 해당 클래스의 객체(Bean)들을 관리해 준다.__\r\n\r\n## 빈 의존 관계 설정\r\n스프링의 빈을 명시해 주었으면 관리되고 있는 클래스간의 의존 관계를 연결해 주어야 한다. 스프링에서 빈 의존 관계를 위한 어노테이션을 제공하여  멤버 변수에 직접 정의하는 경우 __어노테이션을 통하여 setter method를 만들지 않아도 된다.__\r\n\r\n| Annotation | 설명                                                                                                                                                  |\r\n| ---------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| @Resource  | 멤버변수, setter method에서 사용이 가능하며 __타입__ 에 맞춰서 연결된다.                                                                              |\r\n| @Autowired | 스프링 2.5부터 지원하며 __Spring에서는 사용가능하다.__ <br> 멤버변수, setter, constructor, 일반 method에 사용이 가능하며 __타입__ 에 맞춰서 연결된다. |\r\n| @Inject    | 스프링 3.0부터 지원하며 Framework에 종속적이지 않다. <br> `@Autowired`와 마찬지로 사용이 가능하며 __이름__ 으로 연결된다.                             |\r\n\r\n스프링 빈 설정을 어노테이션으로 할 경우 반드시 `component-scan`을 설정 해야 한다.\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n\txmlns:context=\"http://www.springframework.org/schema/context\"\r\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\r\n\t\thttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\">\r\n\r\n        <!-- 스캔할 어노테이션이 있는 패키지 -->\r\n\t<context:component-scan base-package=\"패키지 경로\"/>\r\n</beans>\r\n```\r\n## 3. Java 코드로 설정\r\n컴포넌트 어노테이션을 사용하지 않고 직접 빈을 등록할 클래스들을 정의하기 위해서는  자바 클래스를 `@Configuration` 으로 설정파일인것을 명시해주어야 한다. 또한 `@ComponentScan(basePackages = {})` 를 통하여 component 스캔 할 패키지를 설정해 줄 수 있다. 자바 코드에서 관리될 빈 객체는 `@Bean` 어노테이션을 통하여 스프링이 관리되어야 할 클래스임을 알 수 있게 해준다.\r\n> @Configuration\r\n> - 설정파일인것을 명시한다.\r\n>\r\n> @ComponentScan(basePackages = {})\r\n> - 컴포넌트 스캔할 패키지를 설정한다.\r\n\r\n```java\r\nimport javax.sql.DataSource;\r\n\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.ComponentScan;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.jdbc.datasource.SimpleDriverDataSource;\r\n\r\n@Configuration\r\n@ComponentScan(basePackages = {\"패키지 경로\"})\r\npublic class ApplicationConfig {\r\n    \r\n    @Bean\r\n    public DataSource dataSource() {\r\n        SimpleDriverDataSource ds = new SimpleDriverDataSource();\r\n        ds.setDriverClass(com.mysql.cj.jdbc.Driver.class);\r\n        ds.setUrl(\"jdbc:mysql://127.0.0.1:3306/mydb\");\r\n        ds.setUsername(\"id\");\r\n        ds.setPassword(\"pw\");\r\n        return ds;\r\n    }\r\n}\r\n```\r\n\r\n"},{"excerpt":"스프링 등장 배경 스프링 프레임워크는 자바 플랫폼을 위한 오픈 소스 애플리케이션 프레임워크이다. 스프링이 등장하기 이전에는 EJB (Enterprise JavaBeans) 를 포함한 J2EE(Java 2 Platform, Enterprise Edition) 기반의 애플리케이션 개발이 주류였다. 하지만 EJB의 불편한 API와 높은 부하, 복잡한 구성 등의…","fields":{"slug":"/spring-basic/"},"frontmatter":{"date":"February 18, 2023","title":"스프링 프레임워크의 등장","tags":["Java","Spring"]},"rawMarkdownBody":"# 스프링 등장 배경\r\n<img src=\"https://user-images.githubusercontent.com/63226023/219701751-ef422546-2a51-4ffa-ad98-b67e761e66ac.png\">\r\n\r\n스프링 프레임워크는 자바 플랫폼을 위한 오픈 소스 애플리케이션 프레임워크이다. 스프링이 등장하기 이전에는 __EJB (Enterprise JavaBeans)__ 를 포함한 __J2EE(Java 2 Platform, Enterprise Edition)__ 기반의 애플리케이션 개발이 주류였다. 하지만 EJB의 불편한 API와 높은 부하, 복잡한 구성 등의 문제점이 있어 __로드 존슨은 경량화된 프레임워크를 개발__ 하면서 이러한 문제점을 해결하고자 하였다.\r\n\r\n2002년 로드 존슨이 출판한 책 \"Expert One-on-One J2EE Design and Development\" 에서 처음 EJB를 사용하지 않고 엔터프라이즈 애플리케이션을 개발하는 방법을 소개하였다. (지금 스프링의 모태)\r\n\r\n이후 AOP, DI와 같은 새로운 프로그래밍 방법론으로 가능해지고 POJO로 선언적은 프로그래밍 모델이 가능해 졌다.\r\n\r\n> POJO (Plain Old Java Object)\r\n> - 특정 프레임워크나 기술에 의존적이지 않은 자바 객체이다.\r\n> - 특정 기술에 의존적이지 않아 생산성, 이식성이 향상된다.\r\n> - Plain : component interface를 상속되지 않는 특징 (특정 framework에 종속되지 않는다)\r\n> - Old : EJB 이전의 java class를 의미한다.\r\n\r\n# 스프링의 특징\r\n## 경량 컨테이너\r\n- 스프링은 자바객체를 담고 있는 컨테이너이다.\r\n- 스프링 컨테이너에서는 자바 객체 생성과 소멸과 같은 LifeCycle을 관리한다 -> `Bean`으로 불린다.\r\n\r\n## DI (Dependency Injection) 패턴\r\n- 스프링은 설정 파일, 어노테이션을 통해서 객채간의 의존 관계를 설정할 수 있다.\r\n- 따라서, 객체는 의존하고 있는 객체를 직접 생성하거나 검색하지 않아도 됨\r\n\r\n- [Dependency Injection](https://ppeper.github.io/cs/dependency-Injection/)\r\n\r\n## AOP (Aspect Oriented Programming) 지원\r\n`관점`을 기준으로 프로그래밍하는 기법으로 이는 문제를 해결하기 위한 __핵심 관심사항__ 과 __전체에 적용되는 공통 관심사항__ 을 기준으로 프로그래밍 함으로서 공통 모듈을 여러 코드에 쉽게 적용할 수 있도록 한다.\r\n\r\n## POJO 지원\r\n- 특정 인터페이스를 구현하거나 또는 클래스를 상속하지 않는 일반 자바 객체 지원.\r\n- 스프링 컨테이너에 저장되는 자바객체는 특정한 인터페이스를 구현 하거나, 클래스 상속 없이도 사용이 가능하다.\r\n\r\n## IoC (Inversion of Control - 제어의 반전) \r\n기존의 자바의 객체 생성 및 의존관계에 있어 모든 제어권은 개발자에게 있었다.\r\n\r\nIoC는 __제어의 반전(역전)으로 불리며 말 그대로 이젠 개발자가 위와 같은 제어권을 갖지 않고 외부에서 결정__ 되는 것을 말한다. 이로 인하여 객체의 의존성을 역전시켜 객체간의 결합도를 줄이고 유연한 코드 작성이 가능하게 해준다.\r\n\r\n스프링에서도 __객체에 대한 생성과 생명주기를 관리할 수 있는 기능__ 을 제공하고 있는데 이런 이유로 `Spring Container` 또는 `IoC Container`라고 부르기도 한다. \r\n\r\n위에서 `Bean`이라고 불리는 것이 Spring (IoC) 컨테이너가 관리는 자바 객체를 의미하며, 스프링이 __모든 의존성 객체(Bean)들을 만들어 주고 필요한곳에 주입__ 시켜 준다.\r\n- - -\r\n\r\n\r\n"},{"excerpt":"Servlet 자바 서블릿 은 스프링 MVC 아키텍처가 나오기 전 사용하였다. \n자바 서블릿은 자바를 사용하여 웹페이지를 동적으로 생성하는 서버측 프로그램을 말한다. 자바 서블릿은 웹 서버의 성능을 향상 하기 위해 사용되는 자바 클래스의 일종으로. WAS 서버를 쉽게 구축할 수 있도록 도와준다.  즉 servlet은 정적인 리소스가 아닌 클라이언트로 부터…","fields":{"slug":"/servlet/"},"frontmatter":{"date":"February 15, 2023","title":"Spring 이전에 자바 Servlet 알아보기","tags":["Java","Servlet"]},"rawMarkdownBody":"# Servlet\r\n__자바 서블릿__ 은 스프링 MVC 아키텍처가 나오기 전 사용하였다. \r\n자바 서블릿은 자바를 사용하여 웹페이지를 동적으로 생성하는 서버측 프로그램을 말한다.\r\n\r\n자바 서블릿은 웹 서버의 성능을 향상 하기 위해 사용되는 자바 클래스의 일종으로. WAS 서버를 쉽게 구축할 수 있도록 도와준다. \r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/218739424-acd75b51-9c5c-4aae-8c80-b7c93e92acba.png\">\r\n> WAS (Web Application Server)이란\r\n>\r\n> -> WAS는 웹 애플리케이션을 통하여 필요한 기능을 수행하고 그 결과를 웹 서버에 전달해 준다.\r\n\r\n즉 servlet은 정적인 리소스가 아닌 __클라이언트로 부터 요청을 받고 이에 대한 결과값을 처리하는__ 역할을 수행해 주는 자바 프로그램이다.\r\n\r\n\r\n# Servlet 사용하기\r\n자바 Servlet을 만들게 되면 `@WebServlet` 어노테이션으로 간단하게 url을 지정하고 이름 또한 지정해 줄 수 있다. Servlet은 `HttpServlet` 클래스를 상속 받아서 `service()`, `doGet()`, `doPost()` 메소드들을 오바라이딩 하여 request, response에 대한 클래스를 가져와 쉽게 HTTP 통신을 지원한다.\r\n\r\n```java\r\nimport java.io.IOException;\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.annotation.WebServlet;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\n\r\n@WebServlet(name = \"hello\", urlPatterns = { \"/hello\" })\r\npublic class HelloServlet extends HttpServlet {\r\n\tprivate static final long serialVersionUID = 1L;\r\n\r\n\t@Override\r\n\tprotected void service(HttpServletRequest req, HttpServletResponse resp) \r\n\t\tthrows ServletException, IOException {\r\n\t\tsuper.service(req, resp);\r\n\t}\r\n\r\n\t@Override\r\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response) \r\n\t\tthrows ServletException, IOException {\r\n\t\t// TODO Auto-generated method stub\r\n\t\tresponse.getWriter().append(\"Served at: \").append(request.getContextPath());\r\n\t}\r\n\r\n\t@Override\r\n\tprotected void doPost(HttpServletRequest request, HttpServletResponse response) \r\n\t\tthrows ServletException, IOException {\r\n\t\t// TODO Auto-generated method stub\r\n\t\tdoGet(request, response);\r\n\t}\r\n}\r\n```\r\n\r\n주요 메소드를 살펴보면 다음과 같다.\r\n> 1. init()\r\n> - Servlet이 메모리에 로드 될 때 한번 호출된다 (코드가 수정된다면 다시 호출)\r\n> 2. doGet()\r\n> - GET 방식으로 data전송 시 호출된다.\r\n> 3. doPost()\r\n> - POST 방식으로 data전송 시 호출된다.\r\n> 4. service()\r\n> - 모든 요청은 service()를 통하여 doXXX()관련 메소드로 이동한다.\r\n> 5. destroy()\r\n> - Servlet이 메모레에서 해제되면 호출된다.\r\n\r\n## Hello 요청\r\nServlet의 doGet() 메소드를 이용하면 HTTP GET 요청을 처리하여 \"Hello\" 라는 메시지를 생성하고 HTML 형식으로 응답을 작성하여 전송할 수 있다.\r\n```java\r\npublic void doGet(HttpServletRequest request, HttpServletResponse response)\r\n\t\tthrows ServletException, IOException {\r\n\tresponse.setContentType(\"text/html\");\r\n\r\n\tPrintWriter out = response.getWriter();\r\n\tout.println(\"<html>\");\r\n\tout.println(\"<head><title>Hello World Servlet</title></head>\");\r\n\tout.println(\"<body>\");\r\n\tout.println(\"<h1>Hello</h1>\");\r\n\tout.println(\"</body></html>\");\r\n}\r\n```\r\nhtml 파일을 직접 생성하지 않고 이러한 자바 코드안에 지정하여 사용할 수 있지만 이는 굉장히 코드 작성시 불편함이 있다. 이러한 불편함을 해소 하기 위해 __JSP (Java Server Page)__ 가 나오게 되었다.\r\n\r\n# JSP\r\nServlet은 자바 코드안에 HTML이 있지만 JSP는 HTML 내에 자바 코드를 삽입하여 웹 서버에서 동적으로 웹 페이지를 생성하여 웹 브라우저에 돌려주는 언어이다.\r\n\r\n```jsp\r\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\r\n\tpageEncoding=\"UTF-8\"%>\r\n<%!\r\n\tString name;\r\n\r\n\tpublic void init() {\r\n\t\tname = \"저는 JSP 입니다\";\r\n\t}\r\n%>\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n<meta charset=\"UTF-8\">\r\n<title>Title</title>\r\n</head>\r\n<body>\r\n\t<%\r\n\t\tout.print(name);\r\n\t%>\r\n</body>\r\n</html>\r\n```\r\n\r\nJSP의 문법은 `<% %>` 에 대한 블록을 지정하여 내부에 자바 코드를 구현 할 수 있고 많은 문법들은 인터넷에 자료들을 쉽게 볼 찾아 볼 수 있다.\r\n\r\n이렇게 JSP와 함께 Web Application Architecture의 구성은 처음에는 model1의 구조로 사용이 되었다.\r\n\r\nmodel1 구조는 view와 logic을 JSP 페이지 하나에서 처리하는 구조로 HTML, 자바, 비지니스 로직, JDBC 연결코드 등 이 한 곳에 들어가 있어 굉장히 유지보수가 어려워진다.😨 \r\n\r\n이에 따라 __model2(MVC 패턴) 구조__ 가 나오게 되었다.\r\n\r\n# MVC 패턴\r\nmodel2의 구조는 모든 처리를 JSP가 아닌 `클라이언트의 요청에 대한 처리는 Servlet`이, `logic처리는 java class(Service, Dao..)`, `클라이언트에게 출력하는 response page(view)는 JSP`가 담당하여 개발한다.\r\n\r\nmodel2 구조를 흔히 MVC(Model, View, Controller) 패턴이라고 부르게 되는데 Servlet이 Controller의 역할을 맡고, JSP가 View로 사용되어 서로 Model에 대한 데이터를 참조하게 된다.\r\n```java\r\n@WebServlet(\"/test\")\r\npublic class SomeJspPage extends HttpServlet {\r\n\r\n    @Override\r\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\r\n\t\tthrows ServletException, IOException {\r\n        String path = \"/bookinfo.jsp\";\r\n        // 어떠한 book에 대한 model을 넘긴다고 하자\r\n        BookDto book = new BookDto(생성자 세팅)\r\n\r\n        // model에 book 데이터 전달\r\n        request.setAttribute(\"bookinfo\", book);\r\n\r\n        RequestDispatcher dispatcher = request.getRequestDispatcher(path);\r\n        dispatcher.forward(request, response);\r\n    }\r\n}\r\n```\r\n`RequestDispatcher` 클래스를 사용하여 요청을 JSP/Servlet 내에서 원하는 자원으로 요청을 넘기거나, 처리를 요청하고 결과를 얻어오는 기능을 수행해 주는 클래스이다. 위의 예시는 MVC 패턴으로 `forward()` 메소드를 통해여 model(bookinfo)과 함께 bookinfo.jsp로 이동하게 해준다. \r\n\r\n또한 요청을 받은 페이지에서는 request.getAttribute()로 해당하는 데이터를 가져와 동적으로 화면을 보여줄 수 있다.\r\n\r\n```jsp\r\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\r\n\tpageEncoding=\"UTF-8\" import=\"com.ssafy.move.BookDto\"%>\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n<%\r\n\tBookDto bookDto = (BookDto) request.getAttribute(\"bookinfo\");\r\n\tif (bookDto == null) {\r\n%>\r\n<script>\r\n\talert(\"Book 정보가 없습니다.\");\r\n</script>\r\n<%\r\n\t} else {\r\n%>\r\n\r\n<meta charset=\"UTF-8\">\r\n<title>책정보(book.jsp)</title>\r\n</head>\r\n<body>\r\n\t<div>\r\n\t\t<h3>\r\n\t\t\t[<%=bookDto.getBookName()%>] 정보\r\n\t\t</h3>\r\n\t\tISBN :\r\n\t\t<%=bookDto.getIsbn()%><br> 출판사 :\r\n\t\t<%=bookDto.getPublisher()%><br> 가격 :\r\n\t\t<%=bookDto.getPrice()%>원<br>\r\n\t</div>\r\n\t<%\r\n\t\t}\r\n\t%>\r\n</body>\r\n</html>\r\n```\r\n\r\n`dispatcher.forward()` 메소드 이외에 redirect의 메소드가 있는데 둘의 차이점은 다음과 같다.\r\n> forward()\r\n> - forward 메소드는 현재 서블릿에서 다른 서블릿/JSP 페이지로 요청을 전달 할 수 있다.\r\n> redirect()\r\n> - redirect 메소드는 새로운 요청을 생성하고, 새로운 URL로 이동을 하게된다. 따라서 클라이언트에서는 두 번의 요청이 발생하게 되고, 이에 따라 URL도 변경된다.\r\n> - redirect는 따라서 새로운 요청을 생성하므로, 기존의 요청 객체(bookinfo)에 저장된 데이터는 새로운 요청 객체에서 사용할 수 없다.\r\n\r\n"},{"excerpt":"다시 한번 마음을 잡고 기본을 쌓는 중에 객체 정렬에 대해서 다시 정리해 보았다. 최근 다시 공부를 하면서 내가 몰랐던 내용이나 애매했던 부분들을 잡아가면서 이번에는 객체 지향 언어에서의 클래스와 같은 객체 정렬에 대한 내용을 담아보려고 한다. 자바 Primitive 정렬 기본적으로  를 통하여 정렬이 가능하다 (기본은 오름차순이다.) Arrays.sor…","fields":{"slug":"/comparable-comparator/"},"frontmatter":{"date":"February 06, 2023","title":"자바에서의 Comparable, Comparator 정렬","tags":["Java","Sort"]},"rawMarkdownBody":"다시 한번 마음을 잡고 기본을 쌓는 중에 객체 정렬에 대해서 다시 정리해 보았다. 최근 다시 공부를 하면서 내가 몰랐던 내용이나 애매했던 부분들을 잡아가면서 이번에는 객체 지향 언어에서의 클래스와 같은 객체 정렬에 대한 내용을 담아보려고 한다.\r\n# 자바 Primitive 정렬\r\n- 기본적으로 `Arrays.sort()` 를 통하여 정렬이 가능하다 (기본은 오름차순이다.)\r\n\r\n```java\r\nint[] arr = {1, 28, 16, 25, 99, 44};\r\n\r\nArrays.sort(arr);\r\n\r\nSystem.out.println(Arrays.toString(arr)); \r\n// [1, 17, 25, 26, 44, 99, 303]\r\n```\r\n## Arrays.sort()\r\n- 배열의 기본형 타입은 모두 정렬이 가능하다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/216955538-498a4dd1-c748-452d-86ad-26293a2935f6.png\">\r\n\r\n- List 컬렉션의 경우 `Collections.sort()` 를 사용하여 정렬이 가능하다.\r\n\r\n## 내림차순 정렬\r\n내림차순으로 정렬하려면 `sort()`의 인자에 추가로 `Collections.reverseOrder()` 를 전달하면 된다.\r\n\r\n```java\r\nInteger[] arr = {1, 28, 16, 25, 99, 44};\r\n\r\nArrays.sort(arr, Collections.reverseOrder());\r\n\r\nSystem.out.println(Arrays.toString(arr));\r\n// [303, 99, 44, 26, 25, 17, 1]\r\n```\r\n> -> Collections.reversOrder()??\r\n>\r\n> 위에서의 인자로 전달된 친구는 사실 Comparator 객체이다. Comparator는 직접 구현해야 하지만, 내림차순은 자주 사용되어 Collections에서 기본적으로 제공해 주고 있는 것이다.\r\n\r\n- - -\r\n\r\n# Comparator vs Comparable\r\n- 객체를 비교할 수 있도록 만든다.\r\n- 기본형 타입의 경우 부등호로 비교가 가능하지만 객체의 경우는 불가능하다.\r\n\r\n## Comparator - java.lang\r\n- compare(T o1, T o2)를 구현해야 한다.\r\n- 두 매개변수 객체를 비교\r\n\r\n## Comparator - java.util\r\n- compareTo(T o) 를 구현해야 한다.\r\n- 자기 자신과 매개변수 객체를 비교\r\n\r\n> <h3>❗주의 할 점 </h3>\r\n> 객체에서 나이와 같은 정수형을 비교한다고 하였을때 예시와 같이 int형의 범위에 따른 underflow, overflow 를 조심해야한다!\r\n> 따라서 Primitive 값에 대한 비교를 하게 되었을때는 <,>,==의 대소비교를 통하는 것이 안전하다.\r\n\r\n## 차이점 비교\r\nComparator와 Comparable의 차이는 __`자기 자신`__ 과의 비교가 가능한가? 에서 있다. 이를 다시 생각해 보면 Comparable은 class 객체와 같이 정렬 기준을 정할 때 사용한다.\r\n\r\n```java\r\nclass Student implements Comparable<Student> {\r\n    String name;\r\n    int age;\r\n\r\n    public Student(String name, int age) {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n\r\n    @Override\r\n    public int compareTo(Student o) {\r\n        // 나이가 같을때\r\n        if (this.age == o.age) {\r\n            // 이름 순으로\r\n            return this.name.compareTo(o.name);\r\n        }\r\n        // 나이가 어린순으로\r\n        return this.age - o.age;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Student{\" +\r\n                \"name='\" + name + '\\'' +\r\n                \", age=\" + age +\r\n                '}';\r\n    }\r\n}\r\n// 정렬 기준이 정해짐\r\npublic class Main {\r\n\r\n    public static void main(String[] args) {\r\n        Student student1 = new Student(\"가\", 27);\r\n        Student student2 = new Student(\"나\", 26);\r\n        Student student3 = new Student(\"라\", 28);\r\n        Student student4 = new Student(\"다\", 28);\r\n        Student[] students = {student1, student2,student3, student4};\r\n        // 정렬 X\r\n        System.out.println(\"정렬 X\");\r\n        for (Student s: students) {\r\n            System.out.println(s);\r\n        }\r\n        System.out.println(\"-------------------\");\r\n        System.out.println(\"정렬 -> 나이가 어린순, 같으면 이름이 빠른순\");\r\n        Arrays.sort(students);\r\n        for (Student s: students) {\r\n            System.out.println(s);\r\n        }\r\n        System.out.println(\"-------------------\");\r\n    }\r\n}\r\n정렬 X\r\nStudent{name='가', age=27}\r\nStudent{name='나', age=26}\r\nStudent{name='라', age=28}\r\nStudent{name='다', age=28}\r\n-------------------\r\n정렬 -> 나이가 어린순, 같으면 이름이 빠른순\r\nStudent{name='나', age=26}\r\nStudent{name='가', age=27}\r\nStudent{name='다', age=28}\r\nStudent{name='라', age=28}\r\n-------------------\r\n```\r\n\r\n- Comparable을 상속받아 사용하면 해당하는 정렬 기준만 사용할 수 있지만 __기본 정렬 기준과 다르게 정렬__ 하고 싶을 때는 Comparator를 사용할 수 있다.\r\n\r\n```java\r\nclass Student {\r\n    String name;\r\n    int age;\r\n\r\n    public Student(String name, int age) {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Student{\" +\r\n                \"name='\" + name + '\\'' +\r\n                \", age=\" + age +\r\n                '}';\r\n    }\r\n}\r\npublic class Main {\r\n\r\n    public static void main(String[] args) {\r\n        Student student1 = new Student(\"가\", 27);\r\n        Student student2 = new Student(\"나\", 26);\r\n        Student student3 = new Student(\"라\", 28);\r\n        Student student4 = new Student(\"다\", 28);\r\n        Student[] students = {student1, student2,student3, student4};\r\n        // 정렬 X\r\n        System.out.println(\"정렬 X\");\r\n        for (Student s: students) {\r\n            System.out.println(s);\r\n        }\r\n        System.out.println(\"-------------------\");\r\n        System.out.println(\"정렬 -> 나이가 어린순\");\r\n        Arrays.sort(students, new Comparator<Student>() {\r\n            @Override\r\n            public int compare(Student o1, Student o2) {\r\n                return o1.age - o2.age;\r\n            }\r\n        });\r\n        for (Student s: students) {\r\n            System.out.println(s);\r\n        }\r\n        System.out.println(\"-------------------\");\r\n        System.out.println(\"정렬 -> 이름순\");\r\n        Arrays.sort(students, (o1, o2) -> o1.name.compareTo(o2.name));\r\n        System.out.println(\"-------------------\");\r\n        for (Student s: students) {\r\n            System.out.println(s);\r\n        }\r\n\r\n    }\r\n}\r\n정렬 X\r\nStudent{name='가', age=27}\r\nStudent{name='나', age=26}\r\nStudent{name='라', age=28}\r\nStudent{name='다', age=28}\r\n-------------------\r\n정렬 -> 나이가 어린순\r\nStudent{name='나', age=26}\r\nStudent{name='가', age=27}\r\nStudent{name='라', age=28}\r\nStudent{name='다', age=28}\r\n-------------------\r\n정렬 -> 이름순\r\n-------------------\r\nStudent{name='가', age=27}\r\nStudent{name='나', age=26}\r\nStudent{name='다', age=28}\r\nStudent{name='라', age=28}\r\n```\r\n\r\n## 람다식 표현\r\n\r\n```java\r\n// 람다식 사용 X\r\nArrays.sort(students, new Comparator<Student>() {\r\n      @Override\r\n      public int compare(Student o1, Student o2) {\r\n          return o1.age - o2.age;\r\n      }\r\n});\r\n// Comparator 객체 생성\r\nComparator<Student> comparator = new Comparator<Student>() {\r\n\t      @Override\r\n      public int compare(Student o1, Student o2) {\r\n          return o1.age - o2.age;\r\n      }\r\n}\r\nArrays.sort(students, comparator);\r\n// 람다식 사용\r\nArrays.sort(students, (o1, o2) -> o1.age - o2.age);\r\n// Comparator 제공 메소드\r\nArrays.sort(students, Comparator.comparingInt(o -> o.age));\r\n```"},{"excerpt":"들어가며 2022년은 곧 졸업하는 대학생의 입장에서 정말 빠르게 지나갔던 것 같다.    한해를 빠르게 달려오다 보니 이렇게 새해가 밝았고 목표를 다짐하기 전에 블로그를 시작한 2022년도 첫 회고를 나름대로 풀어가 보려고 한다.😁 2022에는?? 2022 상반기 안드로이드 개발자 컴공 2학년때인 2020년에는 스마트폰의 애플리케이션들을 많이 사용하면서 …","fields":{"slug":"/hello-2023/"},"frontmatter":{"date":"January 02, 2023","title":"2022 회고지만 새해가 밝은..?","tags":["Blog","Retrospect"]},"rawMarkdownBody":"<img src=\"https://user-images.githubusercontent.com/63226023/210177726-2dfd7af3-8a7d-4140-87f3-c29aa7cd8e39.png\">\r\n\r\n# 들어가며\r\n\r\n2022년은 곧 졸업하는 대학생의 입장에서 정말 빠르게 지나갔던 것 같다.   \r\n\r\n한해를 빠르게 달려오다 보니 이렇게 새해가 밝았고 목표를 다짐하기 전에 블로그를 시작한 2022년도 첫 회고를 나름대로 풀어가 보려고 한다.😁\r\n\r\n# 2022에는??\r\n## 2022 상반기\r\n### 안드로이드 개발자\r\n컴공 2학년때인 2020년에는 스마트폰의 애플리케이션들을 많이 사용하면서 동작과정이나 화면들의 구성이 신기하고 궁금하였었다.\r\n\r\n막연하게 해보고 싶다는 생각만 가지고 있는 와중 2021년에 팀원들과 [공개 SW 개발자 대회](https://www.oss.kr/dev_competition)라는 좋은 기회를 가지게 되었고 처음으로 안드로이드 개발을 경험할 수 있었다.\r\n\r\n프로젝트를 진행하면서 점점 안드로이드 개발을 하는 것에 생각했던 것 이상으로 흥미를 가지게 되었고 '안드로이드 개발자가 되야겠다!😀`라는 생각을 가지게 되었다.\r\n\r\n안드로이드 개발자가 되기 위해서는 모바일 이외 프론트엔드, 백앤드와 CS 지식들을 포함한 소프트 스킬들 또한 많이 중요하다고 생각이 들고 꾸준히 성장하도록 공부해야겠다!\r\n### 기술 블로그 시작\r\n2021년 공개 SW 개발자 대회를 마무리한 후 연말부터 기술 블로그를 시작하였다.\r\n\r\n학교에 친한 지인과 이야기와 자료들을 통해 Github.io 와 Jekyll을 사용한 블로그를 알게 되었고, 웹에 대한 css, js의 지식은 없었지만 크롬 개발자 도구와 검색을 통하여 내 블로그 홈페이지를 다루고 커스텀하는 것이 너무 재밌고 좋았다.\r\n\r\n처음에는 블로그의 작성이 나태해지지 않는다는(?) 생각으로 글을 쓴다고 생각이 있었지만 점점 블로그를 작성해 나가면서 __스스로 공부한 것들을 다시 한번 작성해 가면서 더 체화된다고 느꼈다.__\r\n\r\n앞으로도 나의 발전과 혹여 누군가 내 블로그를 보고 하나라도 얻고 갈 수 있도록 꾸준히 작성해 나가야겠다는 생각이 든다.\r\n\r\n### 졸업 프로젝트\r\n2022년 상반기에는 학교에서 졸업 캡스톤프로젝트를 진행하였다. 프로젝트는 기업과 산학협력으로 진행된 주제로 __세포 배양액 사진을 분석__ 하는 주제로 진행되었다. [(Cellification - 세포 분석 애플리케이션)](https://github.com/ppeper/Cellification)\r\n\r\n개인적으로 공부하였던 내용인 안드로이드 라이브러리를 해당 프로젝트를 통하여 적용해 볼 수 있는 좋은 기회라고 생각하였다. \r\n\r\n학습한 안드로이드 라이브러리를 실제로 프로젝트에 적용하면서 크고 작은 문제들이 생기고 예제로 학습하였던 것과는 달리 적용하는데 어려움이 있었다. 예제가 아닌 프로젝트에 적용하고 부딪혀봐야 진정히 공부한 내용이 나에게 체화되고 또한 알지 못하였던 새로운 문제점을 파악할 수 있다고 생각이 들었고 이를 위해 배운 내용을 간단한 토이 프로젝트라도 적용을 해나가야겠다!! \r\n\r\n프로젝트는 성공적으로 마무리하였지만 아쉬웠던 점들을 생각해보면 적용해보고자 하는 기술에 대해서 '이렇게 사용하는 것이 맞나..?', '더 좋은 방법이 있을까?' 등 많은 고민을 하였지만 좋은 코드를 작성하지 못한 것 같다고 생각이 들었고 이러한 자기 피드백을 생각하고 부족함 점을 채워가도록 많이 노력해야겠다고 생각했다.\r\n### SQLD\r\n학교에서 학사 졸업 요건으로 정보처리기사 또는 SQLD 자격증을 취득해야 했었다.   \r\n이 중 SQLD 자격증을 취득하고자 하였는데 그 이유는 먼저 첫 번째로 안드로이드 개발에서도 데이터베이스의 지식이 필요하다고 생각하였고, 두 번째로 정보처리기사와 달리 SQLD는 시험 한 번으로 합불 여부를 확인하기 때문이었다.\r\n\r\nSQLD 시험 일정이 얼마 남지 않아 2주간 __일명 노랭이__ 책으로 시험 문제와 시험 전날에는 기출문제를 풀면서 공부하였고 운 좋게 한 번에 자격증을 합격할 수 있었다...!!!😀\r\n## 2022 하반기\r\n### 알고리즘 스터디\r\n재학 중인 학교에서 학습그룹을 개설하여 학기 동안 알고리즘 스터디를 하였었는데, 하반기에 들어서 진행하였던 친구들과 꾸준히 개인적으로 같이 [스터디](https://github.com/4Rhythm)를 하면 좋겠다고 의견이 수립되어 꾸준히 문제를 풀고 있다. (알고리즘은 꾸준히 손 놓지 말고 해야겠다..!!)\r\n\r\n알고리즘과 코딩 테스트에 대한 공부는 꾸준히 진행을 하고 있었지만 스터디 그룹과 함께 의견을 피드백받고 코드 리뷰를 통하여 내가 생각하지 못하였던 인사이트를 얻을 수 있었다. \r\n\r\n또한 처음 자바로 알고리즘과 코딩테스트를 시작하였었지만 주 언어를 __코틀린__ 으로 바꿔 다시 공부하면서 안드로이드에서만 사용하였던 것과 다른 코틀린 언어의 특성과 표현식을 공부할 수 있었다.\r\n### OPIc\r\n삼성전자 하반기 공채에 맞춰 OPIc 시험을 보기로 하였다. 공채에 점수를 기입하여야 하였어서 시간이 없이 최대한 빠르게 결과가 나올 수 있도록 시험을 봤다 (3일 뒤에 시험이라니..😅) \r\n\r\n어느 정도 시험에 대해서 찾아보기만 하고 시험을 봐서 두려웠지만 __Intermediate Mid 2__ 등급으로 다행히 삼성전자에서 요구하는 등급 이상 얻게 되었다!! \r\n\r\n시험을 보고 나서 개발자가 되기 위해서는 많은 문서들을 읽을 경우가 많을 것이고 분명 소통해야 하는 경우가 있을 것이라고 생각이 들었고 영어 공부도 조금씩 해나가야겠다는 생각이 들었다.\r\n# 마무리 & Hello 2023\r\n<img src=\"https://media0.giphy.com/media/clk44N1gC274ZeI7dn/giphy.gif?cid=ecf05e475oam3358kphw9tkriuei61gj2jl0ceyafmm5ukcs&rid=giphy.gif&ct=g\">\r\n\r\n2022년 처음으로 많은 코딩테스트와 면접 기회들을 접하면서 내가 생각하였던 것과 달리 신입이 되기위한 요구사항들에 대한 인사이트들을 많이 얻게 되었고 수 많은 기도와 좌절도 하였던 한해였다🫡. 나에게 이러한 경험이 성장하는데 있어 큰 거름이 되었다고 생각이 들어 마음이 홀가분하다.\r\n\r\n첫 회고를 작성하다보니 이것저것 나름대로 열심히 하였구나! 라는 생각이 들면서 동시에 부족하고 아쉬웠던 점을 느낄수 있었다. (회고..너좋은데??😘)\r\n\r\n연말에는 아직 많이 부족하지만 [SSAFY라는 좋은 교육 과정](https://www.ssafy.com/ksp/jsp/swp/swpMain.jsp)에 들어가게 되어 2023년에도 꾸준히 부족한 점을 채워나가며 다음 회고를 작성하기까지 열심히 달려나가야겠다!!\r\n\r\n\r\n"},{"excerpt":"안드로이드 Thread 안드로이드에서는 Main Thread와 Sub Thread가 동시에 자원에 접근하여 생기는 동기화 이슈를 발생 할 수 있기 때문에 메인 스레드(UI 스레드) 에서만 뷰의 값을 바꿀 수 있는 싱글 스레드로 동작 한다. -> 위와 같이 멀티 스레드 환경에서 동시에 스레드가 UI를 갱신을 하여고 한다면 가 어떠한 값으로 변경될지 알 수 …","fields":{"slug":"/runOnUiThread/"},"frontmatter":{"date":"October 16, 2022","title":"안드로이드 runOnUiThread?","tags":["Android","Thread","runOnUiThread"]},"rawMarkdownBody":"# 안드로이드 Thread\r\n\r\n안드로이드에서는 Main Thread와 Sub Thread가 동시에 자원에 접근하여 생기는 동기화 이슈를 발생 할 수 있기 때문에 __메인 스레드(UI 스레드)__ 에서만 뷰의 값을 바꿀 수 있는 __싱글 스레드로 동작__ 한다.\r\n\r\n<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/195595735-1577e824-1979-410c-860c-7b0a01fc54da.png\" width=\"70%\"></p>\r\n\r\n> -> 위와 같이 멀티 스레드 환경에서 동시에 스레드가 UI를 갱신을 하여고 한다면 `TextView`가 어떠한 값으로 변경될지 알 수 없다. \r\n\r\n## 싱글 스레드에서 중요한 점\r\n싱글 스레드로 동작하는 안드로이드에서 중요한 점은 따라서 아래와 같이 조심해야 하는 포인트가 있다.\r\n> __❗메인 스레드(UI 스레드) 를 오랜시간 블로킹하면 안된다__\r\n> \r\n> -> 메인 스레드를 블로킹한다는 의미는 사용자가 보고 있는 UI가 멈춘다는 의미와 같다. 안드로이드에서는 메인 스레드를 블로킹하면 ANR(Application Not Responding)이 발생하여 강제 종료가 된다.\r\n\r\n## 메인 스레드에서는 무거운 작업을 피하자\r\n안드로이드에서 메인 스레드를 블로킹하지 않기 위해서 다른 스레드에게 사진을 서버에서 다운 받는 작업을 한다고 하자. 해당하는 사진은 결국 UI에서 보여주기 위해 __메인 스레드에서 처리를 해줘야 할 것이다.__\r\n\r\n-> 이때 스레드간에 통신을 위해서는 __`Handler`와 `Looper`__ 를 통해서 처리 작업을 \r\n바꿔주어야 한다.\r\n- - -\r\n# Handler & Looper\r\n\r\n> 스레드가 시작 되면 스레드는 `Handler`, `Looper`, `MessagingQueue` 를 하나씩 가지고 있다. 각자의 기능은 스레드간의 통신을 위하여 사용된다.\r\n\r\n## Looper\r\n하나의 스레드는 단 하나의 `Looper`를 가지며, 해당 `Looper`는 오직 하나의 스레드를 담당한다.\r\n\r\n`Looper`의 내부에는 `MessageQueue`라는 것이 존재한다. 이름과 같이 MessageQueue는 __스레드가 처리 해야할 일들이__  `Message`__의 형태로 들어가 있는 FIFO 구조로 동작하는 친구__ 이다. `Looper`는 MessageQueue가 비어있으면 아무 행동을 하지 않다가 Message가 들어오면 적절한 `Handler`에게 전달하는 역할을 한다.\r\n\r\n> __Message?__\r\n> - `Message` 객체는 스레드가 처리하는 작업이라고 생각할 수 있다. MessageQueue 에서 이러한 작업을 넣어주거나 꺼내어 적절한 __Handler__ 에게 전달한다.\r\n> - Message 객체는 `Message`와 `Runnable` 두개로 나누어 진다.\r\n\r\n종합적으로 `Looper`는 __MessageQueue에 있는 메시지를 꺼내어 해당하는 `Handler` 에게 전달하는 역할__ 을 한다.\r\n\r\n## Handler\r\n`Handler` 는 이름과 비슷하게 어떠한 것을 다루는 일을 한다. 구체적으로 하는 일은 `Looper` __라는 친구의 MessagingQueue에 어떠한 값을 넣거나__ `Looper`에서 __MessagingQueue의 특정 메시지를 주면 이를 처리__ 한다.\r\n\r\n### 1. Looper에게 메시지 전달\r\nLooper는 `Message`와 `Runnable` 객체를 담을 수 있다.\r\n> __sendMessage()__\r\n>   - MessageQueue에 `Message` 객체를 담을 수 있다.\r\n>\r\n> __post()__\r\n>   - post 메소드를 통하여 `Runnable` 객체를 담을 수 있다.\r\n\r\n### 2. Looper에게서 메시지를 받음\r\nLooper의 Message Queue에서 `(something)`을 꺼냈을때 아래와 같이 구분이 된다.\r\n> __Message__\r\n>    - 해당 메시지의 내부에 있는 `Handler`가 가지고 있는 `handleMessage()`를 호출하여 `Handler`가 메시지를 전달 받을 수 있다.\r\n>\r\n> __Runnable__\r\n>    - `Runnable`의 `run()` 메소드를 통하여 작업을 실행할 수 있다.\r\n\r\n- - -\r\n\r\n# 정리해 보기\r\n<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/195654013-d526bca7-1c79-495f-bc6e-8976ebc5363a.png\" width=\"50%\"></p>\r\n\r\n> 1. 처음 스레드를 생성을 하여 `(something)`을 처리하고 UI를 갱신하기 위해서는 __메인 스레드(UI 스레드)__ 로 전달해야 한다.\r\n> 2. 특정 스레드 `Handler`의 `sendMessage()` 또는 `post()` 메소드를 호출하여 메인 스레드의 `Looper`의 MessageQueue에 메시지를 전달한다.\r\n> 3. 해당 스레드의 `Looper`가 MessageQueue에서 `Handler`에게 메시지를 하나씩 전달한다.\r\n> 4. `Handler`는 `handleMessage()`를 통해 받은 메시지를 처리한다.\r\n\r\n# 안드로이드에서 적접 보기\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        // Other Thread\r\n        val mThread = Thread { // 익명 객체 구현\r\n            // 여기서 UI 작업을 수행하면 Exception 발생\r\n        }\r\n        mThread.start()\r\n    }\r\n}\r\n```\r\n안드로이드의 UI관련한 작업은 __메인 스레드__ 에서 동작한다고 하였다. 따라서 다른 스레드에서 UI 관련 작업을 하려고 하면 Exception이 발생한다.\r\n\r\n앞서 말한 대로 `Handler`를 통하여 __메시지를 메인 스레드의 MessageQueue에 전달__ 해 주어야 한다.\r\n\r\n안드로이드에서는 __메인 스레드__ 가 가지고 있는 `Looper`를 명시하는 `getMainLooper()`를 제공한다.\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n    private var mHandler: Handler? = null\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        // 명시적으로 메인 스레드의 Looper를 생성\r\n        mHandler = Handler(Looper.getMainLooper())\r\n        // Other Thread\r\n        val mThread = Thread { // 익명 객체 구현\r\n            // 여기서 UI 작업을 수행하면 Exception 발생\r\n            mHandler!!.post {\r\n                // UI 작업 가능.\r\n            }\r\n        }\r\n        mThread.start()\r\n    }\r\n}\r\n```\r\n서브 스레드에서의 작업을 메인 스레드의 Looper의 `mHandler!!.post` 를 통하여 메인 스레드에서 UI 작업을 할 수 있다.\r\n\r\n# runOnUiThread는 그래서?\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/195632360-67bc0531-85bd-4182-943e-0889dc703619.png\">\r\n\r\n안드로이드 `runOnUiThread`는 `Activity` 클래스에서 제공되는 메소드이다. Android developer에서는 `Runnable` 객체를 메인 스레드에서 실행하도록 만드는 메소드로 __현재 스레드가 메인 스레드이면 `Runnable` 객체의 `run()` 메소드를 직접 실행__ 을 하고 아니라면 `Handler`에게 `post()` 메소드를 통하여 메인 스레드로 이벤트 큐를 발송한다.\r\n\r\n```java\r\npublic final void runOnUiThread(Runnable action) {\r\n    if (Thread.currentThread() != mUiThread) {\r\n        mHandler.post(action);\r\n    } else {\r\n        action.run();\r\n    }\r\n}\r\n```\r\n\r\n따라서 `runOnUiThread()`를 사용하면 메인 스레드가 아닐때만 `Handler`는 `post()`를 통하여 이벤트를 발생시키기 때문에 좀 더 효율적이라고 할 수 있다.\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n    \r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        // Other Thread\r\n        val mThread = Thread { // 익명 객체 구현\r\n            // 여기서 UI 작업을 수행하면 Exception 발생\r\n            runOnUiThread {\r\n                // UI 작업 가능.\r\n                // UI 스레드가 아니라면 내부적으로 handler.post() 호출\r\n            }\r\n        }\r\n        mThread.start()\r\n    }\r\n}\r\n```\r\n- - -\r\n# References\r\n- [https://hungseong.tistory.com/26](https://hungseong.tistory.com/26)"},{"excerpt":"🚀 ViewPager2 안드로이드 어플을 개발을 하다보면 RecyclerView를 통하여 데이터 목록을 보여주는 경우가 많다. 안드로이드에서 데이터의 목록이 아니라 Pager 형식의 ViewHolder를 구현하려면 를 사용을 해야한다. ViewPager와 ViewPager2 ViewPager2는 AndroidX가 발표된 이후에 새롭게 나온 ViewPage…","fields":{"slug":"/viewpager2/"},"frontmatter":{"date":"September 17, 2022","title":"안드로이드 ViewPager2 사용기","tags":["Android","ViewPager2"]},"rawMarkdownBody":"# 🚀 ViewPager2\r\n안드로이드 어플을 개발을 하다보면 RecyclerView를 통하여 데이터 목록을 보여주는 경우가 많다. 안드로이드에서 데이터의 목록이 아니라 Pager 형식의 ViewHolder를 구현하려면 `ViewPager2`를 사용을 해야한다.\r\n\r\n## ViewPager와 ViewPager2\r\nViewPager2는 AndroidX가 발표된 이후에 새롭게 나온 ViewPager로 구글 공식문서에서 아래와 같은 기능을 지원하여 적극 사용을 권장하고 있다.\r\n- ViewPager2는 세로방향의 페이징을 제공하고 있다. (orientation의 속성)\r\n- RTL(Right To Left) 페이징을 지원한다.\r\n    - RTL 페이징의 경우 설정된 언어에 따라 자동으로 사용 설정되지만 `layoutDirection`의 속성으로 수동으로 설정할 수 있다.\r\n- 수정 가능한 Framgent Collection을 통해 페이징을 지원하며 `notifyDataSetChanged()`를 호출하여 UI를 업데이트 한다.\r\n    - 📌 앱은 런타임 시 Fragment Collection을 동적으로 수정할 수 있다.\r\n\r\n__ViewPager2__ 는 RecyclerView를 기반으로 만들어진 컴포넌트로 `RecyclerView.Adapter`와 `FragmentStateAdapter` 두 가지 방법으로 구현이 가능하다.\r\n- - -\r\n# 사용하기 (RecyclerView.Adapter)\r\n## build.gradle 설정\r\n`ViewPager2`를 사용하기 위해서 `build.gradle`에 종속성을 추가한다.\r\n\r\n```gradle\r\ndependencies {\r\n    implementation \"androidx.viewpager2:viewpager2:1.0.0\"\r\n}\r\n```\r\n\r\n## ViewPager2 layout 설정\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    android:orientation=\"vertical\"\r\n    tools:context=\".MainActivity\">\r\n\r\n    <androidx.viewpager2.widget.ViewPager2\r\n        android:id=\"@+id/viewPager1\"\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"0dp\"\r\n        android:layout_weight=\"0.5\"\r\n        android:orientation=\"horizontal\" />\r\n\r\n</LinearLayout>\r\n```\r\nlayout file에서 위와 같이 `android:orientation=\"horizontal\"`로 설정이 가능하고.\r\n\r\nProgrammically로도 설정할 수 있다.\r\n`viewPager2.orientation = ViewPager2.ORIENTATION_HORIZONTAL`\r\n\r\n## Adapter 설정\r\n간단하게 페이지의 title number를 보여주는 ViewPager Adapter를 만들어 준다.\r\n\r\n```kotlin\r\ndata class Data(\r\n    var title: String\r\n)\r\n\r\nclass ViewPager2Adapter(\r\n    private val list: ArrayList<Data>\r\n): RecyclerView.Adapter<ViewPager2Adapter.CustomViewHolder>() {\r\n\r\n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): CustomViewHolder {\r\n        val binding = ItemListBinding.inflate(LayoutInflater.from(parent.context), parent, false)\r\n        return CustomViewHolder(binding)\r\n    }\r\n\r\n    override fun onBindViewHolder(holder: CustomViewHolder, position: Int) {\r\n        holder.bind(list[position])\r\n    }\r\n\r\n    override fun getItemCount() = list.size\r\n\r\n    inner class CustomViewHolder(private val binding: ItemListBinding) :\r\n        RecyclerView.ViewHolder(binding.root) {\r\n\r\n        fun bind(data: Data) {\r\n            with(binding) {\r\n                textView.text = data.title\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## Activity에서 사용\r\n사용할 Activity에서 `adpater`를 붙여주어 사용한다.\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n    private lateinit var binding: ActivityMainBinding\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        binding = ActivityMainBinding.inflate(layoutInflater)\r\n        setContentView(binding.root)\r\n\r\n        val list: ArrayList<Data> = ArrayList()\r\n        list.apply {\r\n            add(Data(\"First\"))\r\n            add(Data(\"Second\"))\r\n            add(Data(\"Third\"))\r\n        }\r\n        binding.viewPager1.adapter = ViewPager2Adapter(list)\r\n        // binding.viewPager1.orientation = ViewPager2.ORIENTATION_HORIZONTAL\r\n    }\r\n}\r\n```\r\n## Tablayout 사용하기\r\nlayout 파일에 `TabLayout`을 추가한다.\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    android:orientation=\"vertical\"\r\n    tools:context=\".MainActivity\">\r\n\r\n    <com.google.android.material.tabs.TabLayout\r\n        android:id=\"@+id/tabLayout1\"\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"wrap_content\" />\r\n\r\n    ...\r\n\r\n</LinearLayout>\r\n```\r\n\r\n`TabLayout` 과 `ViewPager` 간의 연결은 __TabLayoutMediator__ 를 구현한다. \r\n\r\n__TabLayoutMediator__ 에는 TabLayout과 ViewPager2 객체를 전달하고 `attach()` 함수를 호출하여 연동한다.\r\n\r\n구현된 인터페이스는 Tab을 눌렀을때 해당하는 position마다 tab title text를 설정해 줄 수 있다.\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n        .\r\n        .\r\n        .\r\n        // TabLayout 추가\r\n        TabLayoutMediator(binding.tabLayout1, binding.viewPager1) { tab, position ->\r\n            tab.text = \"Tab ${position + 1}\"\r\n        }.attach()\r\n    }\r\n}\r\n```\r\n- - -\r\n# 사용하기 (FragmentStateAdapter)\r\nFragment를 보여주도록 하는 `Adapter`가 바로 __FragmentAdapter__ 이다. 이는 RecyclerView의 `Adapter`를 만들때 RecyclerView.Adapter를 상속 받아 만들었을때와 같은 `Adapter`이다.\r\n\r\n__FragmentStateAdapter__ 는 RecyclerView에서 Adapter에 ViewHolder를 지정하는 것과 마찬가지로, `FragmentViewHolder` 가 지정되어 구현 된다.\r\n\r\n__FragmentStateAdapter__ 를 구현하기 위해서는 `getItemCount()`와 `createFragment()`를 반드시 구현해야 한다.\r\n\r\n> 🔔 구글 공식 문서에서 __FragmentStateAdapter()__ 는 3종류의 생성자가 있다\r\n\r\n```java\r\n    public FragmentStateAdapter(@NonNull FragmentActivity fragmentActivity) {\r\n        this(fragmentActivity.getSupportFragmentManager(), fragmentActivity.getLifecycle());\r\n    }\r\n\r\n    /**\r\n     * @param fragment if the {@link ViewPager2} lives directly in a {@link Fragment} subclass.\r\n     *\r\n     * @see FragmentStateAdapter#FragmentStateAdapter(FragmentActivity)\r\n     * @see FragmentStateAdapter#FragmentStateAdapter(FragmentManager, Lifecycle)\r\n     */\r\n    public FragmentStateAdapter(@NonNull Fragment fragment) {\r\n        this(fragment.getChildFragmentManager(), fragment.getLifecycle());\r\n    }\r\n\r\n    /**\r\n     * @param fragmentManager of {@link ViewPager2}'s host\r\n     * @param lifecycle of {@link ViewPager2}'s host\r\n     *\r\n     * @see FragmentStateAdapter#FragmentStateAdapter(FragmentActivity)\r\n     * @see FragmentStateAdapter#FragmentStateAdapter(Fragment)\r\n     */\r\n    public FragmentStateAdapter(@NonNull FragmentManager fragmentManager,\r\n            @NonNull Lifecycle lifecycle) {\r\n        mFragmentManager = fragmentManager;\r\n        mLifecycle = lifecycle;\r\n        super.setHasStableIds(true);\r\n    }\r\n```\r\n\r\n> __1. FragmentStateAdapter(FragmentActivity fragmentActivity)__\r\n> - 주로 ViewPager2가 Activity내에서 동작할 때 사용된다.\r\n\r\n> __2. FragmentStateAdapter(Fragment fragment)__\r\n> - Fragment 내에서 동작하는 ViewPager2를 만들 때 사용한다.\r\n\r\n> __3. FragmentStateAdapter(FragmentManager fragmentManager, Lifecycle lifecycle)__\r\n> - `fragmentManager`와 `lifecycle`이 호출되는 것으로 보아 1, 2번의 생성자 함수에서 호출되는 함수이다.\r\n\r\n예시에서는 CustomFragment를 두개 생성하여 FragmentActivity로 받아 사용하였다.\r\n\r\n__activity_main.xml__\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    android:orientation=\"vertical\"\r\n    tools:context=\".MainActivity\">\r\n\r\n    ...\r\n\r\n    <com.google.android.material.tabs.TabLayout\r\n        android:id=\"@+id/tabLayout2\"\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"wrap_content\"/>\r\n\r\n    <androidx.viewpager2.widget.ViewPager2\r\n        android:id=\"@+id/viewPager2\"\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"0dp\"\r\n        android:layout_weight=\"0.5\"\r\n        android:orientation=\"horizontal\" />\r\n\r\n</LinearLayout>\r\n```\r\n```kotlin\r\nclass ViewPagerAdapter(fa: FragmentActivity): FragmentStateAdapter(fa){\r\n    override fun getItemCount() = 2\r\n    override fun createFragment(position: Int): Fragment {\r\n        return when (position) {\r\n            0 -> CustomFragment1()\r\n            1 -> CustomFragment2()\r\n            else -> throw IndexOutOfBoundsException()\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n## Fragment 생성\r\n\r\nTab을 눌렀을때 Fragment를 통하여 보여주도록 CustomFragment(1,2)를 생성해 준다.\r\n\r\n```kotlin\r\nclass CustomFragment1 : Fragment() {\r\n    private lateinit var binding: FragmentCustomBinding\r\n\r\n    override fun onCreateView(\r\n        inflater: LayoutInflater, container: ViewGroup?,\r\n        savedInstanceState: Bundle?\r\n    ): View {\r\n        binding = FragmentCustomBinding.inflate(inflater, container, false)\r\n        return binding.root\r\n    }\r\n}\r\n```\r\n\r\n## Activity에서 사용\r\n`Acitivty` <- `FragmentActivity` <- `AppCompatActivity`로 MainActivity에서 __ViewPagerAdapter(this)__ 로 adapter를 설정할 수 있다.\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n    private lateinit var binding: ActivityMainBinding\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        binding = ActivityMainBinding.inflate(layoutInflater)\r\n        setContentView(binding.root)\r\n\r\n        ...\r\n\r\n        binding.viewPager2.adapter = ViewPagerAdapter(this)\r\n        // TabLayout 추가\r\n        TabLayoutMediator(binding.tabLayout2, binding.viewPager2) { tab, position ->\r\n            tab.text = \"Fragment ${position + 1}\"\r\n        }.attach()\r\n    }\r\n}\r\n```\r\n<p align=\"center\">\r\n<img src=\"https://user-images.githubusercontent.com/63226023/190859015-dd54e6ba-8cc2-4082-9252-896f9e58e987.gif\" width=\"30%\">\r\n</p>\r\n- - -\r\n# References\r\n- [https://developer.android.com/training/animation/screen-slide-2?hl=ko](https://developer.android.com/training/animation/screen-slide-2?hl=ko)"},{"excerpt":"DiffUtil 넌 뭐니 안드로이드를 공부하거나 개발하다보면 대부분 리스트를 보여주기 위하여  의 사용을 하게되고, 리스트의 데이터가 변하게 되면  를 호출하여 리사이클러뷰를 갱신하였다. 이는 바뀐 데이터가 적더라도 간혹 를 호출하여 갱신하기도 하는데 이는 앱 성능에 굉장히 악영향 을 미치게된다. (난가..😅)  를 호출하게 되면 리스트의 모든 데이터를 …","fields":{"slug":"/android-diffutil/"},"frontmatter":{"date":"September 01, 2022","title":"안드로이드 RecyclerView의 DiffUtil 알아보기","tags":["Android","DiffUtil","RecyclerView"]},"rawMarkdownBody":"# DiffUtil 넌 뭐니\r\n안드로이드를 공부하거나 개발하다보면 대부분 리스트를 보여주기 위하여 `RecyclerView` 의 사용을 하게되고, 리스트의 데이터가 변하게 되면 `notifyDataSetChange()` 를 호출하여 리사이클러뷰를 갱신하였다. 이는 바뀐 데이터가 적더라도 간혹 `notifyDataSetChange()`를 호출하여 갱신하기도 하는데 이는 __앱 성능에 굉장히 악영향__ 을 미치게된다. (난가..😅)\r\n\r\n`notifyDataSetChange()` 를 호출하게 되면 __리스트의 모든 데이터를 다시 처음부터 새로운 객체를 생성하여 랜더링__ 하기 때문에 __비용이 크게 발생한다.__\r\n\r\n이런 경우를 위해 등장한 것이 __DiffUtil__ 클래스이다. DiffUtil은 __이전 데이터와 현재 데이터 목록의 차이를 계산하여__ 업데이트 해야할 데이터에 대해서만 갱신을 할 수 있게 한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/187503548-029d1017-9e5d-4712-90c3-257e47f2e594.gif\">\r\n\r\n> 📃 두 데이터간의 차이를 계산은 Eugene W.Myers 의 Diff(erence) Algorithm이 사용되었다고 한다.\r\n\r\n# 사용 방법\r\n`DiffUtil` 는 __이전과 현재의 목록의 차이를 계산__ 을 한 뒤 `DiffUtil.Callback` 이라는 추상 클래스를 __콜랙 클래스로 활용__ 하게 된다. 이 클래스는 __4개의 추상 메소드와 1개의 일반 메소드__ 로 이루어져 있으며, 이를 확장하여 메소드를 오버라이딩 하여 사용한다.\r\n> __getOldListSize()__\r\n>\r\n> 이전 목록의 크기를 반환한다.\r\n\r\n> __getNewListSize()__\r\n>\r\n> 새로운 목록의 크기를 반환한다.\r\n\r\n> __areItemsTheSame(int oldItemPosition, int newItemPosition)__\r\n>\r\n> 두 항목이 같은 객체인지 반환한다. \r\n\r\n> __areContentsTheSame(int oldItemPosition, int newItemPosition)__\r\n>\r\n> 두 항목의 데이터가 같은지 여부를 반환한다. `areItemsTheSame()`이 true를 반환할 때만 호출된다. -> 같은 객체가 아니면 당연히 데이터는 다르기 때문에 비교하는것이 의미가 없음\r\n\r\n> __getChangePayload(int oldItemPosition, int newItemPosition)__\r\n>\r\n> 만약 `areItemTheSame()`이 true를 반환하고, `areContentsTheSame()`이 false를 반환했다면 __변경 내용에 대한 페이로드__ 를 가져온다.\r\n\r\n먼저 `DiffUtil.Callback` 함수를 (익명)클래스를 구현한다.\r\n\r\n```kotlin\r\nclass DiffUtilCallback(\r\n    private val oldList: List<Any>,\r\n    private val newList: List<Any>\r\n): DiffUtil.Callback() {\r\n    override fun getOldListSize() = oldList.size\r\n\r\n    override fun getNewListSize() = newList.size\r\n\r\n    \r\n    // 객체의 고유 값을 비교하는게 좋다.\r\n    override fun areItemsTheSame(oldItemPosition: Int, newItemPosition: Int): Boolean {\r\n        val oldItem = oldList[oldItemPosition]\r\n        val newItem = newList[newItemPosition]\r\n        return oldItem.id == newItem.id\r\n    }\r\n\r\n    override fun areContentsTheSame(oldItemPosition: Int, newItemPosition: Int): Boolean {\r\n        val oldItem = oldList[oldItemPosition]\r\n        val newItem = newList[newItemPosition]\r\n        return oldItem == newItem\r\n    }\r\n}\r\n```\r\n\r\n이렇게 만든 클래스를 생성한 후에는 해당 부분을 adpter내에서 아래와 같은 함수를 만들어 `DiffUtil.calculateDiff()` 에 해당 __콜백 클래스(DiffUtilCallback)__ 를 통하여 업데이트가 필요한 리스트를 찾는다.\r\n\r\n이후 기존의 `notifyDataSetChange()` 대신에 `dispatchUpdatesTo(Adapter adapter)` 를 사용하면 __부분적으로 데이터를 교체하는 notify가 실행__ 된다.\r\n\r\n```kotlin\r\n// RecyclerView Adapter 내에서\r\nprivate val list = mutableListOf<Any>()\r\n\r\n...\r\n\r\nprivate fun update(newList: List<Any>) {\r\n    val diffUtil = DiffUtilCallback(list, newList)\r\n    val diffResult: DiffUtil.DiffResult = DiffUtil.calculateDiff(diffUtil)\r\n    list.clear()\r\n    list.addAll(newList)\r\n    diffResult.dispatchUpdatesTo(this)\r\n}\r\n```\r\n\r\n- 리스트의 크기가 크다면 비교 연산이 길어질 수 있으므로 `calculateDiff()` 는 __백그라운드 쓰레드에서 처리__ 를 해주고, 메인 쓰레드에서 `DiffUtil.DiffResult` 를 가져와 사용하는 것이 권장된다.\r\n- 구현상 목록의 최대 크기는 2²⁶개 이다.\r\n\r\n- - -\r\n# AsyncListDiffer\r\n위에서 말한 `DiffUtil`을 백그라운드 쓰레드에서 수행할 수 있게 해주는 클래스이다. __`adapter`와 `DiffUtil`을 인자로 받아 백그라운드에서 수행 후 RecyclerView에 결과를 반영__ 할 수 있게 해준다. \r\n\r\n## 사용 방법\r\n먼저 리스트의 요소를 비교할 때 호출할 `DiffUtil.ItemCallback`를 구현한다.\r\n\r\n```kotlin\r\nclass AsyncDiffUtilCallback : DiffUtil.ItemCallback<Any>() {\r\n\r\n    override fun areItemsTheSame(oldItem: Any, newItem: Place) {\r\n        return oldItem.id == newItem.id\r\n    }\r\n        \r\n\r\n    override fun areContentsTheSame(oldItem: Any, newItem: Any) {\r\n        return oldItem == newItem\r\n    }\r\n}\r\n```\r\n마찬가지로 adapter 내부에서 `AsyncListDiffer` 객체를 선언하여 사용하면 된다.\r\n\r\n> __getCurrentList()__\r\n>\r\n> adapter에서 사용하는 리스트에 접근하고 싶을때 사용한다.\r\n\r\n> __submitList()__\r\n>\r\n> 리스트의 데이터를 교체할 때 사용한다.\r\n\r\n```kotlin\r\nclass CustomAdapter(): RecyclerView.Adapter<CustomAdapter.CustomViewHolder>() {\r\n    val differ = AsyncListDiffer(this, AsyncDiffUtilCallback())\r\n\r\n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): CustomViewHolder { ... }\r\n\r\n    override fun onBindViewHolder(holder: CustomViewHolder, position: Int) {\r\n        // getCurrentList()\r\n        val any = differ.currentList[position]\r\n        holder.bind(any)\r\n    }\r\n\r\n    override fun getItemCount() = differ.currentList.size\r\n    \r\n    // submitList()\r\n    fun update(newItems: List<Any>) = diffUtil.submitList(newItems)\r\n}\r\n```\r\n> ~~(AsyncListDiffer 클래스 최고다!!)~~ 아직 한발 남았다..\r\n\r\n- - -\r\n# ListAdapter✨\r\n이러한 AsyncListDiffer을 더 편리하게 사용하도록 한 Wrapper 클래스가 `ListAdapter`이다.\r\n\r\n`ListAdapter`는 DiffUtil을 활용하여 리스트를 업데이트하는 기능이 추가된 Adapter라고 생각하면 된다.\r\n\r\n`ListAdapter` 의 인자로 __제너릭 타입 T에는 데이터의 타입, 두번째로 RecyclerView.ViewHolder__ 를 넣어준다.\r\n\r\n```kotlin\r\npublic abstract class ListAdapter<T, VH extends RecyclerView.ViewHolder>\r\n        extends RecyclerView.Adapter<VH> {\r\n    final AsyncListDiffer<T> mDiffer;\r\n    private final AsyncListDiffer.ListListener<T> mListener =\r\n            new AsyncListDiffer.ListListener<T>() {\r\n        @Override\r\n        public void onCurrentListChanged(\r\n                @NonNull List<T> previousList, @NonNull List<T> currentList) {\r\n            ListAdapter.this.onCurrentListChanged(previousList, currentList);\r\n        }\r\n    };\r\n```\r\n`ListAdapter`는 AsyncListDiffer를 포함하는 클래스로, AsyncListDiffer의 객체 생성이 필요없이 __백그라운드 쓰레드에서 DiffUtil의 비교 연산__ 을 편하게 수행할 수 있다.\r\n\r\n> __getItem(position: Int)__\r\n>\r\n> ListAdapter 내부의 리스트에 해당 position 데이터를 사용할때 활용한다.\r\n\r\n> __getCurrentList()__\r\n>\r\n> ListAdapter에서 사용하는 리스트에 접근하고 싶을때 사용한다.\r\n\r\n> __submitList()__\r\n>\r\n> 리스트의 데이터를 교체할 때 사용한다.\r\n\r\n```kotlin\r\n// 제너릭 T와 ViewHolder를 넣어준다\r\nclass CustomListAdapter(): ListAdapter<Any, CustomListAdapter.CustomViewHolder>(diffUtil) {\r\n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): CustomViewHolder { ... }\r\n\r\n    override fun onBindViewHolder(holder: CustomViewHolder, position: Int) {\r\n        // getItem()\r\n        holder.bind(getItem(position))\r\n    }\r\n\r\n    // DiffUtil.ItemCallback\r\n    companion object {\r\n        val diffUtil = object: DiffUtil.ItemCallback<Any>() {\r\n            override fun areItemsTheSame(oldItem: Any, newItem: Any): Boolean {\r\n                return oldItem.id == newItem.id\r\n            }\r\n\r\n            override fun areContentsTheSame(oldItem: Any, newItem: Any): Boolean {\r\n                return oldItem == newItem\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n`ListAdapter`를 사용하면 자체에서 `submitList()`를 지원하므로 메소드를 노출시키지 않고 adapter에서 바로 호출할 수 있다.\r\n\r\n```kotlin\r\n// Activity & Fragment\r\nadpater.submitList(newList)\r\n```\r\n\r\n- - -\r\n# References\r\n- [https://hungseong.tistory.com/24](https://hungseong.tistory.com/24)\r\n- [https://blog.kmshack.kr/RecyclerView-DiffUtil로-성능-향상하기](https://blog.kmshack.kr/RecyclerView-DiffUtil%EB%A1%9C-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81%ED%95%98%EA%B8%B0/)\r\n"},{"excerpt":"은 반응형 프로그래밍으로 비동기 프로그래밍을 구현하기 위하여 많이 사용이 되어 한번 학습을 해봐야 겠다는 생각이 들었다. Coroutine을 학습하는 도중 ReacticeX와 같은 기능을 할 수 있는 비동기 스트림 를 제공하고 있어 ReactiveX 이전에 먼저 Flow에 기본적인 개념에 대해 알아보려고 한다. Flow란 코루틴에서 Flow(흐름)은 단일…","fields":{"slug":"/flow/"},"frontmatter":{"date":"July 16, 2022","title":"Kotlin Coroutines Flow 맛보기","tags":["Kotlin","Flow","Coroutines"]},"rawMarkdownBody":"`youtube: https://www.youtube.com/watch?v=fSB6_KE95bU`\r\n\r\n`ReactiveX`은 반응형 프로그래밍으로 비동기 프로그래밍을 구현하기 위하여 많이 사용이 되어 한번 학습을 해봐야 겠다는 생각이 들었다. Coroutine을 학습하는 도중 ReacticeX와 같은 기능을 할 수 있는 __비동기 스트림__ `Flow`를 제공하고 있어 ReactiveX 이전에 먼저 Flow에 기본적인 개념에 대해 알아보려고 한다.\r\n- - -\r\n# Flow란\r\n코루틴에서 Flow(흐름)은 단일 값만 반환하던 Suspend 함수와는 다르게 __여러 값을 순차적__ 으로 내보낼 수 있다. 또한 반응형 프로그래밍으로 실시간으로 업데이트 하는 상황에서 더욱 코드를 효과적으로 사용할 수 있다. \r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/178661246-540be0cf-a252-4666-9204-ab953441fbfa.png\">\r\n\r\n코루틴에서 데이터 스트림을 구현하기 위해서의 구성요소는 다음과 같다.\r\n\r\n- __Producer(생산자)__\r\n- __Intermediary(중간 연산자) - 선택사항__\r\n- __Consumer(소비자)__\r\n\r\n## Producer(생산자)\r\n먼저 생산자에서는 데이터를 발행하기 위하여 __`flow {}` 코루틴 블록(빌더)을 생성한 후 내부에서 `emit()`을 통하여 데이터를 생성한다.__ 또한 `flow {}` 블록은 suspend 함수이므로 delay를 호출할 수 있다.\r\n```kotlin\r\nfun flowSomething(): Flow<Int> = flow {\r\n    repeat(10) {\r\n        emit(it) // 0 1 2 3..9\r\n        delay(100L) // 100ms\r\n    }\r\n}\r\n```\r\n\r\n### Flow 빌더\r\n- 앞서 `flow {}`를 사용하는 것이 가장 기본적인 플로우 빌더이다.\r\n- `emit()` 이외에 __`asFlow()`__ 를 통하여 Collection 및 Sequence를 Flow로 변환 할 수 있다.\r\n\r\n```kotlin\r\n// Int 배열    \r\n(6..10).asFlow().collect { value ->\r\n    println(value)\r\n}\r\n```\r\n \r\n## Intermediary(중간 연산자)\r\n생산자에서 데이터를 발행을 하였다면 중간 연잔자는 __생성된 데이터를 수정__ 할 수 있다.\r\n대표적으로 코틀린의 컬렉션의 함수와 같이 대표적으로 __map(데이터를 원하는 형태로 변환), filter(데이터 필터링), onEach(데이터를 변경후 수행한 결과를 반환)__ 등이 있다.\r\n```kotlin\r\n// Filter \r\nflowSomethings().filter {\r\n    // 짝수만 필터링\r\n    it % 2 == 0\r\n}\r\n// map\r\nflowSomethings().map {\r\n    // 각 데이터를 2배씩\r\n    it * 2\r\n}\r\n.\r\n.\r\n```\r\n## Consumer(소비자)\r\n마지막으로 생산자에서 데이터를 발행하고, 중간 연산자(선택)에서 데이터를 가공하였다면 소비자에서는 __`collect()`를 이용하여 전달된 데이터를 소비할 수 있다.__\r\n```kotlin\r\nfun main() = runBlocking {\r\n    flowSomething().map {\r\n        it * 2\r\n    }.collect { value ->\r\n        println(value)\r\n    }\r\n}\r\n// 0 2 4 6 8 .. 18\r\n```\r\n\r\n# References\r\n- [https://developer.android.com/kotlin/flow?hl=ko](https://developer.android.com/kotlin/flow?hl=ko)"},{"excerpt":"안드로이드와 코틀린을 공부 하면서 ,  키워드를 많이 봤지만 의미를 정확히 알지 못하였던 개념에 대해서 차근차근 알아가보려고 한다 😅 제네릭(Generic) 프로그래밍 언어에서는 Int, Char, String등 기본(Primitive) 데이터 타입을 지원한다. 제네릭 은 타입을 확실히 정하지 않고 동일한 코드를 사용할 수 있도록 지원해주는 유용한 기능이…","fields":{"slug":"/generic-in-out/"},"frontmatter":{"date":"June 25, 2022","title":"Kotlin 제네릭의 in, out 키워드?","tags":["제네릭","공병성","반공병성","불변성"]},"rawMarkdownBody":"안드로이드와 코틀린을 공부 하면서 `out`, `in` 키워드를 많이 봤지만 의미를 정확히 알지 못하였던 개념에 대해서 차근차근 알아가보려고 한다 😅\r\n\r\n# 제네릭(Generic)\r\n프로그래밍 언어에서는 Int, Char, String등 기본(Primitive) 데이터 타입을 지원한다. __제네릭__ 은 __타입을 확실히 정하지 않고__ 동일한 코드를 사용할 수 있도록 지원해주는 유용한 기능이다. 이는 __`<T>`__ 로 많이 친숙하게 볼 수 있는 친구다. \r\n```kotlin\r\nfun <T> generic(value: T) {\r\n    println(value)\r\n}\r\n\r\nfun main() {\r\n    generic(\"ppeper\")\r\n    generic(\"26\")\r\n}\r\n```\r\n# 불변성이란??\r\n`제네릭`은 자바와 마찬가지로 __타입 불변성__ 을 가진다. 타입 불변성은 제네릭 타입을 사용하는 __클래스나 인터페이스__ 에서는 __일치하는 타입만 사용할 수 있다__ 는 것을 말한다. 즉 해당 타입의 부모,자식의 타입은 사용이 불가하다. 그러한 이유는 예시를 통하여 알아가보자.\r\n\r\n```kotlin\r\nopen class Phone\r\nclass Apple: Phone()\r\nclass Samsung : Phone()\r\n\r\n// 상속 관계로 부모에 자식 사용이 가능하다.\r\nval iphone: Phone = Apple()\r\n\r\n// 오케이 나도 해볼까\r\n// Type Mismatch -> Required: Array<Phone> / Found: Array<Apple>\r\n// ....\r\nval iphones: Array<Apple> = arrayOf(Apple(), Apple())\r\nval phones: Array<Phone> = iphones\r\n```\r\n> 🤔분명 Phone을 상속받은 Apple 클래스인데 Type Mismatch?\r\n\r\n위와 같이 제네릭의 타입을 가지는 클래스, 인터페이스에서 __클래스의 상속관계가 형식인자의 상속관계와 같이 유지되지 않는다__ 즉, `A -> B` 일때 `Class<A> -> Class<B>` 를 만족하지 못한다. 이를 __Invariance(불변성)__ 이라고 한다.\r\n\r\n__불변성(Invariance)__ 이 존재하는 이유는 다음과 같은 문제가 일어날 수 있기 때문이다!\r\n\r\n```kotlin\r\nfun myPhones(phones: Array<Phone>) {\r\n    // ...???\r\n    phones[0] = Apple()\r\n}\r\n\r\nfun main() {\r\n    val galaxys: Array<Samsung> = arrayOf(Samsung())\r\n    myPhones(galaxys)\r\n}\r\n```\r\nSamsung폰에 대한 galaxys 변수의 Array를 모르고 myPhones[0]에 Apple()을 넣어준다면 타입이 맞지 않아 문제가 발생하게 된다.\r\n- - -\r\n## 불변성에 대한 한계점\r\n__불변성__ 은 __컴파일 타임 에러를 잡아주고 런타임에 에러를 내지않는 안전한 방법__ 이다. 그러나 이는 가끔 안전하다고 보장된 상황에서도 컴파일 에러를내 개발자를 불편하게 할 수 있다. \r\n\r\n```kotlin\r\nfun copy(from: Array<Phone>, to: Array<Phone>) {\r\n    for (index in from.indices) {\r\n        to[index] = from[index]\r\n    }\r\n}\r\n\r\nfun main() {\r\n    val phones: Array<Phone> = arrayOf(Phone())\r\n    val galaxys: Array<Samsung> = arrayOf(Samsung())\r\n    copy(galaxys, phones)\r\n    // Type Mismatch -> Required: Array<Phone> / Found: Array<Samsung>\r\n}\r\n```\r\nphones에 galaxys를 copy를 하는 함수는 문제가 없어보인다. 하지만 위에서 말한 __불변성__ 으로 인하여 __`A -> B` 일때 `Class<A> -> Class<B>`__ 를 만족하지 못하여 컴파일 에러로 판단한다.\r\n\r\n이를 해결하기 위해서는 개발자가 __`A -> B` 일때 `Class<A> -> Class<B>`__ 를 상속 받게 바꿔 주어야한다. 이를 __공병성__ 이라고 하며 코틀린에서는 __`out`__ 키워드를 사용한다.\r\n- - -\r\n## 📍공병성, out 키워드\r\n```kotlin\r\nfun copy(from: Array<out Phone>, to: Array<Phone>) {\r\n    for (index in from.indices) {\r\n        to[index] = from[index]\r\n    }\r\n}\r\n\r\nfun main() {\r\n    val phones: Array<Phone> = arrayOf(Phone())\r\n    val galaxys: Array<Samsung> = arrayOf(Samsung())\r\n    copy(galaxys, phones)\r\n}\r\n```\r\n> 위와 같이 __`out`__ 키워드를 통하여 __공변성__ 으로 변환을 통하여 불필요한 __불변성__ 문제를 해결할 수 있다.\r\n\r\n❗하지만 여기서 from에 Samsung()을 Write하려고 한다면 에러가 발생한다. \r\n```kotlin\r\nfun copy(from: Array<out Phone>, to: Array<Phone>) {\r\n    for (index in from.indices) {\r\n        to[index] = from[index]\r\n    }\r\n    // Type Mismatch -> Required: Nothing / Found: Samsung\r\n    from[0] = Samsung()\r\n}\r\n```\r\nfrom[0]에서는 Nothing 즉, 아무것도 입력받기를 원하지 않는다. 이유는 불변성과 비슷하다고 할 수 있다.\r\n\r\n> __[Read]__\r\n>\r\n> from에서는 `Array<out Phone>`을 통하여 컴파일러가 from의 부모가 Phone인것과 sub Type인 Apple, Samasung 중 하나인것을 인지 하고 있다. 따라서 읽을때는 문제가 발생하지 않는다.\r\n>\r\n> __[Write]__\r\n>\r\n> 하지만 from에 값을 쓰려고 한다면 타입이 Phone, Apple, Samsung 중 하나라는 것만 인지하고 있을뿐 __실제 타입을 모르는 Array__ 에서 값을 쓸 수가 없는 것이다.\r\n\r\n그렇다면 공병성과 반대되는 Read가 불가능하고 Write만 할 수 있는 것이 있지 않을까?\r\n\r\nRead가 가능한 __`out`__ 키워드가 있다면 반대로 Write이 가능한 \r\n__`in`__ 키워드가 있다. 이를 __반공병성(Contravariance)__ 라고 한다.\r\n- - -\r\nto 파라미터에 대해서 __`Array<Phone>`__ 에 대하여 __Phone의 super Type인 부모 클래스__ 를 전달하고 싶다면 어떻게 해야할까?\r\n\r\n```kotlin\r\nfun copy(from: Array<out Phone>, to: Array<Phone>) {\r\n    for (index in from.indices) {\r\n        to[index] = from[index]\r\n    }\r\n}\r\n\r\nfun main() {\r\n    val phones: Array<Any> = arrayOf(Any())\r\n    val galaxys: Array<Samsung> = arrayOf(Samsung())\r\n    copy(galaxys, phones)\r\n    // Type Mismatch -> Required: Array<Phone> / Found: Array<Any>\r\n}\r\n```\r\n위와 같이 __`Array<Any>`__ 로 선언하고 싶지만 위에서 설명한 __불변성으로 이는 안된다고 하였고__ 미리 컴파일러는 Type Mismatch를 통하여 에러를 알려 준다~~(고..마워😅)~~.\r\n\r\n이에 대해서 명시적으로 부모 클래스를 넘겨 줄 수 있는 방법이 __`in`__ 키워드이다.\r\n\r\n# 📍반공변성 in!\r\n```kotlin\r\nfun copy(from: Array<out Phone>, to: Array<in Phone>) {\r\n    for (index in from.indices) {\r\n        to[index] = from[index]\r\n    }\r\n}\r\n\r\nfun main() {\r\n    val phones: Array<Any> = arrayOf(Any())\r\n    val galaxys: Array<Samsung> = arrayOf(Samsung())\r\n    copy(galaxys, phones)\r\n}\r\n```\r\n> 위와 같이 __`in`__ 키워드를 통하여 __반공변성__ 으로 변환을 통하여 불필요한 __불변성__ 문제를 해결할 수 있다.\r\n\r\n`to[index] = from[index]`로 반공병성은 Write할때는 문제가 되지 않지만 반대로 Read를 하려고 하면 문제가 발생한다.\r\n\r\n```kotlin\r\nfun copy(from: Array<out Phone>, to: Array<in Phone>) {\r\n    for (index in from.indices) {\r\n        to[index] = from[index]\r\n    }\r\n    val phone: Phone = to[0]\r\n    // Type Mismatch -> Required: Phone / Found: Any?\r\n}\r\n```\r\n이에 대한 문제는 공병성과 반대로 컴파일러가 to 매개변수를 읽으려 할때 __반공병성__ 으로 __Phone과 그에 대한 조상 타입을 명시적으로 가능하게 하였으므로__ 읽을때는 실제 타입을 모르기 때문에 함부로 읽을 수 없는 것이다.\r\n\r\n# 정리\r\n공병성, 반공병성에 대해서 학습을 해보았지만 간단한 예시를 통하여 해보았기 때문에 많은 소스를 접해보고 사용해 봐야 할 것 같다.\r\n\r\n> out: __꺼내와서(out 시킨다)__ 읽는다. -> Write은 불가능\r\n>\r\n>   - 슈퍼 클래스에 서브 클래스를 사용가능하게 해준다.\r\n>\r\n> in: __넣어준다(in 시킨다)__ 즉, Write 할 수 있다. -> Read는 불가능\r\n>   - 서버 클래스에 슈퍼 클래스를 사용가능하게 해준다.\r\n\r\n- - -\r\n# References\r\n- [https://medium.com/mj-studio/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%A0%9C%EB%84%A4%EB%A6%AD-in-out-3b809869610e](https://medium.com/mj-studio/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%A0%9C%EB%84%A4%EB%A6%AD-in-out-3b809869610e)\r\n- [https://readystory.tistory.com/201](https://readystory.tistory.com/201)"},{"excerpt":"로컬 저장 지금까지 안드로이드 로컬에 간단한 데이터를 저장하기 위해 를 사용하였다. 구글에서는 DataStore 의 사용을 적극 권장하고 있고 (SharedPreferences는 구글 공식 문서에서도 사용가이드가 사라졌다..😨) Datastore를 사용하면 어떤 좋은점들이 있어서 사용을 이렇게 권고하는 것인가? Datastore를 하나씩 알아가 보자! 🚀…","fields":{"slug":"/datastore/"},"frontmatter":{"date":"June 16, 2022","title":"새로운 동료 DataStore 알아보기","tags":["Datastore","Local Data","jetpack"]},"rawMarkdownBody":"<img src=\"https://user-images.githubusercontent.com/63226023/174076432-24f77ccb-dcb7-45fe-a70d-5d65e4d08f19.png\">\r\n\r\n```kotlin\r\nclass 로컬 데이터 {\r\n    DataStore: 이제 여기는 얼씬도 말라. 알았어?   \r\n    SharedPreferences: ...\r\n}\r\n```\r\n\r\n# 로컬 저장\r\n지금까지 안드로이드 로컬에 간단한 데이터를 저장하기 위해 `SharedPreferences`를 사용하였다.   \r\n구글에서는 __DataStore__ 의 사용을 적극 권장하고 있고 ~~(SharedPreferences는 구글 공식 문서에서도 사용가이드가 사라졌다..😨)~~\r\n\r\n__Datastore를 사용하면 어떤 좋은점들이 있어서 사용을 이렇게 권고하는 것인가?__ Datastore를 하나씩 알아가 보자!\r\n\r\n# 🚀 DataStore\r\n__DataStore__ 는 `Key-Value` 타입으로 구성되어 있는 __Preferences DataStore__ 와 __사용자가 정의한 데이터를 저장__ 할 수 있는 __Proto DataStore__ 가 존재한다.\r\n\r\n__Proto DataStore__ 을 사용하기 위해서는 '프로토콜 버퍼'를 이용하여 __스키마를 정의__ 해야한다. 이는 데이터의 타입을 보장과 더불어 SharedPreferences보다 빠르고 단순하다👍\r\n## DataStore의 좋은점?\r\n<img src=\"https://user-images.githubusercontent.com/63226023/174060195-e04e5a19-9058-4a05-8e1e-74e3ffc56496.png\">\r\n\r\n[출처] [https://android-developers.googleblog.com/2020/09/prefer-storing-data-with-jetpack.html](https://android-developers.googleblog.com/2020/09/prefer-storing-data-with-jetpack.html)\r\n\r\n> 🤔 DataStore가 한눈에도 더 많은 것을 제공해 주는것을 볼 수 있다. 간단하게 요약하자면 다음과 같은 특징이 있다.\r\n>\r\n> - __코루틴 + Flow__ 를 사용하여 __Read/Write 에 대한 비동기 API를 제공__\r\n> - __UI Thread(Main Thread)__ 를 호출해도 안전 __(Dispatcher.IO에서 동작한다)__\r\n> - __RuntimeException 으로부터 안전__\r\n\r\n## 직접 사용해 보기\r\n### 라이브러리 추가\r\n`build.gradle(app)`에 아래와 같이 라이브러리를 추가해 준다.\r\n```gradle\r\n// Datastore\r\nimplementation 'androidx.datastore:datastore-preferences:1.0.0'\r\n```\r\n### DataStore 생성\r\n```kotlin\r\nclass AppDatastoreManager(private val context: Context) : AppDataStore {\r\n\r\n    private val Context.datastore: DataStore<Preferences> by preferencesDataStore(\r\n        name = \"datastore_name\"\r\n    )\r\n\r\n    // String 타입 저장 Key 값\r\n    private val stringKey = stringPreferencesKey(\"key_name\")\r\n    // Int 타입 저장 Key 값\r\n    private val intKey = intPreferencesKey(\"key_name\")\r\n    .\r\n    .\r\n    .\r\n}\r\n```\r\n__DataStore__ 을 생성해 주기 위해서는 안드로이드 Context의 확장 프로퍼티로 선언해 주고 DataStore에서 사용할 키 값을 설정해 준다.\r\n\r\n__PreferencesKey__ 는 아래와 같은 7가지 타입이 있다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/174065589-5a4a0d80-1034-4561-ad8c-e94342fe504f.png\">\r\n\r\n### 데이터를 Read하는 Flow 생성\r\n`DataStore`에서 데이터를 읽어올 때 __코루틴의 `Flow`__ 를 사용하여 데이터를 __`Flow`__ 객체로 전달한다.\r\n\r\n```kotlin\r\nval intValue :Flow<Int> =\r\n    context.datastore.data\r\n        .catch { exception ->\r\n            if (exception is IOException) {\r\n                emit(emptyPreferences())\r\n            } else {\r\n                throw exception\r\n            }\r\n        }.map { preference ->\r\n            preference[intKey] ?: 0\r\n        }\r\n```\r\n`map()` 함수를 사용하여 아까 생성한 __키 값(intKey)에 대응하는 Value__ 를 `Flow` 형태로 가져오도록 한다.\r\n\r\n또한 `catch()` 를 사용하여, 데이터 읽어오기에 실패하는 경우 `IOException` 을 처리하여 __emptyPreferences()__ 로 비어있는 값을 전달해준다.\r\n\r\n### 데이터를 Write하는 메소드 생성\r\n`DataStore`에 값을 쓸 때는 `edit()`메소드를 이용한다. 또한 값을 쓸때는 __반드시 비동기__ 로 작업이 되야하므로 __`suspend`__ 키워드를 통해 해당 작업이 __코루틴 영역에서 동작__ 할 수 있도록 해준다.\r\n\r\n```kotlin\r\nsuspend fun setInt(data: Int) {\r\n    context.datastore\r\n        .edit { preferences ->\r\n            preferences[intKey] = data\r\n        }\r\n}\r\n```\r\n### 이제 사용하기\r\nDataStore은 `Singleton`으로 관리되어야 한다. 따라서 Application에서 초기화해주고 사용해보도록 하자.\r\n\r\n```kotlin\r\nclass App: Application() {\r\n    companion object {\r\n        lateinit var datastore: AppDataStoreManager\r\n    }\r\n\r\n    override fun onCreate() {\r\n        super.onCreate()\r\n        initDatastore()\r\n    }\r\n\r\n    private fun initDatastore() {\r\n        datastore = AppDatastoreManager(applicationContext)\r\n    }\r\n}\r\n```\r\n<h2>1. 데이터 값 읽고 쓰기</h2>\r\n\r\n`DataStore`에서 읽은 데이터를 사용하기 위해서는 __DataStore 클래스에서 선언해 놓은 변수에 접근한 후__ `Flow`객체를 반환 받고 __`collect`__ 함수를 이용하여 값을 읽어온다. `CoroutineScope`에서 수행되어야 한다.\r\n```kotlin\r\nCoroutineScope(Dispatchers.Main).launch {\r\n    App.datastore.intValue.collect { it ->\r\n    // 값을 사용하여 뷰에 적용\r\n    }\r\n}\r\n```\r\n딱 원하는 타이밍에 한 번만 값을 받아와서 사용하고 싶을때는 `first()` 함수를 이용할 수 있다.\r\n```kotlin\r\nCoroutineScope(Dispatchers.Main).launch {\r\n    val intValue = App.datastore.intValue.first()\r\n}\r\n```\r\n\r\n> 동기적인 동작이 꼭 필요한 경우 `runBlocking`을 사용할 수 있다.\r\n> ```kotlin\r\n> runBlocking {\r\n>    val intValue = App.datastore.intValue.first()\r\n> }  \r\n> ```\r\n> UI 스레드에서 동기 작업을 실행하면 __ANR 또는 UI 버벅거림__ 이 발생할 수 있기 때문에 __과도한 동작은 금해야한다😨__\r\n> \r\n\r\n<h2>2. 데이터 저장</h2>\r\n\r\n`DataStore`에 값을 저장하고 싶을때는 미리 작성해 놓은 함수(setInt())를 사용하면 된다. 이때에 `suspending`으로 지정되어 있기 때문에 __코루틴이나 RxJava를 통해__ 비동기적으로 호출해 준다.\r\n```kotlin\r\nCoroutineScope(Dispatchers.Main).launch {\r\n    App.datastore.setInt(26)\r\n}\r\n```\r\n\r\n지금까지 SharedPreferences를 대체하여 사용하기 위한 DataStore를 알아보았다. 자체적으로 코루틴의 Flow를 사용하여 비동기적이고 안전하게 사용이 가능하다는 점을 보고 DataStore를 꾸준히 사용해 보면서 점점 더 큰 장점들을 알아가보면 좋을것 같다.\r\n\r\n# References\r\n- [https://developer.android.com/topic/libraries/architecture/datastore?gclid=Cj0KCQjwqKuKBhCxARIsACf4XuHSV6c0dQKCbCAO0rH42Pc-MFbVKxhgf1YRYxu2qf_yPmkeU5m3WfoaAqfKEALw_wcB&gclsrc=aw.ds#kts](https://developer.android.com/topic/libraries/architecture/datastore?gclid=Cj0KCQjwqKuKBhCxARIsACf4XuHSV6c0dQKCbCAO0rH42Pc-MFbVKxhgf1YRYxu2qf_yPmkeU5m3WfoaAqfKEALw_wcB&gclsrc=aw.ds#kts)\r\n- [https://kangmin1012.tistory.com/47](https://kangmin1012.tistory.com/47)"},{"excerpt":"🚀최단 경로 탐색 지난 시간에는 그래프와 최소 신장 트리(MST)를 구하는 알고리즘인 프림, 크루스칼 알고리즘을 알아보았다. (그래프 알고리즘이란 + 최소 신장 트리(MST)) 이번 포스팅은 그래프 최단 거리를 구하는 알고리즘에 대해서 알아보려고 한다. 📌다익스트라 다익스트라(dijkstra) 알고리즘은 그래프에서 최단 경로를 구하는 알고리즘 중 하나이다…","fields":{"slug":"/graph-sortest-path/"},"frontmatter":{"date":"May 30, 2022","title":"그래프 최단거리 구하기","tags":["Algorithm","다익스트라","플로이드 와샬","벨만포드"]},"rawMarkdownBody":"<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/170924395-e92bdf93-a6f9-4ad4-a57a-5a996edcbe7e.png\" width=\"70%\"></p>\r\n출처: 픽사베이\r\n\r\n# 🚀최단 경로 탐색\r\n지난 시간에는 그래프와 최소 신장 트리(MST)를 구하는 알고리즘인 프림, 크루스칼 알고리즘을 알아보았다. [(그래프 알고리즘이란 + 최소 신장 트리(MST))](https://ppeper.github.io/algorithm/graph/)\r\n\r\n이번 포스팅은 그래프 최단 거리를 구하는 알고리즘에 대해서 알아보려고 한다.\r\n\r\n## 📌다익스트라\r\n> 다익스트라(dijkstra) 알고리즘은 그래프에서 최단 경로를 구하는 알고리즘 중 하나이다. 다익스트라 알고리즘은 도착 정점 뿐만 아니라 __하나의 정점에서 모든 다른 정점까지 최단 경로로 방문하며 각 정점까지의 최단 경로__ 를 모두 찾게 된다.\r\n\r\n- 인접행렬을 사용: 정점의 수가 N일때, 인접행렬을 사용하면 각 단계마다 N개의 정점을 가중치가 짧은 간선을 찾기위해 순사탐색을 진행한다.\r\n    - __시간 복잡도: O(N²)__\r\n\r\n- 우선순위 큐 사용: 노드의 개수 V, 간선의 개수 E라고 했을때, 모든 간선을 확인하는 O(E)와 우선순위 큐에 최대로 들어갈 수 있는 수 O(E)와 추가 또는 삭제할때 드는 비용 O(LogE) -> 우선순위 큐에서의 시간 복잡도는 O(ELogE).\r\n\r\n따라서 전체 시간 복잡도는 O(E + ELogE) = O(ELogE)이고, 보통 E <= V² 이므로, __O(ELogV)__ 라고 볼 수 있다.\r\n\r\n### 동작 과정(우선순위 큐)\r\n1. 모든 노드에 대한 거리를 무한대 값(충분히 큰 값)으로 초기화\r\n2. 시작 노드에 대한 거리를 0으로 초기화 후 우선순위 큐에 담음\r\n3. 우선순위 큐에서 가져온 노드에 대한 인접한(갈수 있는 노드)노드를 확인\r\n4. 더 빠르면 거리를 갱신하고 우선순위 큐에 넣어줌\r\n5. 방문 or 더 느리면 continue\r\n6. 우선순위 큐가 empty될때까지 3~5 반복\r\n\r\n간단하게 1,2,3번 노드를 가지는 그래프에서 거리가 갱신되는 과정을 보면 아래와 같다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/169876693-1b222949-9886-4093-9aae-81bacfc62c01.png\">\r\n\r\n### 코드(우선순위 큐)\r\n인접한 정점들에 대한 list는 graph로 생성하였다고 가정\r\n\r\n```kotlin\r\ndata class Node(\r\n    val end: Int,\r\n    val weight: Int\r\n)\r\n// 최단 경로 리스트\r\nval distance = IntArray(6) { Int.MAX_VALUE }\r\n\r\nfun dijkstra(start: Int) {\r\n    // 시작 노드의 거리는 0\r\n    distance[start] = 0\r\n    // 기준은 가중치로 오름차순\r\n    val pq = PriorityQueue<Node>(compareBy { it.weight })\r\n    // 시작 노드\r\n    pq.add(Node(start, 0))\r\n    while (pq.isNotEmpty()) {\r\n        val curr = pq.poll()\r\n        // 새로 선택된 node보다 더 가중치가 적음 -> 방문한 느드\r\n        if (distance[curr.end] < curr.weight) {\r\n            continue\r\n        }\r\n        // 현재 시작 노드의 인접 노드들 확인\r\n        for (node in graph[curr.end]) {\r\n            val nextNode = node.end\r\n            // 다음 노드까지의 거리 + 현재 노드까지의 거리 -> 방문후 가는 거리\r\n            val nextDistance = node.weight + curr.weight\r\n            // 지금까지의 거리 보다 방문후 가는 거리가 짧으면 업데이트 후 우선순위 큐에 넣어줌\r\n            if (nextDistance < distance[nextNode]) {\r\n                distance[nextNode] = nextDistance\r\n                pq.add(Node(nextNode, nextDistance))\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n## 📌벨만 포드\r\n> 다익스트라 알고리즘과 마친가지로  ___하나의 정점에서 모든 다른 정점까지 최단 경로로 방문하며 각 정점까지의 최단 거리__ 를 찾을 수 있지만 차이점은 __음의 가중치가 있는 그래프__ 에서 사용할 수 있다. \r\n\r\n벨만 포드 알고리즘에서는 __음수 사이클__ 로 인하여 최단 거리를 정의할 수 없는 경우도 알아낼 수 있다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/170925669-279f8a63-2a15-46b5-b110-d7d2ff30a814.png\">\r\n\r\n> 1->2->3으로 가는경우 무한히 작아질 수 있으므로 최단 거리를 구할 수 없음 -> 계속 노드를 거쳐가면 1 + 2 -4 = -1 이므로 음의방향으로 발산한다.\r\n\r\n벨만 포드 알고리즘과 다익스트라 알고리즘의 차이점은 __음수 가중치__ 가 존재하는 경우에도 적용할 수 있다는 것이며, 시간 복잡도는 __O(VE)__ (V: 정점 개수, E: 간선 대수)로 다익스트라에서 우선순위 큐를 이용한 방식인 __O(ELogV)__ 보다 느리다.\r\n\r\n### 동작 과정\r\n1. 모든 노드에 대한 거리를 무한대 값(충분히 큰 값)으로 초기화\r\n2. 다음의 과정을 V-1번 반복한다.\r\n    - 모든 간선 E개를 순서대로 확인한다.\r\n    - 각 간선을 가쳐가 다른 노드로 가는 비용을 비교하여 최단 거리로 갱신한다.\r\n\r\n- 음수 간선 순환이 발생하는지 확인하기 위해서는 2번의 과정을 한 번 더 수행한다. -> 최단 거리가 갱신이 된다면 음수 간선 순환이 존재한다.\r\n\r\n### 코드\r\n```kotlin\r\nfun bellmanFord(start: Int): Boolean {\r\n    // 최단 경로 리스트\r\n    val distance = IntArray(graph.size) { INF }\r\n    distance[start] = 0\r\n    for (i in graph.indices) {\r\n        for (j in graph.indices) {\r\n            if (graph[i][j] != INF) {\r\n                if (distance[j] > distance[i] + graph[i][j]) {\r\n                    distance[j] = distance[i] + graph[i][j]\r\n                    // N번째에서 갱신이 되었다면 음수 사이클 존재\r\n                    if (i == graph.size - 1) {\r\n                        return true\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false\r\n}\r\n```\r\n\r\n## 📌플로이드 와샬\r\n> 플로이드 와샬 알고리즘은 벨만포드와 같이 __음의 가중치가 있는 그래프__ 에서 사용할 수 있고, 차이점은 하나의 정점이 아닌 __모든 정점에서 모든 다른 정점으로 가는 최단 거리__ 를 구할 수 있다. 다시 말하여 __다른 정점을 경유__ 하여 도착하는 최단 거리를 구할 수 있다.\r\n\r\n플로이드-워셜 알고리즘은 DP(Dynamic Programming) 기법을 사용한 알고리즘이다. 각 정점으로 부터 __다른 정점을 순차적으로 거쳐가면서 더 짧은 길이를 선택__ 하여 갱신 한다.\r\n\r\n다익스트라와 다른점은 정점까지의 거리 dist 배열을 __모든 정점__ 에서 모든 다른 정점으로 가는 최단 거리를 구해야 하므로 정점의 개수 V일때 V * V 크기의 dist 배열을 생성해주어야한다. \r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/170028092-efb435f9-1df9-406a-8c81-cb1be9081667.png\">\r\n\r\n위의 거리 배열에서 각 dist[i][i]는 시작 정점으로 자기자신에 대한 거리는 0이므로 초기화 해준다.\r\n\r\n### 동작 과정\r\n1. 인접행렬을 저장할 2차원 배열을 만들고 무한대(충분히 큰 값)로 초기화한다.\r\n    - 자기자신([i][i])는 0으로 초기화\r\n    - 그래프에 따라 간선 정보를 저장한다.\r\n2. 경유지를 거쳐가는 것이 빠르다면 거리 배열을 갱신 해준다.\r\n    - (시작: i, 도착: j일때 k가 경유 노드라면, dist[i][j] = min(dist[i][k] + dist[k][j])로 갱신)\r\n3. 모든 정점에 대해 순차적으로 경유지로 선택하여 2번 과정을 반복한다.\r\n\r\n### 코드\r\n```kotlin\r\nfun floyd(dist: Array<IntArray>, n: Int) {\r\n    // k -> 거쳐가는 노드\r\n    for (k in 0 until n) {\r\n        // i -> 출발 노드\r\n        for (i in 0 until n) {\r\n            // j -> 도착 노드\r\n            for (j in 0 until n) {\r\n                dist[i][j] = dist[i][j].coerceAtMost(dist[i][k] + dist[k][j])\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n- - -\r\n\r\n# References\r\n\r\n- [https://born2bedeveloper.tistory.com/44](https://born2bedeveloper.tistory.com/44)\r\n- [https://reinvestment.tistory.com/58](https://reinvestment.tistory.com/58)"},{"excerpt":"🎯그래프 정점(V)과 간선(E)로 이루어진 자료구조이다. 그래프는 사이클이 존재 할 수 있고 간선의 방향이 양뱡향일 수 있다. V개의 정점을 가지는 무방향 그래프  최대 간선 갯수 = V(V-1)/2 V개의 정점을 가지는 방향 그래프 의  최대 간선 갯수 = V(V-1) 🧷그래프의 종류 무방향 그래프: 두 정점을 연결하는 간선에 방향이 없는 그래프이다. …","fields":{"slug":"/graph-mst/"},"frontmatter":{"date":"May 20, 2022","title":"그래프 알고리즘이란 + 최소 신장 트리(MST)","tags":["Algorithm","MST","그래프","크루스칼","프림"]},"rawMarkdownBody":"# 🎯그래프\r\n- 정점(V)과 간선(E)로 이루어진 자료구조이다.\r\n- 그래프는 __사이클이 존재__ 할 수 있고 간선의 방향이 양뱡향일 수 있다.\r\n- V개의 정점을 가지는 __무방향 그래프__ \r\n    - 최대 간선 갯수 = V(V-1)/2\r\n- V개의 정점을 가지는 __방향 그래프__ 의 \r\n    - 최대 간선 갯수 = V(V-1)\r\n\r\n## 🧷그래프의 종류\r\n\r\n> \r\n> 1. 무방향 그래프: 두 정점을 연결하는 간선에 방향이 없는 그래프이다.\r\n>\r\n> <img src=\"https://user-images.githubusercontent.com/63226023/168820953-4b4ea5a8-7471-4cd8-946f-b5948841f671.png\" width=\"30%\">\r\n>\r\n> 2. 방향 그래프: 두 정점을 연결하는 간선에 방향이 있는 그래프이다.\r\n>\r\n> <img src=\"https://user-images.githubusercontent.com/63226023/168822029-20a4c4a6-c0f5-40cc-bcef-2f94b55a6acd.png\" width=\"30%\">\r\n>\r\n> 3. 가중치 그래프: 두 정점을 이동할때 비용이 드는 그래프이다.\r\n>\r\n> <img src=\"https://user-images.githubusercontent.com/63226023/168822813-d547202b-de98-4a3b-9999-ebaab354ccc0.png\" width=\"30%\">\r\n>\r\n> 4. 완전 그래프: 모든 정점이 간선으로 연결되어 있는 그래프이다.\r\n>\r\n> <img src=\"https://user-images.githubusercontent.com/63226023/168822899-b5f6576f-30fa-47f3-b9a5-69c79250d875.png\" width=\"30%\">\r\n\r\n## 그래프의 구현 방법\r\n그래프를 구현하는 방법은 크게 __인접행렬(Adjacency Matrix)__, __인접리스트(Adjacency List)__ 방식이 있다.\r\n\r\n두 개의 구현 방식은 각각의 장단점이 있는데 대부분 `인접리스트` 방식을 많이 사용한다.\r\n\r\n### 인접행렬\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/169044528-8e425dd7-6a9e-4ab4-8e89-0a4955c2d296.png\">\r\n\r\n> 인접행렬은 그래프의 노드들을 __2차원 배열__ 로 나타내어, 하나의 정점이 다른 정점과 연결이 되어있으면 `1` 아니면 `0`을 넣어서 만들어 준다.\r\n\r\n장점\r\n1. __두 정점의 연결 정보__ 를 알고 싶을때 2차원 배열의 위치가 곧 연결 정보이기 때문에 O(1)의 시간복잡도로 알 수 있다.\r\n2. 구현이 비교적 간단하다.\r\n\r\n단점 \r\n1. 2차원 배열에 모든 정점에 대한 간선 정보를 넣어줘야 하므로 O(n²)의 시간복잡도가 소요된다.\r\n2. 2차원 배열을 사용하므로 필요 이상의 공간을 사용할 가능성이 있다.\r\n\r\n### 인접리스트\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/169202076-00adc01a-00c7-4123-9bf5-7e7cc35bb676.png\" width=\"50%\">\r\n\r\n> 인접리스트는 그래프의 노드간의 연결을 __리스트__ 로 나타내어, 각 1,2,3,4,5의 정점에 대한 리스트 배열을 만들어 관계를 설정해준다.\r\n\r\n장점\r\n1. __두 정점의 연결 정보__ 를 탐색할때 O(n) 시간복잡도로 알 수 있다.\r\n2. 필요한 연결정보만 리스트로 설정하여 사용하므로 공간 낭비가 적다.\r\n\r\n단점\r\n1. 특정 두 정점에 대한 열결 정보를 알고 싶다면 인접행렬에 비하여 느리다.\r\n\r\n# 최소 스패닝 트리\r\n> 🌳 최소 신장 트리(Minimum Spanning Tree)란\r\n> \r\n>   - 그래프의 __최소 연결 그래프__ -> __Spanning Tree__\r\n>   - __Spanning Tree__ 에서 간선(E)의 __가중치의 합이 최소__ 가 되는 트리 -> __Minimum Spanning Tree__\r\n\r\n## 크루스칼\r\n크루스칼 알고리즘은 __가중치가 있는무향 연결 그래프__ 가 주어질 때, 최소 스패닝 트리(MST)를 구하는 알고리즘이다. \r\n\r\n- __모든 간선__ 에 대하여 가중치가 적은 순서대로 정렬하여 __그리디 하게__ 뽑는다.\r\n- 가중치가 적은 순서대로 뽑아 두 정점이 `연결`되어 있지 않다면 두 정점을 `union`하여 연결한다.\r\n- 두 정점이 `연결`되었다는 것은 하나의 집합을 이루었다고 할 수 있다.\r\n- 최소 신장 트리를 구하기 위해서 같은 집합(사이클이 형성 되는지)에 속하는지에 대한 판별을 하는 과정이 필요하다.\r\n\r\n### Union & Find(합집합 찾기)\r\n사이클의 형성에 대한 판단으로 `Union & Find` 다른 말로 __서로소 집합(Disjoint-Set)__ 알고리즘이라고 한다.\r\n\r\n서로 다른 두 집합을 합치는 Union 연산, 알고 싶은 원소가 어느 집합에 포함되는지 찾는 Find 연산이라는 의미로 이름이 붙여졌다.\r\n\r\n아래의 예시는 Union & Find를 통하여 사이클의 형성을 알아보는 과정을 보여준다.\r\n\r\n> <img src=\"https://user-images.githubusercontent.com/63226023/169308331-f4c9356f-693b-41eb-b099-c4b95baf6fdc.png\">\r\n>\r\n> - 동작 과정\r\n> \r\n> 1. 모든 정점의 개수의 크기의 배열을 생성하여 자기자신으로 초기화 한다.\r\n> \r\n> 2. 두 노드간의 루트 노드(부모 노드)가 다르다면 -> 서로소 집합 -> Union 연산으로 두 노드를 연결해주고, 부모 노드를 바뀌준다. 같다면 사이클이 형성되므로 연결 불가능\r\n\r\n부모 노드를 찾는 Find 연산은 다음과 같다.\r\n\r\n```kotlin\r\n// 재귀적으로 쭉 찾기\r\nfun getParentNode(node: Int): Int {\r\n    return if (parentNode[node] == node) {\r\n        node\r\n    } else { // parent 노드가 자기자신이 아님 -> 연결된 부모가 있음\r\n        getParentNode(parentNode[node])\r\n    }\r\n}\r\n\r\n// 경로 압축\r\nfun getParentNode(node: Int): Int {\r\n    if (parentNode[node] != node) {\r\n        // 바로 갱신하는 동시에 재귀 호출\r\n        parentNode[node] = getParentNode(parentNode[node])\r\n    }\r\n    return parentNode[node]\r\n}\r\n```\r\n \r\n## 프림\r\n크루스칼과 마친가지로 최소 스패닝 트리(MST)를 구하는 알고리즘이다. 프림 알고리즘은 크루스칼과 다르게 임의의 정점을 시작점으로 잡는다. \r\n\r\n- __시작 정점__ 을 기준으로 가중치가 가장 작은 간선과 __연결된 정점__ 을 선택하여 트리를 확장해 가는 방식이다.\r\n- 각 정점들은 인접한 정점 중 __최소 비용 간선__ 인 정점을 선택하여 큐에 추가한다.\r\n- __우선순위 큐__ 를 이용하여 임의의 정점에서 인접한 정점의 __간선의 가중치를 기준으로 정렬__ 한다.\r\n- 가중치가 최소인 정점을 연결후 다시 인접한 정점을 넣고 정렬한다.\r\n\r\n> <img src=\"https://user-images.githubusercontent.com/63226023/169350972-12a2a1ff-416c-4b9e-a779-b62f757f03ee.png\">\r\n>\r\n> - 동작 과정\r\n> \r\n> 1. 임의의 정점에서 연결된 인접된 노드중 __가중치가 최소인 간선__ 을 선택한다.\r\n> \r\n> 2. 크루스칼과 마찬가지로 사이클 형성여부는 Union & Find 연산으로 확인한다.\r\n>\r\n> 3. 연결이 되었다면 선택된 간선에 연결된 정점 중에 __가중치가 최소인 간선__ 을 선택한다.(방문하지 않은 노드중)\r\n\r\n- - -\r\n\r\n# References\r\n\r\n- [https://ko.wikipedia.org/wiki/%ED%94%84%EB%A6%BC_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98](https://ko.wikipedia.org/wiki/%ED%94%84%EB%A6%BC_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)\r\n- [https://velog.io/@yuhyerin/%EA%B7%B8%EB%9E%98%ED%94%84%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98](https://velog.io/@yuhyerin/%EA%B7%B8%EB%9E%98%ED%94%84%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)"},{"excerpt":"Dynamic Programming(동적 프로그래밍) 동적 프로그래밍이란 주어진 문제를 부분 문제로 나누어 각 부분 문제의 답을 계산하고, 이 계산한 결과값을 이용해 원래 문제의 답을 산출 하는 방법이다. Divide And Conquer 동적 프로그래밍과 같이 큰 문제를 작은 문제로 나누는 알고리즘은 분할 정복(Divide And Conquer) 이 있…","fields":{"slug":"/dynamic-programming/"},"frontmatter":{"date":"May 13, 2022","title":"알고리즘 Dynamic Programming(동적 프로그래밍) 살펴보기","tags":["Algorithm","DP"]},"rawMarkdownBody":"# Dynamic Programming(동적 프로그래밍)\r\n동적 프로그래밍이란 __주어진 문제를 부분 문제로 나누어__ 각 부분 문제의 답을 계산하고, __이 계산한 결과값을 이용해 원래 문제의 답을 산출__ 하는 방법이다.\r\n\r\n## Divide And Conquer\r\n\r\n동적 프로그래밍과 같이 큰 문제를 작은 문제로 나누는 알고리즘은 __분할 정복(Divide And Conquer)__ 이 있다.\r\n> 📌분할 정복(Divide And Conquer)\r\n>\r\n> __Divide(분할):__ 주어진 문제를 부분 문제로 나눈다.\r\n>\r\n> __Conquer(정복):__ 작은 문제들을 더 이상 분할되지 않을때까지 __분할(recursion)__ 후 작은문제에 대한 답을 구한다.\r\n>\r\n> __Conbine(결합):__ 나누어진 작은 문제에 대한 정복된 답을 결합을 통하여 __원래의 문제에 대한 답을 구한다__\r\n\r\n> 🧷분할 정복은 주어진 문제를 작은 문제로 나누어 푸는 방식으로 __하향식(Top down)__ 접근 방법이다.\r\n\r\n- - -\r\n## Dynamic Programming\r\n\r\n동적 프로그래은 분할 정복과 다르게 __작은 문제가 반복__ 되는지에 대한 여부가 중요하다. 동적 프로그래밍은 작은 문제의 반복되는 값을 __메모를 해 놓았다가__ 다시 사용하여 푸는 방법이다.\r\n\r\n1. 동적 프로그래밍을 사용하기 위한 조건은 아래와 같다.\r\n> - 문제를 나누었을 때 작은 문제가 __반복적으로__ 일어나는 경우\r\n>\r\n> - 같은 나누어진 문제에 대한 __답이 항상 같을 경우__\r\n\r\n2. Memoization\r\n\r\n앞서 동적 프로그래밍은 __작은 문제가 반복되는 부분을 메모를 해 놓았다가 사용__ 한다고 하였다. 이를 Memoization이라고 표현 하며 배열을 통하여 저장할 공간을 생성한다.\r\n> 🧷Memoization: 계산한 결과를 저장하고 필요할때 다시 사용한다.\r\n\r\n# 피보나치\r\n동적 프로그래밍의 예시를 위하여 피보나치 수열을 보면 다음과 같다.\r\n\r\n> 피보나치 수: 첫 번째 및 두번 째 항이 1이며 그 뒤의 모든 항은 바로 앞 두 항의 합인 수열\r\n\r\n1. Recursion 사용\r\n\r\n```kotlin\r\nfun fibonacci(n: Int): Int {\r\n    if (n <=1) {\r\n        return n\r\n    }\r\n    return fibonacci(n - 1) + fibonacci(n - 2)\r\n    // fibonacci(7) -> 13\r\n}\r\n```\r\n피보나치 수열을 구하는 과정을 보면 아래와 같다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/168243379-d011f728-5ed4-4696-bfc0-193a44890949.png\">\r\n\r\n피보나치에서 F4까지만 보게되면 여기서도 이미 __F3은 3번, F4는 3번은 반복되어 사용__ 되는 것을 볼 수 있다.\r\n> Fibonacci(n) = Fibonacci(n-2) + Fibonacci(n-1)\r\n\r\n이를 동적 프로그래밍으로 `Memoization`을 사용하여 작은 문제에 대한 결과값을 저장하여 사용하면 아래와 같다.\r\n\r\n전역 변수 `memo`의 배열에서 값을 저장해두고 필요할 때 사용하여 값을 구한다.\r\n\r\n```kotlin\r\nval memo = IntArray(100) { 0 }\r\nfun fibonacci(n: Int): Int {\r\n    return if (n <= 1) {\r\n        memo[n] = n\r\n        memo[n]\r\n    } else {\r\n        if (memo[n] == 0) {\r\n            memo[n] = fibonacci(n - 1) + fibonacci(n - 2)\r\n        }\r\n        memo[n]\r\n    }\r\n    // fibonacci(7) -> 21\r\n}\r\n```\r\n- - -"},{"excerpt":"최근에 알고리즘의 풀이를 에서 로 바꾸며 진행해 나가면서 알고리즘 문제 풀이에서 많이 사용되는 정렬을 하는 방법 에 대해서 알아가보려고 한다. 리스트 기본 정렬 코틀린에서 리스트의 정렬은 다음과 같이 크게 , , 의 세가지 방법이 있다. 코틀린에서는 Immutable 과 Mutable 로 나뉜다. 여기서 Immutable(데이터의 변경이 불가능)에서는 함…","fields":{"slug":"/sort/"},"frontmatter":{"date":"May 10, 2022","title":"코틀린 리스트 정렬하는 방법 (sort vs sortBy vs sortWith)","tags":["Kotlin","Sort"]},"rawMarkdownBody":"<img src=\"https://user-images.githubusercontent.com/63226023/167560322-2806af0e-35ee-4323-be7d-f289948e24d5.png\">\r\n\r\n최근에 알고리즘의 풀이를 `자바언어`에서 `코틀린언어`로 바꾸며 진행해 나가면서 알고리즘 문제 풀이에서 많이 사용되는 __정렬을 하는 방법__ 에 대해서 알아가보려고 한다.\r\n\r\n- - -\r\n\r\n# 리스트 기본 정렬\r\n코틀린에서 리스트의 정렬은 다음과 같이 크게 `sort`, `sortBy`, `sortWith`의 세가지 방법이 있다.\r\n\r\n코틀린에서는 __Immutable__ 과 __Mutable__ 로 나뉜다. 여기서 Immutable(데이터의 변경이 불가능)에서는 함수의 끝에 __ed__ 로 끝난다.\r\n\r\n> - Mutable(데이터의 변경이 가능): `sort()`, `reverse()`\r\n>\r\n> - Immutable(데이터의 변경 불가능): `sorted()`, `reversed()`\r\n\r\n## sort(), sorted() / reverse(), reversed()\r\n\r\n> `sort()`는 __데이터의 변경이 가능한__ 리스트에 사용되며, `sort()`는 __리스트의 원형 변경하지 않고__, __리스트를 정렬된(오름차순) 리스트로 변경__ 합니다. \r\n\r\n```kotlin\r\nfun main() {\r\n    val mutablelist = mutableListOf(7, 2, 1, 10, 12, 5, 4)\r\n    mutablelist.sort()\r\n    println(\"MutableList: $mutablelist\")\r\n}\r\n```\r\n\r\n> `sorted()`는 __데이터의 변경이 불가능__ 한 리스트에 사용되며, `sorted()`는 __리스트의 원형 변경하지 않고__, __정렬된(오름차순) 리스트를 생성하여 반환__ 합니다. \r\n\r\n```kotlin\r\nfun main() {\r\n    val list = listOf(7, 2, 1, 10, 12, 5, 4)\r\n    val sortedlist = list.sorted()\r\n    println(\"List: $list\")\r\n    println(\"Sortedlist: $sortedlist\")\r\n    //    List: [7, 2, 1, 10, 12, 5, 4]\r\n    //    Sortedlist: [1, 2, 4, 5, 7, 10, 12]\r\n}\r\n```\r\n`reverse()`, `reversed()` 또한 위와 같은 방식으로 리스트를 __역순으로 정렬__ 한다.\r\n\r\n- `reverse()` : Mutable 리스트에 사용한다. __리스트를 역순으로 정렬을 시킨다__\r\n- `reversed()` : Immutable 리스트에 사용한다. __역순으로 변경된 리스트를 생성하고 반환 한다__\r\n\r\n- - -\r\n\r\n# 기본 정렬 -> sort(ed)By\r\n`sortBy()`는 리스트 요소가 1개 이상으로 있을때 어떤 요소를 기준으로 정렬을 할지 결정할 수 있다.\r\n\r\n아래의 예시에서 __Info__ 클래스에 대해서 __이름순으로__ 정렬을 하고자 하면 `sortBy`를 사용하면 된다.\r\n\r\n```kotlin\r\ndata class Info(\r\n    val name: String,\r\n    val count: Int,\r\n    val grade: Double\r\n)\r\n\r\nfun main() {\r\n    val list = listOf(\r\n        Info(\"B\", 8, 2.5),\r\n        Info(\"C\", 5, 3.0),\r\n        Info(\"E\", 1, 4.0),\r\n        Info(\"A\", 9, 3.5),\r\n        Info(\"A\", 9, 1.5),\r\n        Info(\"A\", 11, 1.5),\r\n    )\r\n\r\n    println(\"Name으로 정렬\")\r\n    list.sortedBy {\r\n        it.name\r\n    }\r\n    //    Name으로 정렬\r\n    //    Info(name=A, count=11, grade=3.5)\r\n    //    Info(name=A, count=9, grade=3.5)\r\n    //    Info(name=A, count=9, grade=1.5)\r\n    //    Info(name=B, count=8, grade=2.5)\r\n    //    Info(name=C, count=5, grade=3.0)\r\n    //    Info(name=E, count=1, grade=4.0)\r\n\r\n}\r\n``` \r\n# 기준이 2개 이상 -> sort(ed)With\r\n위의 예시에서는 Name으로 오름차순으로 정렬을 한것을 볼 수 있다. 여기서 새 프로퍼티 Count를 정렬 조건으로 추가하고 싶다면 `sortWith()`을 사용하면 된다. `sortWith()`는 인자로 Comparator를 구현하여 넘겨주게 된다.\r\n\r\n```kotlin\r\nfun main() {\r\n    val list = listOf(\r\n        Info(\"B\", 8, 2.5),\r\n        Info(\"C\", 5, 3.0),\r\n        Info(\"E\", 1, 4.0),\r\n        Info(\"A\", 11, 3.5),\r\n        Info(\"A\", 9, 3.5),\r\n        Info(\"A\", 9, 1.5),\r\n    )\r\n\r\n    println(\"Name으로 정렬후 Count으로 정렬\")\r\n    list.sortedWith(\r\n        compareBy<Info> {\r\n            it.name\r\n        }.thenBy {\r\n            it.count\r\n        }\r\n    )\r\n    //    Name으로 정렬후 Count으로 정렬\r\n    //    Info(name=A, count=9, grade=3.5)\r\n    //    Info(name=A, count=9, grade=1.5)\r\n    //    Info(name=A, count=11, grade=3.5)\r\n    //    Info(name=B, count=8, grade=2.5)\r\n    //    Info(name=C, count=5, grade=3.0)\r\n    //    Info(name=E, count=1, grade=4.0)\r\n    println(\"Name으로 정렬후 Count으로 정렬후 Grade로 정렬\")\r\n    list.sortedWith(\r\n        compareBy<Info> {\r\n            it.name\r\n        }.thenBy {\r\n            it.count\r\n        }.thenBy {\r\n            it.grade\r\n        }\r\n    )\r\n    //    Name으로 정렬후 Count으로 정렬후 Grade로 정렬\r\n    //    Info(name=A, count=9, grade=1.5)\r\n    //    Info(name=A, count=9, grade=3.5)\r\n    //    Info(name=A, count=11, grade=3.5)\r\n    //    Info(name=B, count=8, grade=2.5)\r\n    //    Info(name=C, count=5, grade=3.0)\r\n    //    Info(name=E, count=1, grade=4.0)\r\n}\r\n```\r\n\r\n# 정리\r\n> 정렬의 기본값은 __오름차순으로 정렬__ 이고 이는 `decending`을 통하여 __내림차순으로 정렬__ 이 가능하다.\r\n\r\n- Immutable(데이터의 변경이 불가능)\r\n    - *ed()를 사용: __정렬된 리스트를 생성하고 반환 한다.__\r\n- Mutable(데이터의 변경이 가능)\r\n    - *()를 사용: __현재 리스트를 정렬한다.__\r\n\r\n> - __기본정렬__ : sort(오름차순), reverse(역순), *Decending(내림차순)\r\n> - __sortBy, sortByDecending__ : 리스트 요소가 1개 이상일때 > 어떤 요소를 기준으로 정렬을 할지 결정할 수 있다.\r\n>\r\n>\r\n> - __sortWith, sortWithDescending__ : 기준이 2개이상으로 정렬을 하려고자 할때 사용이 가능하다.\r\n>     - `compareBy`, `compareByDescending`: Comparator를 사용하여 정렬기준을 정한다.\r\n>     - `thenBy`, `thenByDecending`: compareBy에 이어서 정렬기준을 정할때 사용한다."},{"excerpt":"그래프에서는 와 방식으로 모든 정점을 탐색한다. 그래프는 따로 파트를 나누어 학습을 하고 이번 포스팅은 그래프의 탐색 방법의 기본이 되는 와 에 대해서 정리하려고 한다.🤔 깊이 우선 탐색(DFS, Depth-First Search) 🧷DFS는 미로에서 출구를 찾는것과 비슷하다고 볼 수 있다. 하나의 길을 갈때 쭉 진행하다가 길이 막히면 왔던길을 되돌아 가…","fields":{"slug":"/dfs-bfs/"},"frontmatter":{"date":"May 04, 2022","title":"알고리즘 DFS/BFS 탐색 방법 알아보기","tags":["Algorithm","DFS","BFS"]},"rawMarkdownBody":"그래프에서는 `DFS`와 `BFS`방식으로 모든 정점을 탐색한다. 그래프는 따로 파트를 나누어 학습을 하고 이번 포스팅은 그래프의 탐색 방법의 기본이 되는 `DFS`와 `BFS`에 대해서 정리하려고 한다.🤔\r\n\r\n# 깊이 우선 탐색(DFS, Depth-First Search)\r\n\r\n<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/166437047-03f6e094-c080-45d4-a98c-3754cd5f1a2d.png\" width=\"70%\"></p>\r\n\r\n>🧷DFS는 미로에서 출구를 찾는것과 비슷하다고 볼 수 있다. 하나의 길을 갈때 쭉 진행하다가 __길이 막히면 왔던길을 되돌아 가__ 다시 안가본 길을 탐색하여 모든 경로를 탐색한다.\r\n\r\n- 그래프에서의 DFS는 임의의 정점에서 시작하여 이웃하는 하나의 정점을 방문을 한다.\r\n- 방금 방문한 정점의 이웃하는 정점을 방문한다.\r\n- 이웃하는 정점들을 다 방문을 하였다면, 이전 정점으로 되돌아가 다시 탐색을 한다.\r\n\r\nDFS는 아래와 같은 특징들이 있다.\r\n1. DFS는 `Deep(깊게)` 탐색하는 방법이다.\r\n2. 모든 노드를 방문을 하고자 할때 이 방법을 선택한다.\r\n3. 검색속도는 BFS보다 보다 느리다.\r\n4. DFS는 `Stack` 또는 `재귀함수`로 구현할 수 있다.\r\n\r\n## DFS의 구현\r\nDFS에서는 정점의 방문여부를 체크하기 위하여 `visited` 배열을 두어 확인한다. 재귀함수로 DFS의 구현은 아래와 같이 할 수 있다.\r\n\r\n1. 재귀함수를 사용한 DFS 구현\r\n\r\n```java\r\nimport java.util.Arrays;\r\nimport java.util.LinkedList;\r\n\r\nclass Graph_Recursion {\r\n    int N;\t// 그래프의 정점의 수\r\n    LinkedList<Integer> list[];\r\n    private boolean[ ] visited;\t// DFS 수행 중 방문한 정점을 true로 만든다.\r\n\r\n    public Graph_Recursion(int N) {\r\n        this.N = N;\r\n        list = new LinkedList[N];\r\n        for (int i = 0; i < N ; i++) {\r\n            list[i] = new LinkedList<>();\r\n        }\r\n        visited = new boolean[N];\r\n        Arrays.fill(visited, false); // 배열 초기화\r\n    }\r\n\r\n    public void addEdge(int source, int destination){\r\n        list[source].add(destination);\r\n        list[destination].add(source);\r\n    }\r\n\r\n    private void dfs(int start) {\r\n        for (int i = start; i < N; i++) {\r\n            if (!visited[start]) {\r\n                System.out.print(i + \" \");\r\n                visited[start] = true; // 점점 start를 방문함\r\n                for (Integer node: list[start]) {\r\n                    if (!visited[node]) {\r\n                        dfs(node);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void printGraph(){\r\n        for (int i = 0; i < N ; i++) {\r\n            LinkedList<Integer> nodeList = list[i];\r\n            if(!nodeList.isEmpty()) {\r\n                System.out.print(\"Node = \" + i + \" is connected to nodes: \");\r\n                for (Integer node : nodeList) {\r\n                    System.out.print(\" \" + node);\r\n                }\r\n            }\r\n            System.out.println();\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Graph_Recursion graph = new Graph_Recursion(6);\r\n        graph.addEdge(0, 1);\r\n        graph.addEdge(0, 2);\r\n        graph.addEdge(1, 3);\r\n        graph.addEdge(1, 4);\r\n        graph.addEdge(4, 5);\r\n        graph.printGraph();\r\n        System.out.print(\"Depth First Traversal: \");\r\n        graph.dfs(0);\r\n    }\r\n}\r\n```\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/166632872-26c637e2-20d3-4246-a811-dece85be60a7.png\r\n\">\r\n\r\nDFS의 또 다른 구현은 `Stack`을 이용하는 것이다. DFS는 `Deep(깊게)` 탐색을 먼저하였다가 다시 이전 노드의 이웃한 노드를 확인하는 방법이므로 __Stack의 Last In First Out 구조__ 를 사용하여 구현이 가능하다.\r\n\r\n2. stack을 이용한 DFS 구현 (printGraph, addEdge 동일)\r\n\r\n```java\r\nclass Graph_Stack {\r\n    int N;\r\n    LinkedList<Integer> list[];\r\n    Stack<Integer> stack;\r\n    private boolean[] visited; // DFS 수행 중 방문한 정점을 true로 만든다.\r\n\r\n    public Graph_Stack(int N) {\r\n        this.N = N;\r\n        stack = new Stack();\r\n        list = new LinkedList[N];\r\n        for (int i = 0; i < N ; i++) {\r\n            list[i] = new LinkedList<>();\r\n        }\r\n        visited = new boolean[N];\r\n        Arrays.fill(visited, false); // 배열 초기화\r\n    }\r\n\r\n    private void dfs(int start) {\r\n        System.out.print(\"Depth First Traversal: \");\r\n        // 시작 노드\r\n        stack.push(start);\r\n        while (!stack.isEmpty()) {\r\n            int node = stack.pop();\r\n            if (!visited[node]) {\r\n                System.out.print(node + \" \");\r\n                visited[node] = true; // 점점 node를 방문함\r\n                LinkedList<Integer> adjList = list[node]; // 인접한 노드들 리스트\r\n                for (int adjNode : adjList) {\r\n                    // 인접한 노드를 탐색 안했다면 탐색\r\n                    if (!visited[adjNode]) {\r\n                        stack.push(adjNode);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Graph_Stack graph = new Graph_Stack(6);\r\n        graph.addEdge(0, 2);\r\n        graph.addEdge(0, 1);\r\n        graph.addEdge(1, 4);\r\n        graph.addEdge(4, 5);\r\n        graph.addEdge(1, 3);\r\n        graph.printGraph();\r\n        graph.dfs(0);\r\n    }\r\n}\r\n```\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/166635949-38f397e5-19bf-4dda-9362-54c3e9eb431b.png\">\r\n\r\n# 너비 우선 탐색(BFS, Breadth First Search)\r\n\r\n<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/166434137-0249dea4-891f-4362-9dac-79f5a0209781.png\" width=\"70%\"></p>\r\n\r\n>🧷BFS는 물이 퍼지는것과 같이 주변부터 진행하면서 모든 경로를 탐색한다.\r\n\r\n- 그래프에서의 BFS는 임의의 정점에서 시작하여 이웃하는 정점을 방문을 한다.\r\n- 방문하기 이전의 정점에서 또 다른 이웃하는 정점을 방문을 한다.\r\n- 모든 이웃하는 정점을 방문을 하면 다시 전에 방문한 노드의 이웃한 노드를 방문 하여 탐색을 한다.\r\n\r\nBFS는 아래와 같은 특징들이 있다.\r\n1. BFS는 `Wide(넓게)` 탐색하는 방법이다.\r\n2. 주로 두 노드 사이의 최단 경로를 찾고 싶을 때 사용한다.\r\n3. DFS는 `Queue`로 구현은 한다.\r\n\r\n\r\n## BFS의 구현\r\n\r\nBFS는 `Wide(넓게)` 탐색을 하는 방법으로 __Queue의 First In First Out 구조__ 를 사용하여 구현이 가능하다.\r\n\r\n\r\n1. Queue를 이용한 BFS 구현 (printGraph, addEdge 동일)\r\n\r\n```java\r\nimport java.util.Arrays;\r\nimport java.util.LinkedList;\r\nimport java.util.Queue;\r\n\r\nclass Graph {\r\n    int N;  // 그래프의 정점의 수\r\n    LinkedList<Integer> list[];\r\n    Queue<Integer> queue;\r\n    private boolean[] visited;    // DFS 수행 중 방문한 정점을 true로 만든다.\r\n\r\n    public Graph(int N) {\r\n        this.N = N;\r\n        list = new LinkedList[N];\r\n        queue = new LinkedList<>();\r\n        for (int i = 0; i < N; i++) {\r\n            list[i] = new LinkedList<>();\r\n        }\r\n        visited = new boolean[N];\r\n        Arrays.fill(visited, false); // 배열 초기화\r\n    }\r\n\r\n    public void bfs(int start) {\r\n        System.out.print(\"Breadth First Search: \");\r\n        // 시작 노드\r\n        queue.offer(start);\r\n        visited[start] = true;   // 점점 node를 방문함\r\n        // bfs 탐색\r\n        while (!queue.isEmpty()) {\r\n            int node = queue.poll();\r\n                System.out.print(node + \" \");\r\n                LinkedList<Integer> adjList = list[node];   // 인접한 노드들 리스트\r\n                for (int adjNode: adjList) {\r\n                    // 인접한 노드들을 방문하지 않았으면 다 방문 체크 -> Wide하게 탐색 -> BFS\r\n                    if (!visited[adjNode]) {\r\n                        queue.offer(adjNode);\r\n                        visited[adjNode] = true;\r\n                    }\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Graph graph = new Graph(6);\r\n        graph.addEdge(0, 1);\r\n        graph.addEdge(0, 2);\r\n        graph.addEdge(1, 3);\r\n        graph.addEdge(1, 4);\r\n        graph.addEdge(4, 5);\r\n        graph.printGraph();\r\n        graph.bfs(0);\r\n    }\r\n}\r\n```\r\n\r\n# References\r\n- [https://velog.io/@lucky-korma/DFS-BFS%EC%9D%98-%EC%84%A4%EB%AA%85-%EC%B0%A8%EC%9D%B4%EC%A0%90](https://velog.io/@lucky-korma/DFS-BFS%EC%9D%98-%EC%84%A4%EB%AA%85-%EC%B0%A8%EC%9D%B4%EC%A0%90)\r\n- [https://lemidia.github.io/algorithm/DFS-Implementation-stack/](https://lemidia.github.io/algorithm/DFS-Implementation-stack/)"},{"excerpt":"그리디(탐욕) 알고리즘에서 그리디(탐욕법) 알고리즘이란 이름에서 유추해 볼 수 있듯이 현재 상황에서 가장 최선의 선택 을 하는 알고리즘을 말한다. 매 순간마다 하는 선택은 그 순간에 대해 으로는 최적이지만, 그 선택들을 계속 수집하여 최종적()인 해답을 만들었다고 해서, 그것이 최적의 해답이라는 보장은 없다.  하지만 그리디 알고리즘을 적용할수 있는 문제…","fields":{"slug":"/greedy/"},"frontmatter":{"date":"April 24, 2022","title":"그리디 알고리즘(Greedy Algorithm)에 대해","tags":["Algorithm","Greedy"]},"rawMarkdownBody":"<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/164942840-d52e6623-5973-4c16-99ef-3da83ce1e9ab.png\"></p>\r\n\r\n- - -\r\n# 그리디(탐욕)\r\n알고리즘에서 그리디(탐욕법) 알고리즘이란 이름에서 유추해 볼 수 있듯이 __현재 상황에서 가장 최선의 선택__ 을 하는 알고리즘을 말한다.\r\n\r\n매 순간마다 하는 선택은 그 순간에 대해 `지역적`으로는 최적이지만, 그 선택들을 계속 수집하여 최종적(`전역적`)인 해답을 만들었다고 해서, 그것이 최적의 해답이라는 보장은 없다. \r\n\r\n하지만 그리디 알고리즘을 적용할수 있는 문제들은 `지역적`으로 최적이면 `전역적`으로 최적인 문제들이다. \r\n- - -\r\n\r\n# 어떤 경우에 잘 작동하는가?\r\n> 🎯그리디 알고리즘이 적용되기 위해서는 아래와 같은 조건이 만족되야 한다.\r\n\r\n- 탐욕스런 선택 조건\r\n- 최적 부분 구조 조건\r\n\r\n> 📍탐욕스런 선택 조건(greedy choice property)은 __앞의 선택이 이후의 선택에 영향을 주지 않는다__ 는 것이다.\r\n>\r\n> 📍최적 부분 구조 조건(optional substructure)은 __문제에 대한 최적해__ 가 __부분 문제에 대해서도 최적해라는 것__ 이다.\r\n\r\n- - -\r\n# 거스름돈 문제🪙\r\n그리디 문제중에서 거스름돈 문제가 있다. 어떤 금액에 대해 거스름돈을 받을때, 동전을 최소의 개수로 받는 문제이다.\r\n\r\n단, 거스름돈 문제가 항상 __그리디 알고리즘__ 으로 해결되는 것은 아니다.   \r\n우리의 실생활에서의 동전은 10, 50, 100, 500원 이 있지만, 문제에서 다음과 같이 냈다고 하자.\r\n\r\n> 거스름돈 14원을 주려고한다. 동전은 1, 6, 10원이 있다고하자.\r\n\r\n위의 문제를 그리디 알고리즘을 적용하면 __가장 큰 단위의 동전을 선택하여 거스롬든을 주자__ 로 생각해 볼 수 있고 구하는 해는 10원, 1원 * 4 -> 5가지가 된다. 반면에 최소의 개수는 6원 * 2, 1원 * 2 -> 4가지이다.\r\n\r\n이 거스름돈 문제가 그리디 알고리즘이 적용되기 위해서는 __각각의 거스름돈이 서로의 배수/약수의 관계__ 가 되어야 한다. 따라서 실생활에 사용되는 동전으로 이루어진 거스름돈 문제는 그리디 알고리즘이 적용이 가능하다.\r\n\r\n> (500원 = 100원 5개, 100원 = 50원 2개, 50원 = 10원 5개) -> 작은 단위 동전을 조합하여 다른 해가 나올 수 없기 때문에 그리디 알고리즘 사용이 가능하다.\r\n\r\n이렇게 그리디 알고리즘을 적용하기 위해서는 문제의 요구사항을 파악하고 위에서 적용되는 조건을 확인하는것이 중요하다.🤔\r\n- - -\r\n# References\r\n\r\n- [https://ko.wikipedia.org/wiki/탐욕_알고리즘](https://ko.wikipedia.org/wiki/%ED%83%90%EC%9A%95_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)\r\n- [https://ujink.tistory.com/10](https://ujink.tistory.com/10)"},{"excerpt":"Scope Function 코틀린에서는 기본적으로 \"표준 스코프 함수\" 라는것을 제공한다. 스코프 함수들을 사용하여 기존의 복잡한 코드를 단순화하고 효율적으로 만들 수 있다. 스코프 함수를 람다식으로 사용을 하게되면 일시적인 Scope(범위)가 형성 되고, 이 범위 안에서는 객체에 대해서 일일이 참조하지 않고 객체에 대한 접근 을 하여 사용할 수 있다. …","fields":{"slug":"/scope-function/"},"frontmatter":{"date":"April 20, 2022","title":"코틀린의 Scope Function는 언제쓸까","tags":["Kotlin","Scope Function"]},"rawMarkdownBody":"# Scope Function\r\n코틀린에서는 기본적으로 __\"표준 스코프 함수\"__ 라는것을 제공한다.   \r\n스코프 함수들을 사용하여 기존의 복잡한 코드를 단순화하고 효율적으로 만들 수 있다.\r\n\r\n스코프 함수를 __람다식으로 사용을 하게되면 일시적인 Scope(범위)가 형성__ 되고, 이 범위 안에서는 __객체에 대해서 일일이 참조하지 않고 객체에 대한 접근__ 을 하여 사용할 수 있다.\r\n\r\n코틀린에서 제공하는 스코프 함수들은 `let`, `also`, `with`, `run`, `apply`로 5가지로 이루어져 있다.   \r\n각 키워드에 대해서 단어의 의미를 보면 어렴풋이 어떠한 기능을 할 것이다라는 감은 오지만 __역할이나 수행하는 기능들이 비슷하여__ 어떤 상황에 알맞은 스코프 함수를 써야하는지 __헷갈리게 된다.__(지금상태..😨)\r\n\r\n최근에 안드로이드 프로젝트에서 스코프 함수를 사용하고 있지만 명확한 차이점을 알지못하고 제대로 사용하고 있나? 라는 의문이 생겨 이번 포스팅을 통하여 각각의 차이점, 특징들을 정리하려고 한다.\r\n\r\n## let\r\n> fun <T, R> T.let(block: (T) -> R): R\r\n\r\n`let` 함수는 제네릭으로 매개변수화된 타입 T의 확장 함수이다. 따라서 __자기자신을 인수로 전달하고 수행된 결과(블록의 마지막 값)를 반환__ 하며, 인수로 전달한 객체의 참조는 __it__ 으로 참조를 한다.\r\n\r\n```kotlin\r\ndata class Person(var name: String, var favorite: String)\r\n\r\nfun main() {\r\n    val person1 = Person(\"페퍼\", \"Dr pepper\")\r\n    person1.let {\r\n        println(\"이름: ${it.name}, 좋아하는것: ${it.favorite}\")\r\n    }\r\n    // 이름: 페퍼, 좋아하는것: Dr pepper\r\n\r\n    val person2 = person1.let {\r\n        it.name = \"준후\"\r\n        it.favorite = \"닥터페퍼\"\r\n        \"이름: ${it.name}, 좋아하는것: ${it.favorite}\"    // (T) -> R 부분에서의 반환값\r\n    }\r\n    println(person2)\r\n    // 이름: 준후, 좋아하는것: 닥터페퍼\r\n}\r\n```\r\n안드로이드에서 let은 `T?.let{ }`(safe call)의 형태로 let 블록안에 __not-null__ 만 들어올 수 있어 null 체크 시에 유용하게 쓰인다. \r\n\r\n```kotlin\r\nval response = // 서버로부터 데이터 요청\r\n        if (response.isSuccessful) {\r\n            // body()가 null이 아니라면 실행\r\n            // it -> result라는 이름의 인자로 바꾸어 사용가능\r\n            response.body()?.let { result ->\r\n                return // Something\r\n            }\r\n        }\r\n```\r\n\r\n## also\r\n> fun <T> T.also(block: (T) -> Unit): T\r\n\r\n`also`는 언듯보면 `let`과 역할이 거의 동일해 보인다. 하지만 반환값을 보면 __T__ 라는 것으로 조금 다른데, __let은 마지막으로 수행된 코드 블록의 결과를 반환__ 하고 __also는 블록 안의 코드와 상관없이 T인 객체를 반환__ 한다.\r\n\r\n```kotlin\r\nval person2 = person.let {\r\n    it.name = \"준후\"\r\n    it.favorite = \"닥터페퍼\"\r\n    \"이름: ${it.name}, 좋아하는것: ${it.favorite}\"    // (T) -> R 부분에서의 반환값\r\n}\r\nprintln(person2)\r\n// 이름: 준후, 좋아하는것: 닥터페퍼\r\n\r\nval person3 = person.also {\r\n    it.name = \"준후\"\r\n    it.favorite = \"닥터페퍼\"\r\n    \"이름: ${it.name}, 좋아하는것: ${it.favorite}\"    // 무시\r\n}\r\nprintln(person3)\r\n// Person(name=준후, favorite=닥터페퍼) -> T인 person 객체 반환\r\n```\r\n\r\n## with\r\n> fun <T, R> with(receiver: T, block: T.() -> R): R\r\n\r\n`with`는 다른 스코프 함수들과 다르게 __일반 함수__ 이다. 따라서 __객체 receiver를 직접 입력__ 받고 `receiver`로 객체를 입력 받으면 , `this` 키워드 없이 __객체의 속성__ 을 변경할 수 있다.\r\n\r\n`with`는 `not-null`객체를 이용하여 사용하고, 블록의 반환값이 필요하지 않을 때 사용한다.\r\n\r\n주로 `with`는 __객체의 함수나 속성을 여러개 호출할 때 그룹화__ 하는 용도로 많이 활용한다.\r\n\r\n```kotlin\r\nbinding.userId.text~\r\nbinding.userpwd.text~\r\n\r\n// 주로 안드로이드에서 view binding을 사용할때 with사용\r\nwith(binding) {\r\n    userId.text ~~\r\n    userpwd.text ~\r\n}\r\n```\r\n\r\n## run\r\n`run`은 두 가지 형태로 선언이 되어 있는데, 첫 번째는 아래와 같다.\r\n> fun <T, R> T.run(block: T.() -> R): R\r\n\r\n`run`은 with와 유사하지만 T의 확장함수라는 점에서 차이가 있다. 또한 확장함수 이기때문에 `T?.`(safe call)을 사용하면 __null 객체가 들어와도 not-null을 체크하고 실행__ 이 가능하다. \r\n\r\n`run`은 __어떤 값을 계산할 필요__ 가 있거나, __여러 개의 지역변수 범위를 제한__ 하고자 할 때 사용한다.\r\n\r\n```kotlin\r\nval favorite = person.run {\r\n    // person을 수신객체로 변환하여 favorite 값을 사용\r\n    println(\"가장좋아하는것: $favorite\")\r\n    favorite.plus(\" 존맛탱!!\")     // run은 마지막 실행문의 결과를 반환\r\n}\r\nprintln(\"가장좋아하는것: $favorite\")\r\n// 가장좋아하는것: 닥터페퍼\r\n// 가장좋아하는것: 닥터페퍼 존맛탱!!\r\n}\r\n```\r\n두 번째 선언 방식은 아래와 같다.\r\n> fun <R> run(block: () -> R): R\r\n\r\n이 `run`은 __확장함수도 아니고, 블록에 대한 입력값도 없다.__ 따라서 객체를 전달 받고 속성을 이용할때 사용하는 함수가 아니고, __어떤 객체를 생성하기 위한 명령문들을 하나로 묶음으로써 가독성을 높이는 역할을 한다.__\r\n\r\n```kotlin\r\nval person = run {\r\n    val name = \"ppeper\"\r\n    val favorite = \"닥터페퍼\"\r\n    Person(name, favorite) // Return\r\n}\r\n```\r\n이렇게 사용한다면 Person() 객체 가 `person`에 담기게 된다.\r\n\r\n## apply\r\n> fun <T> T.apply(block: T.() -> Unit): T\r\n\r\n`apply`는 T의 확장함수로 run과 유사하지만 반환값을 받지않고 객체 T를 반환한다는 점이 다르다. 따라서 apply는 이름에서 느낄수 있듯이, __새로운 인스턴스를 생성하고 특정 변수에 할당하기 전__ 에 __초기화 작업__ 을 하거나 변경할때 사용한다. 따라서 앞서 설명한 것처럼 `apply` 스코프 내에 모든 명령을 수행하여 적용된 새로운 인스턴스가 (T) 반환 한다는 특징이 있다.\r\n\r\n```kotlin\r\nval person = Person(\"\", \"\")\r\nperson.apply {\r\n    name = \"ppeper\"\r\n    favorite = \"닥터페퍼\"\r\n}\r\nprintln(\"$person\")\r\n// Person(name=ppeper, favorite=닥터페퍼)\r\n``` \r\n- - -\r\n\r\n# References\r\n- [https://blog.yena.io/studynote/2020/04/15/Kotlin-Scope-Functions.html](https://blog.yena.io/studynote/2020/04/15/Kotlin-Scope-Functions.html)"},{"excerpt":"Repository 이전의 포스팅에서 안드로이드 MVVM 디자인 패턴에 대해서 알아보면서 아주 잠깐 Repository의 개념 대해서 알아보았다. 이번에 새로운 프로젝트에 Repository를 적용하면서 공부하였던 내용들을 정리해 보려고 한다. 단어의 의미보면 파악할 수 있듯이 Repository는 필요한 데이터들을 저장하고 있는 저장소라고 생각하면 된다…","fields":{"slug":"/repository-pattern/"},"frontmatter":{"date":"April 19, 2022","title":"안드로이드 Repository 패턴은 무엇인가","tags":["Android","MVVM","Repository Pattern"]},"rawMarkdownBody":"<img src=\"https://user-images.githubusercontent.com/63226023/151594101-266890b7-079a-47c5-9daa-2afbc335ccb7.png\">\r\n\r\n# Repository\r\n이전의 포스팅에서 안드로이드 [MVVM 디자인 패턴](https://ppeper.github.io/android/android-acc/)에 대해서 알아보면서 아주 잠깐 Repository의 개념 대해서 알아보았다. 이번에 새로운 프로젝트에 Repository를 적용하면서 공부하였던 내용들을 정리해 보려고 한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/163725815-0dc509ff-346b-4f7f-bc4f-cc407c2b2f8d.png\">\r\n\r\n단어의 의미보면 파악할 수 있듯이 Repository는 필요한 데이터들을 저장하고 있는 저장소라고 생각하면 된다. 그러면 안드로이드에서는 Repository가 어떻게 사용되는가??\r\n\r\n## 안드로이드 아키첵처 컴포넌트\r\n<img src=\"https://user-images.githubusercontent.com/63226023/163726014-6b6a0c25-1d70-47d2-ac4f-37f3972c5549.png\">\r\n\r\n위의 그림이 안드로이드에서 권장하는 아키텍처이다. 위 다이어그램을 보면 아키텍처의 Activity / Fragment 즉 UI 레이어에서 직접 Data에 접근하지 않고 __Repository__ 를 통하여 데이터를 가지고 오는것을 볼 수 있다.\r\n\r\nRepository는 UI에서 사용할 데이터들을 가져올 수 있도록 접근하는 __LocalDataSource(앱 내부 데이터 ex)Room)__, __RemoteDataSource(서버데이터 ex)Retrofit)__ 을 캡슐화하여 사용하는 것이다.\r\n\r\n> Repository는 데이터의 출처(local/remote)와 상관없이 동일한 인터페이스로 데이터에 접근할 수 있도록 만든것이다.\r\n\r\n## Repository 패턴을 사용하는 이유?\r\n이전에 안드로이드에서 MVC패턴으로 개발을 하게되면 View(Activity/Fragment)에 모든 코드를 작성을 하여 많은 단점들이 존재하였었다.\r\n\r\n> View와 Model사이에 의존성이 발생하여 View의 UI 갱신을 위해 Model을 직/간접적으로 참조하여 Activity/Frament의 크기가 커지고 로직들이 복잡해 질 수록 유지보수가 힘들어진다.(처음 안드로이드 프로젝트를 진행하였을때 이러한 문제에 직면하였었다..😅)\r\n\r\n그렇다면 Repository 패턴을 사용하게 되면 얻는 이점은 무었일까?\r\n\r\n- 도메인과 연관된 모델을 가져오기 위해서 필요한 DataSource가 Presenter 계층에서는 알 필요가 없다(필요한 DataSource가 몇개든 사용될 data만 가져오면 된다)\r\n   - 따라서 DataSource를 새롭게 추가하는 것도 부담이 없다.\r\n- DataSource 의 변경이 되더라도 다른 계층에는 영향이 없다.\r\n- Client는 Repository 인터페이스에 의존하기 때문에 테스트 하기 용이하다.\r\n\r\n> 🔔 Repository는 결국 Presenter 계층과 Data 계층간의 Coupling을 느슨하게 만들어 주는것이다.\r\n\r\nRepository 패턴을 사용한다는 것은 DataSource 즉, Data Layer를 `캡슐화`한다는 의미이다.\r\n\r\nRepository를 추가하여 View에서 데이터를 참조하는 흐름을 보면 다음과 같다. \r\n\r\n> 1. __View -> ViewModel로만 데이터를 가져온다.__ \r\n>\r\n> 2. __ViewModel -> Repository로 데이터 접근한다.__\r\n>\r\n> 3. __Repository -> DataSource(local/remote)로 부터 데이터를 요청한다.__\r\n\r\n- - -\r\n\r\n앱에서 회원가입을 구현 해야한다고 했을때 Repository 패턴을 적용하여 요청을 보내는 예시를 보면 다음과 같다.(Hilt 의존성 주입 사용)\r\n\r\n> 먼저 UserRemoteDataSource로 부터 서버로 회원가입 요청을 보내는 함수를 만들어준다.\r\n\r\n```kotlin\r\n// 서버로 부터 데이터 요청하는 class 인터페이스화\r\ninterface UserRemoteDataSource {\r\n    suspend fun signInUser(user: User): Response<ResponseUser>\r\n    .\r\n    .\r\n}\r\n\r\n// 인터페이스 UserRemoteDataSource를 구체화할 Impl 클래스\r\nclass UserRemoteDataSourceImpl(\r\n    private val userService: UserService\r\n): UserRemoteDataSource {\r\n    override suspend fun signInUser(user: User): Response<ResponseUser> {\r\n        return userService.signInUser(user)\r\n    }\r\n    .\r\n    .\r\n}\r\n```\r\n\r\n> UserRepository는 UserRemoteDataSource를 참조하여 서버로 회원가입 요청을 보낸다.\r\n\r\n```kotlin\r\ninterface UserRepository {\r\n    suspend fun signInUser(user: User): APIResponse<ResponseUser>\r\n    .\r\n    .\r\n}\r\n\r\nclass UserRepositoryImpl(\r\n    private val userRemoteDataSource: UserRemoteDataSource\r\n): UserRepository {\r\n    // 회원가입 요청이 성공하면 Success에 데이터를 실어서 ,실패하면 Error에 message 리턴\r\n    override suspend fun signInUser(user: User): APIResponse<ResponseUser> {\r\n        val response = userRemoteDataSource.signInUser(user)\r\n        if (response.isSuccessful) {\r\n            response.body()?.let { result ->\r\n                return APIResponse.Success(result)\r\n            }\r\n        }\r\n        return APIResponse.Error(response.message())\r\n    }\r\n    .\r\n    .\r\n}\r\n```\r\n\r\n Retrofit으로 서버의 요청에 대한 응답을 받으면 return값을 `APIResponse` 를 통하여 State와 data를 매핑해 주었다.\r\n\r\n```kotlin\r\nsealed class APIResponse<T>(\r\n    val data: T? = null,\r\n    val message: String? = null\r\n) {\r\n    class Success<T>(data: T? = null): APIResponse<T>(data)\r\n    class Loading<T>(data: T? = null): APIResponse<T>(data)\r\n    class Error<T>(message: String, data: T? = null): APIResponse<T>(data, message)\r\n}\r\n```\r\n\r\n> UserViewModel은 UserRepository만을 이용해서 데이터에 접근하고 LiveData를 관찰하는 observer에게 값을 넘겨준다.\r\n\r\n```kotlin\r\n@HiltViewModel\r\nclass UserViewModel @Inject constructor(\r\n    private val repository: UserRepository\r\n): ViewModel() {\r\n\r\n    // request state\r\n    val state: MutableLiveData<APIResponse<ResponseUser>> = MutableLiveData()\r\n\r\n   fun signInUser(user: User) {\r\n       // 서버의 요청에대한 response가 오기전에는 Loading 상태\r\n       state.value = APIResponse.Loading()\r\n       viewModelScope.launch(Dispatchers.IO)  {\r\n           val response = repository.signInUser(user)\r\n           try {\r\n               if (response.data != null) {\r\n                   state.postValue(response)\r\n               } else {\r\n                   state.postValue(APIResponse.Error(response.message.toString()))\r\n               }\r\n           } catch (e: Exception) {\r\n               state.postValue(APIResponse.Error(e.message.toString()))\r\n           }\r\n       }\r\n   }\r\n   .\r\n   .\r\n}\r\n```\r\n\r\n> 사용할 Activity에서 직접 서버로 요청을 하지 않고 UserViewModel을 사용하여 회원가입을 요청(requestSignIn)하고 LiveData를 observe한다.\r\n\r\n```kotlin\r\n@AndroidEntryPoint\r\nclass LogInActivity : AppCompatActivity() {\r\n    private val userViewModel: UserViewModel by viewModels()\r\n    private lateinit var binding: ActivityLogInBinding\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        binding = ActivityLogInBinding.inflate(layoutInflater)\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(binding.root)\r\n\r\n\r\n        with(binding) {\r\n            // 로그인 요청\r\n            buttonLogin.setOnClickListener {\r\n                // user의 input 값이 들어갔다고 가정\r\n                    val userLogin =\r\n                        UserLogin(editTextLoginId.text.toString(), editTextLoginPwd.text.toString())\r\n                    requestLogin(userLogin)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun requestLogin(userLogin: UserLogin) {\r\n        userViewModel.getTokenRequest(userLogin)\r\n        userViewModel.isLogin.observe(this@LogInActivity, Observer { response ->\r\n            when (response) {\r\n                is APIResponse.Success -> {\r\n                    // success code\r\n                }\r\n                is APIResponse.Error -> {\r\n                    // error code\r\n                }\r\n                is APIResponse.Loading -> {\r\n                    // loading code\r\n                }\r\n            }\r\n        })\r\n    }\r\n}\r\n```\r\n\r\n- - -\r\n# References \r\n- [https://vagabond95.me/posts/android-repository-pattern/](https://vagabond95.me/posts/android-repository-pattern/)"},{"excerpt":"완전탐색이란? 완전탐색이란 가능한 모든 경우의 수 를 모두 찾는 방법이다. 이러한 방법은 무식한 한다는 의미로 'Brute Force'라고도 이름이 불린다. 완전탐색은 직관적이어서 이해하기 쉽고, 문제에 대한 결과값이 정확하게 얻을 수 있다 는 점에서 가장 확실하고 기초적인 문제 풀이 방법이다. 알고리즘 문제를 풀때에는 기본적으로 두가지를 생각하고 들어간…","fields":{"slug":"/brute-force/"},"frontmatter":{"date":"April 17, 2022","title":"알고리즘 완전탐색(Exhaustive search)이란","tags":["Algorithm","완전탐색"]},"rawMarkdownBody":"# 완전탐색이란?\r\n완전탐색이란 __가능한 모든 경우의 수__ 를 모두 찾는 방법이다. 이러한 방법은 무식한 한다는 의미로 'Brute Force'라고도 이름이 불린다.\r\n\r\n완전탐색은 __직관적이어서 이해하기 쉽고__, 문제에 대한 __결과값이 정확하게 얻을 수 있다__ 는 점에서 가장 확실하고 기초적인 문제 풀이 방법이다.\r\n\r\n알고리즘 문제를 풀때에는 기본적으로 두가지를 생각하고 들어간다.\r\n\r\n1. 해당 알고리즘이 적절한가> -> 문제를 풀 수 있는 방법인가\r\n2. 효율적인가? -> 제한된 시간이 안에 알고리즘이 동작하는가\r\n\r\n1번의 경우에서의 완전탐색은 가능한 모든 경우의 수를 확인하여 정확한 답은 얻어 낼 수 있다. 반면에 2번 측면에서는 문제와 주어진 조건에 따라 제한된 시간안에 결과값을 도출할 수 없을 수 있다.\r\n\r\n완전탐색은 가장 기초적으로 알고리즘 문제를 푸는 방식중 하나이지만 완전탐색을 사용할때는 문제를 잘 파악하여 적용시킬 수 있는지 확인하는것이 중요하다.\r\n\r\n# 완전탐색 기법들\r\n완전탐색은 그 자체로 알고리즘보단 __문제 풀이__ 방법이기 때문에 완전탐색을 구현하기 위한 여러가지 방법들이 존재한다. 주로 이용하는 방법은 아래와 같다.\r\n\r\n- Brute-Force\r\n- 비트마스크(Bitmask)\r\n- 재귀함수(Recursion)\r\n- 순열(Permutation)\r\n- DFS/BFS\r\n\r\n## Brute-Force\r\n단순 Brute-Force는 for문 또는 if문을 사용하여 가능한 모든 경우의 수를 확인하여 답을 구하는 방법이다. 이 방법은 가장 기초적인 문제에서 사용이되거나, 전체의 문제에서 일부분에서만 사용된다. 코딩 테스트에서는 거의 이 방법만으로 푸는 문제는 자주등장하지 않는다.\r\n\r\n## 비트마스크(Bitmask)\r\n비트마스크는 이진수를 사용하는 컴퓨터의 연산 방식을 이용하여, 정수의 이진 표현을 자료 구조로 사용하는 기법을 말한다.\r\n\r\n이진수는 1과 0을 이용하여 하나의 비트에서 사용할 수 있는 가짓수는 2가지이다. 이러한 방식으로 어떤 비트가 1이면 \"존재한다\" 0이면 \"존재하지 않는다\"라고 말할 수 있다.\r\n\r\n## 재귀함수(Recursion)\r\n재귀함수란 어떠한 함수에서 자신을 다시 호출하여 작업을하는 방식이다. 재귀 함수는 함수 내에서 자기 자신을 계속 호출하는 방식이기 때문에 함수 안에 __반드시 종료 구간__ 을 정해주어야 합니다.\r\n\r\n## 순열(Permutation)\r\n완전 탐색의 대표적인 유형으로. 순열은 순서에 상관있게 선택하는 혹은 나열하는 것을 말한다. N개의 원소가 주어졌을때 순열의 수는 N!개이다.\r\n\r\n> ex)[1,2,3]이라는 배열이 주어졌을때, 모든 경우의 수\r\n>\r\n> [1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1] 총 6개. -> 3!의 값과 동일한 개수이다\r\n\r\n## DFS/BFS\r\n약간의 난이도가 있는 문제로 완전 탐색 + BFS/DFS 문제와 그래프를 탐색할때 사용하는 알고리즘이다.\r\n\r\n# References\r\n- [https://hongjw1938.tistory.com/78](https://hongjw1938.tistory.com/78)"},{"excerpt":"Hilt Hilt란 Google의 Dagger2를 기본으로 만든 의존성 주입 라이브러리이다. 따라서 Dagger2에 대한 Component, Scope를 기본적을 제공하며, 초기 프로젝트 환경 구축 비용을 크게 줄이는 것이 목적이 있다. Hilt에 대해 알아보기 전에 Dagger2를 사용하여 의존성 주입을 사용한 간단한 예시를 구성해 보면 다음과 같다. …","fields":{"slug":"/android-hilt/"},"frontmatter":{"date":"April 10, 2022","title":"안드로이드 Hilt에 대해 알아보기","tags":["Android","Hilt"]},"rawMarkdownBody":"# Hilt\r\nHilt란 Google의 Dagger2를 기본으로 만든 의존성 주입 라이브러리이다. 따라서 Dagger2에 대한 Component, Scope를 기본적을 제공하며, 초기 프로젝트 환경 구축 비용을 크게 줄이는 것이 목적이 있다.\r\n\r\n\r\n```kotlin\r\n// Third Party Library라고 생각\r\nclass DataSource {\r\n    fun getData() {\r\n        Log.i(\"TAG\", \"데이터 다운로드..\")\r\n    }\r\n}\r\n```\r\n\r\nHilt에 대해 알아보기 전에 Dagger2를 사용하여 의존성 주입을 사용한 간단한 예시를 구성해 보면 다음과 같다.\r\n\r\n```kotlin\r\n@Module\r\nclass DataModule {\r\n\r\n    @Provides\r\n    fun providesDataSource(): DataSource {\r\n        return DataSource()\r\n    }\r\n}\r\n\r\n@Component(modules = [DataModule::class])\r\ninterface DataComponent {\r\n    fun inject(mainActivity: MainActivity)\r\n}\r\n\r\nclass App: Application() {\r\n    lateinit var dataComponent: DataComponent\r\n    \r\n    override fun onCreate() {\r\n        super.onCreate()\r\n        dataComponent = DaggerDataComponent.builder()\r\n            .build()\r\n    }\r\n}\r\n\r\nclass MainActivity : AppCompatActivity() {\r\n    @Inject\r\n    lateinit var dataSource: DataSource\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n        (application as App).dataComponent\r\n            .inject(this)\r\n\r\n        // 사용하기\r\n        dataSource.getData()\r\n    }\r\n}\r\n```\r\n\r\n```xml\r\n<application\r\n    android:name=\".App\"\r\n    .\r\n    .\r\n</application>\r\n\r\n```\r\nDagger2로 적용되어있는 간단한 예시를 Hilt를 알아보면서 바꿔보도록 한다.\r\n\r\n# 종속 항목 추가\r\n먼저 `hilt-android-gradle-plugin` 플러그인을 프로젝트의 루트 build.gradle 파일에 추가한다.\r\n\r\n```gradle\r\nbuildscript {\r\n    ...\r\n    dependencies {\r\n        ...\r\n        classpath 'com.google.dagger:hilt-android-gradle-plugin:2.28-alpha'\r\n    }\r\n}\r\n```\r\n\r\n`app/build.gradle` 파일에 종속 항복을 추가한다.\r\n\r\n```gradle\r\nplugins {\r\n    id 'kotlin-kapt'\r\n    id 'dagger.hilt.android.plugin'\r\n}\r\n\r\ndependencies {\r\n    // Dagger - Hilt\r\n    implementation \"com.google.dagger:hilt-android:2.41\"\r\n    kapt \"com.google.dagger:hilt-android-compiler:2.41\"\r\n}\r\n```\r\n\r\nHilt는 자바8 기능을 사용한다. 대부분 자바8을 사용하기 때문에 이미 되어있는 부분일 수 있다.\r\n\r\n```gradle\r\ncompileOptions {\r\n    sourceCompatibility JavaVersion.VERSION_1_8\r\n    targetCompatibility JavaVersion.VERSION_1_8\r\n}\r\n```\r\n\r\n## version 범블비\r\n안드로이드 스튜디오 범블비 버전에선 `build.gradle`과 `settings.gradle`이 변화하였다.\r\n\r\n`build.gradle`에 있던 이 부분이 `settings.gradle`로 이동하였다.\r\n\r\n```gradle\r\nrepositories {\r\n    gradlePluginPortal()\r\n    google()\r\n    mavenCentral()\r\n}\r\n```\r\n\r\n`build.gradle` 의 classpath 설정하던 부분이 다음과 같이 변경되었다.\r\n```gradle\r\nplugins {\r\n    id 'com.android.application' version '7.1.1' apply false\r\n    id 'com.android.library' version '7.1.1' apply false\r\n    id 'org.jetbrains.kotlin.android' version '1.6.10' apply false\r\n}\r\n```\r\nHilt의 2.41버전이 나오면서 classpath는 `build.gradle`에 다음과 같이 넣어주면 된다.\r\n```gradle\r\nplugins {\r\n    id 'com.android.application' version '7.1.1' apply false\r\n    id 'com.android.library' version '7.1.1' apply false\r\n    id 'org.jetbrains.kotlin.android' version '1.6.10' apply false\r\n    id 'com.google.dagger.hilt.android' version '2.41' apply false\r\n}\r\n\r\n```\r\n# @HiltAndroidApp\r\n```kotlin\r\nclass App: Application() {\r\n    lateinit var dataComponent: DataComponent\r\n    \r\n    override fun onCreate() {\r\n        super.onCreate()\r\n        dataComponent = DaggerDataComponent.builder()\r\n            .build()\r\n    }\r\n}\r\n```\r\nHilt에서 __@HiltAndroidApp__ 어노테이션을 사용하면 컴파일 타임시 표준 Component 생성에 필요한 클래스들을 초기화한다. 따라서 Hilt를 프로젝트에 적용하기 위해서는 필수적으로 요구되는 과정이다. \r\n\r\nDagger를 적용하였는 App 클래스를 Hilt로 변경하면 다음과 같이 코드가 줄어든다.\r\n```kotlin\r\n@HiltAndroidApp\r\nclass App: Application()\r\n```\r\n```xml\r\n<application\r\n    android:name=\".App\"\r\n    .\r\n    .\r\n</application>\r\n\r\n```\r\n# Component hierachy\r\n기존의 Dagger2는 개발자가 직접 필요한 Component들을 작성하고 상속 관계를 정의하여 사용하였지만, Hilt에서는 Android 화경에서 표준적으로 사용되는 Component들을 기본적으로 제공하고 있다.\r\n\r\n또한 Hilt 내부적으로 제공하는 Component들의 전반적인 생명주기 또한 자동으로 관리를 해주기 때문에 초기 DI 적용을 위한 환경을 구축하는데 드는 비용을 줄일수 있다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/162617386-fb24e8e4-e8dd-4730-9170-3430f0145c3e.png\">\r\n\r\n위와 같은 Hilt에서 제공하는 Component들은 아래와 같은 함수 호출시점에 생성되고, Destroy가 된다.\r\n\r\n|        생성된 구성요소       |       생성 위치         |        제거 위치        |\r\n| :------------------------ | :--------------------- | :--------------------- |\r\n|    SingletonComponent     | Application#onCreate() | Application#onDestroy()|\r\n| ActivityRetainedComponent |   Activity#onCreate()  |  Activity#onDestroy()  |\r\n|     ActivityComponent     |   Activity#onCreate()  |   Activity#onDestroy() |\r\n|    FragmentComponent      | \tFragment#onAttach()  |   Fragment#onDestroy() |\r\n|       ViewComponent       |      View#super()      |        제거된 뷰        |\r\n| ViewWithFragmentComponent |      View#super()      |        제거된 뷰        |\r\n|     ServiceComponent      | \t Service#onCreate()  |   Service#onDestroy()  |\r\n\r\n각 컴포넌트들은 생성 시점부터 제거되기까지 `Member Injection`이 가능하고, 각 컴포넌트마다 아래와 같은 생명주기를 갖는다.\r\n\r\n- SingletonComponent: Application 전체의 생명주기를 가진다.\r\n- ActivityRetainComponent: `ApplicationComponent`의 하위 컴포넌트로써, Activity의 생명주기를 가진다.\r\n   - Activity의 화면 회전과 같은 작업이 일어났을시 파괴되지 않고 유지된다.\r\n- ActivityComponent: `ActivityRetainComponent`의 하위 컴포넌트로써, Activity의 생명주기를 가진다.\r\n- FragmentComponent: `ActivityComponent`의 하위 컴포넌트로써, Fragment가 Activity에 붙는(onAttach()) 시점에 생성이 되고, Fragment가 파괴되는 시점에 제더된다.\r\n- ViewComponent: `ActivityComponent`의 하위 컴포넌트로써, View의 생명주기를 가진다.\r\n- ViewWithFragmentComponent: `FragmentComponent`의 하위 컴포넌트로써, Fragment의 view 생명주기를 가진다.\r\n- ServiceComponent: `ApplicationComponent`의 하위 컴포넌트로써, Service의 생명주기를 가진다.\r\n\r\n위와 같은 표준 Component/Scope들은 Hilt에서는 제공하고 있으며, 새로운 Component를 정의하고 싶다면 `@DefineComponent` 어노테이션을 사용하여 정의가 가능하다.\r\n\r\n# @InstallIn\r\nDagger2에서는 새로운 module을 생성하면, 사용자가 정의한 Component에 module 클래스를 직접 넣어주는 방법을 사용하였다. \r\n```kotlin\r\n@Component(modules = [DataModule::class])\r\ninterface DataComponent {\r\n    fun inject(mainActivity: MainActivity)\r\n}\r\n```\r\n반면에 Hilt에서는 표준적으로 제공하는 Component들이 존재하기 때문에 @InstallIn 어노테이션을 사용하여 표준 Component에 Module을 install 할 수 있다.\r\n\r\nDagger에서 사용하였던 DataComponent를 삭제하고 DataModule에 @InstallIn을 추가한다.\r\n\r\n```kotlin\r\n@Module\r\n@InstallIn(SingletonComponent::class)\r\nclass DataModule {\r\n    @Provides\r\n    fun providesDataSource(): DataSource {\r\n        return DataSource()\r\n    }\r\n}\r\n```\r\n# @AndroidEntryPoint\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n    @Inject\r\n    lateinit var dataSource: DataSource\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n        (application as App).dataComponent\r\n            .inject(this)\r\n\r\n        // 사용하기\r\n        dataSource.getData()\r\n    }\r\n}\r\n```\r\nDagger2에서는 의존성을 주입받을 대상을 전부 dependency graph에 지정을 해주었지만, Hilt에서는 객체를 주입할 대상에게 @AndroidEntryPoint 어노테이션을 추가만 해주면 된다. @AndroidEntryPoint를 추가할 수 있는 Android Component는 아래와 같다.\r\n- Activity\r\n- Fragment\r\n- View\r\n- Service\r\n- BroadcastReceiver\r\n\r\n```kotlin\r\n@AndroidEntryPoint\r\nclass MainActivity : AppCompatActivity() {\r\n    @Inject\r\n    lateinit var dataSource: DataSource\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n        // 사용하기\r\n        dataSource.getData()\r\n    }\r\n}\r\n```\r\n<img src=\"https://user-images.githubusercontent.com/63226023/162624070-99438590-aae7-4ae4-b966-5e66119cbaa7.png\">\r\n\r\n- - -\r\n\r\n# References \r\n- [Hilt를 사용한 종속 항목 삽입](https://developer.android.com/training/dependency-injection/hilt-android?hl=ko)\r\n- [안드로이드-스튜디오-범블비202111-버전이-나오면서-buildgradle과-settingsgradle에-변화](https://open-support.tistory.com/entry/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%8A%A4%ED%8A%9C%EB%94%94%EC%98%A4-%EB%B2%94%EB%B8%94%EB%B9%84202111-%EB%B2%84%EC%A0%84%EC%9D%B4-%EB%82%98%EC%98%A4%EB%A9%B4%EC%84%9C-buildgradle%EA%B3%BC-settingsgradle%EC%97%90-%EB%B3%80%ED%99%94)\r\n- [https://hyperconnect.github.io/2020/07/28/android-dagger-hilt.html](https://hyperconnect.github.io/2020/07/28/android-dagger-hilt.html)"},{"excerpt":"Custom Application 저번 포스팅에서 Dagger의 Inject, Module, Component에 대해서 알아보고 SmartPhone 클래스에 적용시켜 보았다. 불변하는 데이터나 전역으로 사용되는 object 같은 경우 모든 Component 에 공유가 되어 사용되야 할 것이다 (ex) Room Database, SharedPreferenc…","fields":{"slug":"/android-dagger2-more/"},"frontmatter":{"date":"April 08, 2022","title":"안드로이드 Dagger2 좀 더 알아가기","tags":["Android","Dagger"]},"rawMarkdownBody":"# Custom Application\r\n저번 포스팅에서 Dagger의 Inject, Module, Component에 대해서 알아보고 SmartPhone 클래스에 적용시켜 보았다.\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n    // Field Injection\r\n    @Inject\r\n    lateinit var smartPhone: SmartPhone\r\n    \r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n        DaggerSmartPhoneComponent.create()\r\n            .inject(this)\r\n            \r\n        smartPhone.start()\r\n    }\r\n}\r\n```\r\n불변하는 데이터나 전역으로 사용되는 object 같은 경우 __모든 Component__ 에 공유가 되어 사용되야 할 것이다 (ex) Room Database, SharedPreference..)\r\n\r\n위의 예시에서의 SmartPhone 컴포넌트가 필요한 Activity/Fragment가 10개라면 `DaggerSmartPhoneComponent.create().inject(this)` 의 같은 코드를 10번 써야할 것이다 😨\r\n\r\n> 📍Application 서브 클래스를 생성하여 전역으로 사용할 수 있게 한다.\r\n\r\n## 생성하기\r\nApplication을 상속 받는 커스텀 SmartPhoneApplication 클래스를 생성한다.\r\n\r\nonCreate() 함수를 오버라이드 하여 어플리케이션 실행전에 Component를 build해준다.\r\n\r\n```kotlin\r\nclass SmartPhoneApplication: Application() {\r\n    lateinit var smartPhoneComponent: SmartPhoneComponent\r\n    override fun onCreate() {\r\n        super.onCreate()\r\n        smartPhoneComponent = initDagger()\r\n    }\r\n\r\n    private fun initDagger(): SmartPhoneComponent =\r\n        DaggerSmartPhoneComponent.builder()\r\n            .build()\r\n\r\n}\r\n```\r\n이후에 `AndroidManifest.xml`파일에 이름을 지정해 줘야한다.\r\n```xml\r\n    <application\r\n        android:name=\".SmartPhoneApplication\"\r\n            .\r\n            .\r\n    </application>\r\n```\r\n여기서 __android:name__ 의 역할은 구글 문서에서 다음과 같이 정의되어 있다.\r\n\r\n> 📃: 어플리케이션에 대해 구현된 어플리케이션 서브클래스의 이름. 어플리케이션 프로세스(앱이 실행)가 시작될 때, 어플리케이션의 다른 어떤 컴포넌트보다 먼저 인스턴스화된다(객체화된다). 서브클래스는 없어도 된다(대부분의 어플리케이션은 서브클래스를 사용하지 않는다). 서브클래스가 없으면, 안드로이드는 기본 어플리케이션 클래스의 객체를 사용한다.\r\n\r\n마지막으로 사용하고자하는 Activity/Fragment에서 사용하면 된다.\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n    // Field Injection\r\n    @Inject\r\n    lateinit var smartPhone: SmartPhone\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n        (application as SmartPhoneApplication).smartPhoneComponent\r\n            .inject(this)\r\n\r\n        smartPhone.start()\r\n    }\r\n}\r\n```\r\n# Scope\r\n특정 Component에 Scope를 지정하고 이와 같은 생명주기를 같이할 클래스에 Scope를 지정할 수 있다. Scope가 지정되면 해당 Component의 생명주기 동안은 항상 같은 객체를 반환 받는 것을 보장한다.\r\n\r\n🧷Scoping rules\r\n1. type에 Scope을 붙일 때는 같은 Scope이 붙은 Component에 의해서만 사용 가능하다.\r\n2. Component에 Scope를 지정하면 Scope이 없는 type이나 동일한 Scope이 붙은 type만 제공할 수 있다.\r\n3. SubComponent는 상위 Component에서 사용 중인 annotation을 사용할 수 없다.\r\n\r\nCustom Scope를 생성하기 위해서는 다음과 같이 생성한다.\r\n```kotlin\r\n@Scope\r\n@kotlin.annotation.Retention(AnnotationRetention.RUNTIME)\r\nannotation class CustomScope\r\n```\r\n\r\n## @Singleton\r\nCustom Application의 생성은 어플리케이션에서 공유되어 사용하기 위해서 만들어 준다고 했다. 지금까지 Dagger를 적용하여 SmartPhone을 실행하고 화면의 회전을 하게 되면 __SmartPhone이 다시 생성되어 실행되는 것을 볼 수 있다.__\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/161263860-d0937a5d-aa2b-46df-8a57-b079fa97f6c4.png\">\r\n\r\n안드로이드 Room Database의 경우 room DB에 접근을 할때 Database객체를 받아와야 한다. 구글에선 한번 생성된 Database를 이용해서 사용하도록 권고 합니다.(싱글톤으로 만들어준다)\r\n\r\n이때 @Singleton 어노테이션을 붙여서 한개의 컴포넌트만 생성할 수 있게 해준다. \r\n\r\n> 📍@Singleton은 javax.inject 패키지 하위에 있는 어노테이션으로 Dagger의 어노테이션 X.\r\n\r\n```kotlin\r\n@Singleton\r\nclass SmartPhone @Inject constructor(val battery: Battery, val simCard: SIMCard, val memoryCard: MemoryCard) {\r\n    fun start() {\r\n        Log.i(\"TAG\", \"스마트폰 동작!\")\r\n    }\r\n}\r\n\r\n@Singleton\r\n@Component(modules = [MemoryCardModule::class])\r\ninterface SmartPhoneComponent {\r\n    fun inject(mainActivity: MainActivity)\r\n}\r\n```\r\n\r\n싱글톤으로 생성되어야하는 SmartPhone 클래스와 Component 인터페이스에 @Singleton 어노테이션을 붙여주고 아까와 같이 실행후 화면을 돌려봐도 같은 객체를 사용하는 것을 볼 수 있다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/161267195-f762a0ab-6f9e-4496-9a64-3c15b8b2fdb8.png\">\r\n\r\n# Component\r\n## Builder\r\nComponent 인스턴스를 생성하기 위한 __Builder__ 용 어노테이션이다. __Module에 초기 설정__ 을 할때 사용한다. Component 내의 interface 또는 abstract 클래스에 붙여서 사용한다.\r\n\r\n```kotlin\r\n@Singleton\r\n@Component(modules = [MemoryCardModule::class])\r\ninterface SmartPhoneComponent {\r\n    fun inject(mainActivity: MainActivity)\r\n\r\n    @Component.Builder\r\n    interface Builder {\r\n        fun getMemoryCardModule(memoryCardModule: MemoryCardModule): Builder\r\n        fun build(): SmartPhoneComponent\r\n    }\r\n}\r\n\r\nclass SmartPhoneApplication: Application() {\r\n    .\r\n    .\r\n    private fun initDagger(): SmartPhoneComponent =\r\n        DaggerSmartPhoneComponent.builder()\r\n            .getMemoryCardModule(MemoryCardModule())\r\n            .build()\r\n\r\n}\r\n```\r\nBuilder는 __반드시 Component를 반환하는 메소드__ (위의 예시: build()), Builder를 반환값으로 가지면서 Component가 필요로하는 Module을 파라미터로 받는 메소드를 가지고 있어야한다.\r\n\r\nBuilder를 사용하지 않고 Dagger2를 생성하였을때도 이미 Component에는 자동으로 Builder가 생성되어 있다.\r\n\r\n```kotlin\r\n@Singleton\r\n@Component(modules = [MemoryCardModule::class])\r\ninterface SmartPhoneComponent {\r\n    fun inject(mainActivity: MainActivity)\r\n}\r\n```\r\n```java\r\n// DaggerSmartPhoneComponent.java\r\n public static final class Builder {\r\n    private MemoryCardModule memoryCardModule;\r\n\r\n    private Builder() {\r\n    }\r\n\r\n    public Builder memoryCardModule(MemoryCardModule memoryCardModule) {\r\n      this.memoryCardModule = Preconditions.checkNotNull(memoryCardModule);\r\n      return this;\r\n    }\r\n\r\n    public SmartPhoneComponent build() {\r\n      if (memoryCardModule == null) {\r\n        this.memoryCardModule = new MemoryCardModule();\r\n      }\r\n      return new DaggerSmartPhoneComponent(memoryCardModule);\r\n    }\r\n```\r\n## Factory\r\n`daager-android 2.22` 버전에서 추가된 Factory 어노테이션은 Builder와 의미는 같지만 사용법 다른 형태이다. Builder는 파라미터를 __1개__ 만 받으며 여러 Module을 설정해야 한다면 각각의 메소드를 선언하여 메소드 체이닝이 길어지는 점을 보완한 것이 Factory이다.\r\n\r\nFactory는 __단 하나__ 의 메소드(create())만 선언되어야 하고 Component 인스턴스를 반환해야 한다.\r\n\r\n```kotlin\r\n@Singleton\r\n@Component(modules = [MemoryCardModule::class, ModuleB::class])\r\ninterface SmartPhoneComponent {\r\n    fun inject(mainActivity: MainActivity)\r\n\r\n    @Component.Factory\r\n    interface Factory {\r\n        fun create(memoryCardModule: MemoryCardModule, moduleB: ModuleB): SmartPhoneComponent\r\n    }\r\n}\r\n```\r\n# @SubComponent \r\nSubComponent는 부모 Component가 있는 자식 Component라고 볼 수 있다. Component는 SubComponent로 계층관계를 만들 수 있으며, SubComponent는 Dagger의 그래프를 형성하는 역할이다.\r\n\r\nInject으로 의존성 주입을 요청받으면 SubComponent에서 먼저 의존성을 찾고, 없으면 상위 부모로 올라가면서 검색한다.\r\n\r\n@Component를 사용할 때는 직접 해당하는 component의 인스턴스를 반환하는 Factory를 만들어 줄 필요가 없었지만 @SubComponent는 __반드시 부모 컴포넌트가 어떻게 서브 컴포넌트가 만들면 되는지 알도록 해야하므로 Factory를 구현해야한다.__\r\n\r\n\r\n```kotlin\r\n@CustomScope\r\n@Subcomponent\r\ninterface PpeperSubComponent {\r\n    fun inject(aActivity: A_Activity)\r\n\r\n    @Subcomponent.Factory\r\n    interface Factory {\r\n        fun create(): PpeperSubComponent\r\n    }\r\n}\r\n```\r\n\r\n1. SubComponentModule을 만들고 서브컴포넌트 클래스를 subcomponents 속성값으로 넣어준다.\r\n\r\n```kotlin\r\n@Module(subcomponents = [PpeperSubComponent::class])\r\nclass SubComponentModule {}\r\n```\r\n2. 만든 모듈을 부모 Component에 추가한다.\r\n3. 사용할 SubComponent를 외부로 노출시켜 다른곳에서 가져다 쓸수 있게 해준다.\r\n\r\n```kotlin\r\n@Singleton\r\n@Component(modules = [ModuleA::class, ModuleB::class, SubComponentModule::class])\r\ninterface ParentComponent {\r\n    fun pppeperSubComponent(): PpeperSubComponent.Factory  \r\n}\r\n```\r\n- - -\r\n# References\r\n- [Android 개발자 > 문서 > 가이드](https://developer.android.com/guide/topics/manifest/application-element.html#nm)\r\n- [https://jaejong.tistory.com/125](https://jaejong.tistory.com/125)"},{"excerpt":"Dagger Dagger는 의존성 주입(DI)을 도와주는 프레임워크이다. 의존성 주입(DI)에 대해서 전 포스팅에서 알아보았다. Dagger를 사용하여 의존성 주입을 자동화하도록 지원하여 코드 작성에 편의성을 제공한다. 전 포스팅에서 만들어 보았던 스마트폰 예시에 Dagger를 적용해 보려고 한다. 시작하기 build.gradle 프로젝트에 Dagger를…","fields":{"slug":"/android-dagger2/"},"frontmatter":{"date":"March 31, 2022","title":"안드로이드 Dagger2 맛보기","tags":["Android","Dagger"]},"rawMarkdownBody":"# Dagger\r\nDagger는 [의존성 주입(DI)](https://ppeper.github.io/cs/dependency-Injection/)을 도와주는 프레임워크이다.   \r\n의존성 주입(DI)에 대해서 전 포스팅에서 알아보았다. Dagger를 사용하여 의존성 주입을 자동화하도록 지원하여 코드 작성에 편의성을 제공한다. 전 포스팅에서 만들어 보았던 스마트폰 예시에 Dagger를 적용해 보려고 한다.\r\n\r\n# 시작하기\r\n## build.gradle\r\n프로젝트에 Dagger를 사용하려면 `build.gradle`에 아래의 종속 항복을 추가해야 한다.\r\n최신 버전의 Dagger는 [Github](https://github.com/google/dagger) 에서 확인 할 수 있다.\r\n```kotlin\r\nplugins {\r\n    .\r\n    .\r\n    id 'kotlin-kapt'\r\n}\r\n\r\n\r\ndependencies {\r\n    .\r\n    .\r\n    // Dagger2\r\n    implementation \"com.google.dagger:dagger:2.41\"\r\n    kapt \"com.google.dagger:dagger-compiler:2.41\"\r\n}\r\n```\r\n## @Inject\r\n__@Inject__ 를 사용하게 되면 Dagger가 해당 타입을 어떻게 생성하는지 알수 있게 한다. __@Inject__ 는 `필드`, `생성자`, `메서드`에 붙여 Component로 부터 의존성 객체를 주입 요청하는 어노테이션이다. 객체(인스턴스)의 생성이 클래스에 의존적이지 않고 Component가 생성해 주기 때문에 __보일러 플레이트 코드가 줄어들고 테스트하기 수월해 진다.__\r\n\r\n__@Inject__ 로 의존성 주입을 요청하면 연결된 Component의 Module에서 의존 객체가 생성되어 반환된다.\r\n\r\n- - -\r\n\r\n각 Battery, MemoryCard, SIMCard, SmartPhone에 __@Inject__ 어노테이션을 추가한다. -> `생성자를 통한 의존성 주입`\r\n\r\n\r\n```kotlin\r\nclass Battery @Inject constructor() {\r\n    init {\r\n        Log.i(\"TAG\", \"배터리 생성완료!\")\r\n    }\r\n}\r\n\r\nclass MemoryCard @Inject constructor(){\r\n    init {\r\n        Log.i(\"TAG\", \"메모리 카드 생성완료!\")\r\n    }\r\n}\r\n\r\nclass SIMCard @Inject constructor(){\r\n    init {\r\n        Log.i(\"TAG\", \"유심칩 생성완료!\")\r\n    }\r\n}\r\n\r\nclass SmartPhone @Inject constructor(val battery: Battery, val simCard: SIMCard, val memoryCard: MemoryCard) {\r\n    fun start() {\r\n        Log.i(\"TAG\", \"스마트폰 동작!\")\r\n    }\r\n}\r\n```\r\n\r\n## @Component\r\n__@Component__ 는 `Interface` 또는 `abstract class`에만 사용이 가능하다.\r\n\r\n> 📍 __컴파일 타임__ 에 접두어 `Dagger`와 `Component 클래스 이름`이 합쳐진 Dagger클래스 자동생성   \r\n> ex) SmartPhoneComponent -> DaggerSmartPhoneComponent\r\n\r\n연결된 Module로 부터 의존성 객체를 생성하고, Inject로 요청받은 인스턴스에 생성한 객체를 주입한다.\r\n\r\n### Component Methods\r\n\r\n__@Component__ 어노테이션이 가지는 인터페이스 또는 abstract class는 __하나 이상의 메소드__ 를 가지고 있어야 한다.\r\n\r\n메소드의 방식에는 `Provision Method` 와 `Member-Injection` 이 있다.\r\n\r\n#### 1. Provision Method\r\nProvision Method의 경우 매개변수가 없고, Module이 제공하는 객체의 타입을 반환값으로 갖는다.\r\n\r\n#### 2. Member-Injection\r\n의존성 주입을 시킬 객체를 파라미터로 넘기는 방식으로, 해당 객체의 `클래스 내부`에서 `@Inject가 붙은 필드에 객체`를 주입한다.\r\n\r\n```kotlin\r\n@Component\r\ninterface SmartPhoneComponent {\r\n    // Provision Method 방식\r\n    fun getSmartPhone(): SmartPhone\r\n}\r\n```\r\n## Component 객체 구현 - create() / build()\r\nDagger로 생성된 Component는 위에서 말한 형태로 `Dagger + Component 클래스 이름`으로 자동 생성된다. \r\n> 📍해당하는 클래스가 생성이 되지않았다면   \r\n> \r\n> 1. Rebuild Project 실행   \r\n> 2. 1번을 수행해도 안된다면 `dagger-complier` 라이브러리를 포함하는지 확인\r\n\r\nComponent의 인스턴스를 생성하는 방법은 `create(), build()`로 2가지 방법이 있다.\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n//        val battery = Battery()\r\n//        val simCard = SIMCard()\r\n//        val memoryCard = MemoryCard()\r\n//        val smartPhone = SmartPhone(battery, simCard, memoryCard)\r\n//        smartPhone.start()\r\n\r\n        // 1. create() 방식\r\n        val smartPhone = DaggerSmartPhoneComponent.create()\r\n            .getSmartPhone()\r\n    \r\n\r\n        // 2. build() 방식\r\n        val smartPhone = DaggerSmartPhoneComponent.builder()\r\n            .build()\r\n            .getSmartPhone()\r\n            \r\n        smartPhone.start()\r\n    }\r\n}\r\n```\r\n생성된 스마트폰 Component에 있는 smartPhone.start()를 통하여 실행을 하게되면 동작을 하는것을 볼 수 있다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/157629828-8ad84f5a-a74b-4866-ba14-a2f8ceea556e.png\">\r\n\r\n```java\r\n@DaggerGenerated\r\n@SuppressWarnings({\r\n    \"unchecked\",\r\n    \"rawtypes\"\r\n})\r\npublic final class DaggerSmartPhoneComponent implements SmartPhoneComponent {\r\n  private final DaggerSmartPhoneComponent smartPhoneComponent = this;\r\n\r\n  private DaggerSmartPhoneComponent() {\r\n\r\n\r\n  }\r\n\r\n  public static Builder builder() {\r\n    return new Builder();\r\n  }\r\n\r\n  public static SmartPhoneComponent create() {\r\n    return new Builder().build();\r\n  }\r\n\r\n  @Override\r\n  public SmartPhone getSmartPhone() {\r\n    return new SmartPhone(new Battery(), new SIMCard(), new MemoryCard());\r\n  }\r\n\r\n  public static final class Builder {\r\n    private Builder() {\r\n    }\r\n\r\n    public SmartPhoneComponent build() {\r\n      return new DaggerSmartPhoneComponent();\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n자동으로 생성된 `DaggerSmartPhoneComponent` 클래스에서 `getSmartPhone() `을 상속받아 자동으로 객체들을 주입해준것을 볼 수 있다.\r\n\r\n# Third Party Library는??\r\n여기서 외부에 존재하는 `Third Party Library`라면 함수의 내부를 볼 수 없기 때문에 `@Inject`어노테이션을 사용할 수 없다. 예를 들어 Retrofit client의 경우 Third party Library 이기 때문에 생성자를 통한 의존성 주입이 불가능하다.\r\n\r\n```kotlin\r\n// Retrofit\r\nclass Retrofit @Inject constructor()??{\r\n}\r\n```\r\n이러한 해당 객체를 의존성 주입을 사용하기 위해서는 __Module__ 과 __provider function__ 을 사용하여 주입해야한다.\r\n\r\n## @Module / @Provides\r\n\r\nDagger에서 의존성 관계를 설정하는 클래스를 __Module__ 이라고 부르고 @Module 어노테이션을 붙여준다. 즉 Dagger에서 Module은 의존성 주입에 필요한 객체들을 관리해준다. \r\n\r\n__@Provide__ 어노테이션은 @Module클래스에서 선언된 메소드들에만 붙임으로서 Dagger가 메소드에서 해당 타입의 객체를 반환해 준다는것을 알 수 있게 해준다.\r\n\r\nModule 클래스는 `클래스 이름 + Module`으로 생성하고, Provide 메소드는 `provide + 메소드 이름` 으로 만드는것이 일반적인 컨벤션이다.\r\n- - -\r\n위의 예시에서 MemoryCard가 Third Party Library라고 생각하고 Module을 생성해 보면 아래와 같다.\r\n```kotlin\r\n// third party 라이브러리하고 생각\r\nclass MemoryCard {\r\n    init {\r\n        Log.i(\"TAG\", \"메모리 카드 생성완료!\")\r\n    }\r\n}\r\n// Module 클래스 생성 \r\n@Module\r\nclass MemoryCardModule {\r\n\r\n    @Provides\r\n    fun provideMemoryCard(): MemoryCard {\r\n        return MemoryCard()\r\n    }\r\n}\r\n```\r\nComponent가 생성된 Module을 알 수 있게 하기위해선 @Component에 아래와 같이 추가해 주면 된다.\r\n\r\n```kotlin\r\n@Component(modules = [MemoryCardModule::class])\r\ninterface SmartPhoneComponent {\r\n    // Provision Method 방식\r\n    fun getSmartPhone(): SmartPhone\r\n}\r\n```\r\n- - -\r\n# Field Injection\r\n위의 Inject, Module, Component를 사용하여 의존성 주입을 해보았다. 실제로 의존성 주입을 사용하게되면 SmartPhone과 같은 Component 이외에 다은 의존성 객체가 많이 존재 할 수 있다. 이러한 Component들을 MainActivity에서 의존성 주입을 할때마다 생성해주어야 한다면 getSmartPhone()과 같은 getter 메소드들이 불필요하게 많이 추가가 될것이다.\r\n\r\nComponent에서 Method-Injection 방식을 사용하여 사용할 Activity / Fragment를 지정해 주고 사용할 View에서 Field Injection을 사용하면 불필요한 코드의 사용을 줄일 수 있다.\r\n\r\n```kotlin\r\n@Component\r\ninterface SmartPhoneComponent {\r\n    // Provision Method 방식\r\n    // fun getSmartPhone(): SmartPhone\r\n\r\n    // Method-Injection 방식\r\n    fun inject(mainActivity: MainActivity)\r\n}\r\n```\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n    // Field Injection\r\n    @Inject\r\n    lateinit var smartPhone: SmartPhone\r\n    \r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n        // 1. create() 방식\r\n        // val smartPhone = DaggerSmartPhoneComponent.create()\r\n        //     .getSmartPhone()\r\n    \r\n        DaggerSmartPhoneComponent.create()\r\n            .inject(this)\r\n            \r\n        smartPhone.start()\r\n    }\r\n}\r\n```\r\n\r\n- - -\r\n# References\r\n- [Android 앱에서 Dagger 사용](https://developer.android.com/training/dependency-injection/dagger-android?hl=ko)\r\n- [https://jaejong.tistory.com/125](https://jaejong.tistory.com/125)"},{"excerpt":"의존성 주입을 최근에 공부하게 되면서 의존성 주입에 대한 개념을 알아보려고 한다🤔 의존성 주입💉 의존성 주입(Dependency Injection)은 객체지향 프로그래밍을 하게 되면 한번씩 들어볼 수 있는 용어이다. 일반적으로 객체생성을 하게되면 사용할 클래스 내에서 객체를 생성하여 사용하지만, DI는 외부에서 생성된 객체를 주입 을 받는다.  📍의존성 …","fields":{"slug":"/dependency-injection/"},"frontmatter":{"date":"March 10, 2022","title":"의존성 주입(DI) 알아보기","tags":["CS","DI"]},"rawMarkdownBody":"<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/157641205-b344edbb-e4e3-4965-a366-5ee1401325b5.png\"></p>\r\n\r\n의존성 주입을 최근에 공부하게 되면서 의존성 주입에 대한 개념을 알아보려고 한다🤔\r\n\r\n- - -\r\n\r\n# 의존성 주입💉\r\n\r\n의존성 주입(Dependency Injection)은 객체지향 프로그래밍을 하게 되면 한번씩 들어볼 수 있는 용어이다.\r\n\r\n일반적으로 객체생성을 하게되면 사용할 클래스 내에서 객체를 생성하여 사용하지만, DI는 __외부에서 생성된 객체를 주입__ 을 받는다. \r\n> 📍의존성 주입: 외부에서 생성된 객체를 주입한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/157621746-f6102708-c8c2-4698-ad6b-4b6aff63ca9b.png\">\r\n\r\n## 일반적인 예시\r\n스마트폰이라는 객체가 있고 스마트폰에는 배터리, 유심칩, 메모리카드가 있다고 하자. 이를 일반적인 객체생성을 하게 되면 아래와 같을 것이다.\r\n```kotlin\r\nclass SmartPhone {\r\n\r\n    init {\r\n        val battery = Battery()\r\n        val simCard = SIMCard()\r\n        val memoryCard = MemoryCard()\r\n    }\r\n\r\n    fun start() {\r\n        Log.i(\"TAG\", \"스마트폰 동작!\")\r\n    }\r\n}\r\n\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n        val smartPhone = SmartPhone()\r\n        smartPhone.start()\r\n    }\r\n}\r\n\r\n```\r\n이렇게 해서 스마트폰을 생성하여 사용하더라도 문제없이 동작을 한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/157629828-8ad84f5a-a74b-4866-ba14-a2f8ceea556e.png\">\r\n\r\n여기서 만약 배터리를 다른 용량의 배터리로 교체를 하려고 한다면 __스마트폰 객체의 코드에서 다른 배터리 객체__ 로 바꿔야할 것이다. \r\n\r\n위의 간단한 예시에서는 한줄의 코드만 바꾸면 되지만 의존 관계가 복잡해 진다면 바꿔야 할 코드가 굉장히 많아지고 또한 어느 패키지에 있는 클래스를 바꿔야할지 등 코드 수정이 굉장히 힘들어질것이다😨\r\n\r\n## 생성자 주입(constructor Injection) 사용\r\n> 📍생성자를 통해 의존하는 객체를 주입하는 방법\r\n\r\n스마트폰과 부품들간의 결합도를 느슨하게 하기위하여 예시의 코드를 변경해보자.\r\n\r\n```kotlin\r\nclass SmartPhone(val battery: Battery, val simCard: SIMCard, val memoryCard: MemoryCard) {\r\n\r\n    fun start() {\r\n        Log.i(\"TAG\", \"스마트폰 동작!\")\r\n    }\r\n}\r\n\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n        val battery = Battery()\r\n        val simCard = SIMCard()\r\n        val memoryCard = MemoryCard()\r\n        val smartPhone = SmartPhone(battery, simCard, memoryCard)\r\n        smartPhone.start()\r\n    }\r\n}\r\n```\r\n\r\n이렇게 스마트폰을 생성을 하게되면 __다른 용량이 큰 배터리로 교체를 하더라도 새로운 배터리 객체를 생성하여 스마트폰에 주입__ 을 할 수 있다. 이렇게 생성자를 통하여 의존성 주입을 하는 방법을 __생성자 주입__ 이라이고 한다.\r\n\r\n## 필드 주입(Field Injection) 사용\r\n> 📍객체를 초기화한 후 의존하는 객체로 주입하는 방법\r\n\r\n```kotlin\r\nclass SmartPhone {\r\n    lateinit var battery: Battery\r\n    lateinit var simCard: SIMCard\r\n    lateinit var memoryCard: MemoryCard\r\n\r\n    fun start() {\r\n        Log.i(\"TAG\", \"스마트폰 동작!\")\r\n    }\r\n}\r\n\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n        val battery = Battery()\r\n        val simCard = SIMCard()\r\n        val memoryCard = MemoryCard()\r\n\r\n        val smartPhone = SmartPhone()\r\n        smartPhone.battery = battery\r\n        smartPhone.simCard = simCard\r\n        smartPhone.memoryCard = memoryCard\r\n        smartPhone.start()\r\n    }\r\n}\r\n```\r\n\r\n위의 예시처럼 배터리, 유심카드, 메모리 카드를 생성하여 외부에서 해당 멤버변수로 직접 값을 넣어주는 방법을 __필드 주입__ 이라고 한다.\r\n\r\n## 의존성 주입의 장점\r\n앞서 살펴본 의존성 주입을 사용한다면 클래스간의 결합도가 약해지는것을 볼 수 있었다. 이러한 클래스간의 결합도가 약해지면 얻어지는 장점들은 다음과 같다.\r\n- __코드의 리펙토링이 쉬워진다.__\r\n- __코드의 재사용성이 좋아진다.__\r\n- __코드의 가독성이 좋아진다.__\r\n- __결합도가 약해져서 Unit testing에 용이하다.__\r\n\r\n- - -\r\n\r\n# 마무리\r\n안드로이드에서 의존성 주입은 Dagger라는 프레임워크와 kotlin 언어를 사용하면 Koin을 많이 사용한다고 한다. 최근에 안드로이드 의존성 주입에 대해서 공부를 하면서 굉장히 러닝커브가 높다는걸 느꼈다.😅~~(프로젝트에 적용시킬 수 있을까..)~~ \r\n\r\n\r\n"},{"excerpt":"Room Room은 안드로이드 앱 내부에서 데이터를 저장 하기 위한 jetpack 라이브러리이다. Room은 데이터베이스의 데이터(객체)를 자바나 코틀린 객체로 매핑해주는 ORM 라이브러리 이다. 📍ORM(Object Relational Mapping) : 객체-관계 매핑의 줄인말로 객체와 관계형 데이터베이스의 데이터 를 자동으로 매핑(연결) 해주는 것을…","fields":{"slug":"/room-database/"},"frontmatter":{"date":"March 04, 2022","title":"안드로이드 Room 사용하면서 알아보기","tags":["Android","Room"]},"rawMarkdownBody":"<img src=\"https://user-images.githubusercontent.com/63226023/151594101-266890b7-079a-47c5-9daa-2afbc335ccb7.png\">\r\n\r\n# Room\r\nRoom은 안드로이드 __앱 내부에서 데이터를 저장__ 하기 위한 jetpack 라이브러리이다. Room은 데이터베이스의 데이터(객체)를 자바나 코틀린 객체로 매핑해주는 __ORM 라이브러리__ 이다.\r\n\r\n> 📍ORM(Object Relational Mapping) : 객체-관계 매핑의 줄인말로 __객체와 관계형 데이터베이스의 데이터__ 를 __자동으로 매핑(연결)__ 해주는 것을 말한다.\r\n\r\n 1. 객체 지향 프로그래밍에서는 __클래스__ 를 사용하고, 관계형 데이터베이스는 __테이블__ 을 사용하기 때문에 둘간의 __불일치__ 가 발생한다.\r\n 2. ORM을 통하여 객체의 관계를 자동으로 SQL문을 생성을 해주어 이러한 불일치 문제를 해결해준다.\r\n\r\n Room 라이브러리가 나오기전에는 SQLite을 사용하여 데이터를 저장하였다. SQLite를 사용하여 DB를 사용하기 위해선 여러가지 많은 작업들을 해주어야 한다.\r\n > 🤔 [SQLite를 사용하여 데이터 저장](https://developer.android.com/training/data-storage/sqlite?hl=ko)\r\n \r\n Room도 내부적으론 SQLite를 사용하지만 이를 좀더 편하게 사용할 수 있도록 제공하며 다양한 장점이 있다.\r\n\r\n - 컴파일 동안 SQL 쿼리의 유효성 검사 가능.\r\n - 오류가 발생하기 쉬운 상용구 코드없이 OBM 라이브러리를 통하여 매핑 가능.\r\n - 스키마 변경시 자동으로 업데이트가 가능.\r\n - LiveData, RxJava와 같이 사용 가능.\r\n\r\n- - -\r\n\r\n# Room의 구조 & Annotation\r\n<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/156314796-580f6154-d163-4642-912a-df39d48aa217.png\" width=\"70%\"></p>\r\n\r\nRoom 라이브러리의 구성요소는 Entity(데이터 모델), DAO(데이터 접근 객체), Database(데이터베이스 소유 객체)로 되어있다.\r\n\r\n## Entity\r\n데이터베이스에서 Table역할을 한다. class의 변수들의 column이 된다.\r\n\r\n- __@Entity(tableName = 원하는 테이블 이름)__\r\n    - Table의 이름을 설정해준다.(기본적으론 Entity class 이름을 Database table의 이름으로 인식한다) \r\n\r\n- __@PrimaryKey__\r\n    - 데이터베이스 의 기본키를 지정해준다.(모든 Entity는 __하나의 Primary Key__ 를 가지고 있어야한다)\r\n    - __(autoGenerate=true)__ 로 설정해주면 자동으로 Key값을 생성한다.\r\n\r\n- __@ColumnInfo__\r\n    - Table 내의 column을 변수들과 매칭한다.(기본적으론 Entity의 필드 이름을 열이름으로 인식한다)\r\n\r\n## DAO\r\n데이터베이스에 접근하여 상호작용하기 위한 작업들을 메서드 형태로 정의한다.\r\n\r\n- __@Insert__\r\n    - 파라미터로 넘겨받은 데이터를 테이블에 저장한다.\r\n    - __onConflict = OnConflictStrategy.REPLACE__ 를 사용하면 Update와 동일한 기능으로 사용할 수 있다. IGNORE을 사용하면 데이터 중복시 기존 데이터를 유지한다.\r\n\r\n- __@Update__\r\n    - 데이터베이스의 값을 업데이트한다. 리턴 값으로 업데이트된 행 수를 받을 수 있다.\r\n\r\n- __@Delete__\r\n    - 데이터베이스의 값을 삭제한다. 리턴 값으로 삭제된 행 수를 받을 수 있다.\r\n\r\n- __@Query__\r\n    - SQL 쿼리문을 사용하여 데이터베이스에서 읽기/쓰기 작업을 실행할 수 있다. 쿼리에 매개변수를 전달하려면 __:컬럼 이름__ 을 사용해야한다.\r\n    - Room은 컴파일 시간에 SQL 쿼리를 검증한다. 즉, 쿼리에 문제가 있으면 런타임 실패가 아닌 컴파일 오류가 발생한다.\r\n\r\n## Room Database\r\n데이터베이스의 소유자 역할로 __DB의 생성 및 버전을 관리__ 한다.\r\n\r\nRoom Database에서 DAO의 객체를 가져와 데이터를 \"CRUD\" 한다.\r\n\r\n- __@Database__\r\n    - class가 데이터베이스임을 알린다.\r\n        - __entities__ : DB에 어떤 테이블들이 있는지 정의한다.\r\n        - __version__ : DB의 버전을 정의한다. 스키마가 바뀌게 되면(Entity가 바뀐다면) version을 바꾸거나 Migration을 해야한다.\r\n        - __exportSchema__ : Room의 Schema 구조를 폴더로 Export 할 수 있다. DB 버전 히스토리를 기록할 수 있다는 점에서 __true로 설정하는 것이 좋다__.\r\n\r\n- - -\r\n\r\n# 사용법\r\n## 1. gradle 설정\r\n가장 먼저 room을 사용하기 위해서는 gradle을 설정해주어야 한다.\r\n\r\n```gradle\r\nplugins {\r\n        .\r\n        .\r\n    id 'kotlin-kapt'\r\n}\r\n        .\r\n        .\r\ndef roomVersion = \"2.4.1\"\r\nimplementation \"androidx.room:room-runtime:$roomVersion\"\r\nkapt \"androidx.room:room-compiler:$roomVersion\"\r\n```\r\n\r\n📍Room 라이브러리와 Coroutine을 함께 사용하기 위해서는 아래를 추가해줘야 한다.\r\n```gradle\r\nimplementation \"androidx.room:room-ktx:$roomVersion\"\r\n```\r\n\r\n## 2. Entity 생성\r\n```kotlin\r\n@Entity(tableName = \"myEntity\")\r\ndata class Subscriber(\r\n\r\n    @PrimaryKey(autoGenerate = true) // 자동으로 기본키를 생성\r\n    @ColumnInfo(name = \"myEntity_id\")\r\n    var id: Int,\r\n\r\n    @ColumnInfo(name = \"myEntity_name\")\r\n    var name: String,\r\n\r\n    @ColumnInfo(name = \"myEntity_email\")\r\n    var email: String\r\n\r\n)\r\n\r\n``` \r\n위의 예시에선 Entity의 테이블의 이름을 myEntity로 생성하고 Column의 이름을 사용자에 맞게 생성하였다.\r\n\r\n## 3. DAO 생성\r\n데이터베이스에 접근하여 사용할 메소드들을 생성해준다.\r\n\r\n```kotlin\r\n@Dao\r\ninterface SubscriberDAO {\r\n    @Insert\r\n    suspend fun insertSubscriber(subscriber: Subscriber)\r\n\r\n    @Update\r\n    suspend fun updateSubscriber(subscriber: Subscriber)\r\n\r\n    @Delete\r\n    suspend fun deleteSubscriber(subscriber: Subscriber)\r\n\r\n    @Query(\"DELETE FROM subscriber_data_table\")\r\n    suspend fun deleteAll()\r\n}\r\n```\r\n### 코루틴 suspend \r\n\r\n데이터베이스 접근이나 네트워킹과 같은 __메인 쓰레드를 Block 시킬 위험이 있는 작업__ 은 __백그라운드 쓰레드__ 로 스위칭을 해주어야 한다.\r\n\r\n코루틴의 `suspend` 키워드를 함수 앞에 붙임으로서 __suspend를 호출한 쓰레드는 일시 suspend(정지)__ 가 되고, 해당 suspend가 붙은 함수의 실행이 끝나고 다시 Resume(재개)된다. \r\n\r\nRoom, Retrofit과 같은 라이브러리는 `Main-safety` 가 보장되어 있어 메인 쓰레드에서 동작하여도 되어 `suspend` 를 사용하여 메인 쓰레드에서 동작하도록 하면 된다.\r\n\r\n## 4. Database 생성\r\n데이터베이스의 생성은 @Database를 통하여 이 클래스가 데이터베이스임을 명시해주고 __RoomDatabase()를 상속하여 abstract로 생성__ 한다. 또한 Dao를 데이터베이스에서 사용하기 위하여 __abstract dao를 가져야한다.__\r\n\r\nRoom 객체는 많은 리소스를 소모하며, 단일 프로세스 내에선 여러 인스턴스에 접근할 필요가 거의 없기 때문에 __Singleton__ 패턴을 사용하여 생성해 준다.\r\n\r\n\r\n```kotlin\r\n@Database(entities = [Subscriber::class], version = 1)\r\nabstract class SubscriberDatabase: RoomDatabase() {\r\n\r\n    abstract val subscriberDAO : SubscriberDAO\r\n\r\n    companion object {\r\n        @Volatile\r\n        private var INSTANCE : SubscriberDatabase? = null\r\n\r\n        fun getInstance(context: Context): SubscriberDatabase {\r\n            synchronized(this) {\r\n                var instance = INSTANCE\r\n                if (instance == null) {\r\n                    instance = Room.databaseBuilder(\r\n                        context.applicationContext,\r\n                        SubscriberDatabase::class.java,\r\n                        \"subscriber_data_database\"\r\n                    ).build()\r\n                }\r\n            return instance\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\nsynchronized 블록을 통하여 싱글톤 인스턴스가 중복되는것을 방지해준다. 또한 [@Volatile 어노테이션](https://nesoy.github.io/articles/2018-06/Java-volatile)을 접근가능한 변수의 값을 cache를 통해 사용하지 않고 쓰레드가 직접 main memory에 접근 하게하여 동기화한다. \r\n\r\n## 5. 생성된 DB 사용\r\n데이터베이스까지 완료되었다면 getInstance()함수를 통하여 사용할 위치에서 생성하여 사용한다.\r\n```kotlin\r\nval db = SubscriberDatabase.getInstance(application)\r\n```\r\n\r\n# 마무리\r\n이번 Room 라이브러리를 다시 정리해보며 코루틴의 `suspend`사용과 더불어 몰랐던 많은 새로운 내용들을 알게되었다🤔\r\n\r\n최근에 MVVM 패턴에 대한 내용을 접하면서 Room 라이브러리는 Repository와 같이 사용하는 것을 알게되었고, 정리한 내용들을 이러한 패턴과 적용시켜서 만들어 봐야겠다고 생각이 들었다.\r\n- - -\r\n\r\n# References\r\n\r\n- [Room을 사용하여 로컬 데이터베이스에 데이터 저장](https://developer.android.com/training/data-storage/room?hl=ko)\r\n- [[DB] ORM이란](https://gmlwjd9405.github.io/2019/02/01/orm.html)\r\n- [[Android, Kotlin] Retrofit, Room과 같은 동작에서의 Coroutine 쓰레드 처리](https://hungseong.tistory.com/9)"},{"excerpt":"코루틴 개요 스레드와 코루틴을 알아보면서 코루틴에 대한 개념을 알아보았었다. 스레드와 코루틴은 둘다 동시성을 보장  관점에서 보면 비슷한 개념이라고 생각이 든다. 코투린은 실행되다가 일시 정지(예: 일정 시간 대기) 할 때 코틀린 런타임에 의해 자신이 실행되던 스레드가 다른 코루틴 에 할당된다. 이번 포스팅을 통해 코루틴의 구현에 필요한 요소 들을 살펴보…","fields":{"slug":"/coroutine/"},"frontmatter":{"date":"February 14, 2022","title":"안드로이드 코루틴의 기초 알아보기","tags":["Android","Kotlin","Coroutine","비동기"]},"rawMarkdownBody":"<img src=\"https://user-images.githubusercontent.com/63226023/152948157-588cbe52-ea52-4654-9050-cd98db3a51ba.png\">\r\n\r\n# 코루틴 개요\r\n[스레드와 코루틴](https://ppeper.github.io/cs/thread-coroutine/)을 알아보면서 코루틴에 대한 개념을 알아보았었다. 스레드와 코루틴은 둘다 __동시성을 보장__  관점에서 보면 비슷한 개념이라고 생각이 든다.\r\n\r\n코투린은 실행되다가 __일시 정지(예: 일정 시간 대기)__ 할 때 코틀린 런타임에 의해 __자신이 실행되던 스레드가 다른 코루틴__ 에 할당된다. 이번 포스팅을 통해 __코루틴의 구현에 필요한 요소__ 들을 살펴보면서 대략적인 코루틴이란 무엇인지 알아보려고 한다👍\r\n\r\n## 안드로이드 앱의 메인 스레드\r\n안드로이드 앱이 처음 시작되면 런타인 시스템에서 하나의 스레드를 생성하며 이 스레드를 __메인 스레드(Main)__ 라고 한다. 모든 앱 컴포넌트들은 이 __메인 스레드__ 에서 실행이 되며, 주된 역할은 __사용자 인터페이스(UI)__ 를 처리하는 것이다.\r\n\r\n__메인 스레드__ 를 사용해서 __시간이 오래걸리는 작업__ 을 수행을 하게되면 __해당 작업이 끝날 때까지 앱 전체가 멈춘 것__ 🚫 처럼 보이게 된다. 이 경우에 안드로이드에서는 __'ANR(애플리케이션 응답 없음)'__ 오류가 발생하게 된다. 이때는 별도의 __백그라운드 스레드__ 에서 수행되어야 메인 스레드가 방해를 받지 않고 다른 작업을 계속하게 해주어야 한다.\r\n\r\n코루틴은 이러한 백그라운드 작업을 좀 더 효율적이고 간편하게 개발할 수 있도록 한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/152943012-23be57c1-e7ad-45ad-9d73-2d1d40522198.png\" width=\"30%\">\r\n\r\n코루틴을 시작하기 전에 간단하게 __메인 스레드__ 가 방해받는 예시를 보고 들어가 보려고한다. 이 예시에서는 `Click을 통하여 textview를 1씩 증가`를 하고 `Download data를 통하여 Log 메시지를 20만번` 보여주게 하려고 한다.\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n    private var count = 0\r\n    private lateinit var binding: ActivityMainBinding\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        binding = ActivityMainBinding.inflate(layoutInflater)\r\n        setContentView(binding.root)\r\n\r\n        binding.btnCount.setOnClickListener {\r\n            binding.tvCount.text = count++.toString()\r\n        }\r\n\r\n        binding.btnDownload.setOnClickListener {\r\n            downloadData()\r\n        }\r\n    }\r\n\r\n    private fun downloadData() {\r\n        for (i in 1..200000) {\r\n            Log.i(\"Coroutines\", \"Download $i in ${Thread.currentThread().name}\")\r\n        }\r\n    }\r\n}\r\n```\r\ndownloadData 함수에서 200000번 Log를 출력하고 btnCount는 클릭시 1씩 증가가 되어 사용자 인터페이스 UI에게 보여줄 것이다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/152945466-305bb24c-f0f0-427d-b210-430ae3c63d4a.png\">\r\n\r\nDownload Data 버튼을 클릭하면 Log창에 메시지가 뜨는것을 볼 수 있다. \r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/152945657-ca178551-6316-4f55-8428-68546ed3cae9.png\" width=\"31%\"> <img src=\"https://user-images.githubusercontent.com/63226023/152945695-995e7004-bffe-499d-aec4-9aa35fd31840.png\" width=\"30%\">\r\n\r\n이때 Click버튼을 계속 누르게 되면 __앱이 멈춘것처럼(Freezing)__ 있다가 __ANR__ 이 발생하여 앱이 종료되는 것을 볼 수 있다. 위에서 앱의 UI는 __메인 스레드__ 에서 처리한다고 하였는데 이때에 __메인 스레드에서 바쁘게 작업을 하고 있기 때문에__  UI를 처리하는데 문제가 생긴 것이다.\r\n\r\n```kotlin\r\nbinding.btnDownload.setOnClickListener {\r\n    CoroutineScope(Dispatchers.IO).launch {\r\n        downloadData()\r\n    }\r\n}\r\n```\r\n해당 문제를 해결하기 위해 downloadData를 다음으로 감싼다. 코루틴 관련한 개념은 차차 알아가 보려고 한다.\r\n\r\n해당 코드를 추가하고 앱을 실행해보면 Download Data를 클릭을 한 후 Click을 하여도 숫자가 잘 증가하는 것을 볼 수 있다😮\r\n\r\n- - -\r\n\r\n# 코루틴 사용하기\r\n코루틴의 사용하기 위해서는 dependency를 추가해야 한다.\r\n```xml\r\ndependencies {\r\n    .\r\n    .\r\n    .\r\n    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.1'\r\n    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.5.0'\r\n}\r\n```\r\n코루틴을 사용할 준비가 되었다면 크게 다음과 같은 코루틴의 구성요소로 사용한다.\r\n- 코루틴 범위(Scope)\r\n- 코루틴 디스패처(Dispatchers)\r\n- 코루틴 시작\r\n\r\n## 코루틴 범위(Scope)\r\n모든 코루틴은 ~~개별적으로 실행되지 않고~~ 그룹으로 관리될 수 있는 __범위__ 에서 실행이 되어야 한다. 범위에서 실행을 하여 액티비티나 프래그먼트가 소멸될때 이와 관련된 코루틴도 한번에 취소 또는 소멸을 하여 __메모리 누수__ 가 생기지 않게 해준다.\r\n\r\n코틀린은 커스텀 범위의 생성뿐만 아니라 내장된 범위도 지원한다.\r\n\r\n- __GlobalScope__ : __앱의 전체 생명주기와 같이 실행__ 이 되기 때문에 __앱이 시작될 때 생성되어 종료되어야만 메모리에서 해제__ 된다. 코루틴이 필요가 없어도(예: 액티비티가 종료) 계속 실행될 가능성이 있으므로 안드로이드 앱에서는 사용하지 않는 것을 권장한다.\r\n\r\n- __ViewModelScope__ : __ViewModel 컴포넌트를 사용__ 할 때 ViewModel 인스턴스에서 사용하기 위해 제공된다. ViewModel 인스턴스가 소멸될 때 코틀린 런타임에 의해 자동으로 취소된다.\r\n\r\n이 외에는 커스텀 범위가 사용된다. 이때에 사용되는 스코프는 __CoroutineScope__ 이다.\r\n\r\n- __CoroutineScope__ : 코루틴 라이브러리에서 __기본적으로 제공__ 하는 스코프이다. 액티비티가 종료되거나 클래스의 인스턴스가 소멸되면 메모리에서 해제된다.\r\n\r\n```kotlin\r\nbinding.btnDownload.setOnClickListener {\r\n    CoroutineScope(Dispatchers.IO).launch {\r\n        downloadData()\r\n    }\r\n}\r\n```\r\n위의 예시를 보면 `CoroutineScope` 를 사용하여 코루틴 실행에 사용될 `Dispatchers.Main` 디스패처를 갖는 __코루틴 범위__ 를 선언하였다. \r\n\r\n## 코루틴 디스패처(Dispatchers)\r\n코틀린은 서로 다른 유형의 __비동기 작업 스레드__ 를 유지 관리한다. 코루틴을 시작할때 이러한 디스패처를 지정해 주어야 한다.\r\n- __Dispatchers.Main__ : __메인 스레드__ 에서 코루틴을 실행한다. UI를 변경할 필요가 있는 코루틴에 적합하며, 경량의 작업을 사용하는데 보편적으로 사용된다.\r\n\r\n- __Dispatchers.IO__ : __네트워크, 디스크, 데이터베이스 작업__ 을 수행하는 코루틴에 적합하다.\r\n\r\n- __Dispatchers.Default__ : 안드로이드의 __기본 스레드풀을 사용__ 한다. __데이터의 정렬이나 복잡한 연산__ 과 같은 CPU를 많이 사용하는 코루틴에 적합하다.\r\n\r\n## 코루틴 시작\r\n코루틴의 범위와 디스패처를 정했으면 코루틴을 시작할 준비가 되었다. 코루틴을 동작하기 위해선 __launch__ 와 __async__ 로 시작을 하면된다.\r\n\r\n- __launch__ \r\n    - 결과를 반환❌\r\n    - Job 객체를 반환한다.\r\n- __async__ \r\n    - 결과를 반환⭕\r\n    - Deffered 객체를 반환한다.\r\n\r\n- - -\r\n\r\n# References \r\n- 안드로이드 스튜디오 Arctic Fox & 프로그래밍                                  "},{"excerpt":"문제 설명 카카오는 하반기 경력 개발자 공개채용을 진행 중에 있으며 현재 지원서 접수와 코딩테스트가 종료되었습니다. 이번 채용에서 지원자는 지원서 작성 시 아래와 같이 4가지 항목을 반드시 선택하도록 하였습니다. 코딩테스트 참여 개발언어 항목에 cpp, java, python 중 하나를 선택해야 합니다. 지원 직군 항목에 backend와 frontend …","fields":{"slug":"/programmers-kakao-blind-2021-1/"},"frontmatter":{"date":"February 11, 2022","title":"프로그래머스 2021 KAKAO BLIND RECRUITMENT - 순위 검색","tags":["Algorithm","programmers"]},"rawMarkdownBody":"### 문제 설명\r\n\r\n카카오는 하반기 경력 개발자 공개채용을 진행 중에 있으며 현재 지원서 접수와 코딩테스트가 종료되었습니다. 이번 채용에서 지원자는 지원서 작성 시 아래와 같이 4가지 항목을 반드시 선택하도록 하였습니다.\r\n\r\n- 코딩테스트 참여 개발언어 항목에 cpp, java, python 중 하나를 선택해야 합니다.\r\n- 지원 직군 항목에 backend와 frontend 중 하나를 선택해야 합니다.\r\n- 지원 경력구분 항목에 junior와 senior 중 하나를 선택해야 합니다.\r\n- 선호하는 소울푸드로 chicken과 pizza 중 하나를 선택해야 합니다.\r\n\r\n인재영입팀에 근무하고 있는 니니즈는 코딩테스트 결과를 분석하여 채용에 참여한 개발팀들에 제공하기 위해 지원자들의 지원 조건을 선택하면 해당 조건에 맞는 지원자가 몇 명인 지 쉽게 알 수 있는 도구를 만들고 있습니다.   \r\n예를 들어, 개발팀에서 궁금해하는 문의사항은 다음과 같은 형태가 될 수 있습니다.\r\n`코딩테스트에 java로 참여했으며, backend 직군을 선택했고, junior 경력이면서, 소울푸드로 pizza를 선택한 사람 중 코딩테스트 점수를 50점 이상 받은 지원자는 몇 명인가?`\r\n\r\n물론 이 외에도 각 개발팀의 상황에 따라 아래와 같이 다양한 형태의 문의가 있을 수 있습니다.\r\n\r\n- 코딩테스트에 python으로 참여했으며, frontend 직군을 선택했고, senior 경력이면서, 소울푸드로 chicken을 선택한 사람 중 코딩테스트 점수를 100점 이상 받은 사람은 모두 몇 명인가?\r\n- 코딩테스트에 cpp로 참여했으며, senior 경력이면서, 소울푸드로 pizza를 선택한 사람 중 코딩테스트 점수를 100점 이상 받은 사람은 모두 몇 명인가?\r\n- backend 직군을 선택했고, senior 경력이면서 코딩테스트 점수를 200점 이상 받은 사람은 모두 몇 명인가?\r\n- 소울푸드로 chicken을 선택한 사람 중 코딩테스트 점수를 250점 이상 받은 사람은 모두 몇 명인가?\r\n- 코딩테스트 점수를 150점 이상 받은 사람은 모두 몇 명인가?\r\n\r\n즉, 개발팀에서 궁금해하는 내용은 다음과 같은 형태를 갖습니다.\r\n```\r\n* [조건]을 만족하는 사람 중 코딩테스트 점수를 X점 이상 받은 사람은 모두 몇 명인가?\r\n```\r\n\r\n지원자가 지원서에 입력한 4가지의 정보와 획득한 코딩테스트 점수를 하나의 문자열로 구성한 값의 배열 info, 개발팀이 궁금해하는 문의조건이 문자열 형태로 담긴 배열 query가 매개변수로 주어질 때,\r\n각 문의조건에 해당하는 사람들의 숫자를 순서대로 배열에 담아 return 하도록 solution 함수를 완성해 주세요.\r\n\r\n### 제한사항\r\n\r\n- info 배열의 크기는 1 이상 50,000 이하입니다.\r\n- info 배열 각 원소의 값은 지원자가 지원서에 입력한 4가지 값과 코딩테스트 점수를 합친 \"개발언어 직군 경력 소울푸드 점수\" 형식입니다.\r\n    - 개발언어는 cpp, java, python 중 하나입니다.\r\n    - 직군은 backend, frontend 중 하나입니다.\r\n    - 경력은 junior, senior 중 하나입니다.\r\n    - 소울푸드는 chicken, pizza 중 하나입니다.\r\n    - 점수는 코딩테스트 점수를 의미하며, 1 이상 100,000 이하인 자연수입니다.\r\n    - 각 단어는 공백문자(스페이스 바) 하나로 구분되어 있습니다.\r\n- query 배열의 크기는 1 이상 100,000 이하입니다.\r\n- query의 각 문자열은 \"[조건] X\" 형식입니다.\r\n    - [조건]은 \"개발언어 and 직군 and 경력 and 소울푸드\" 형식의 문자열입니다.\r\n    - 언어는 cpp, java, python, - 중 하나입니다.\r\n    - 직군은 backend, frontend, - 중 하나입니다.\r\n    - 경력은 junior, senior, - 중 하나입니다.\r\n    - 소울푸드는 chicken, pizza, - 중 하나입니다.\r\n    - '-' 표시는 해당 조건을 고려하지 않겠다는 의미입니다.\r\n    - X는 코딩테스트 점수를 의미하며 조건을 만족하는 사람 중 X점 이상 받은 사람은 - 모두 몇 명인 지를 의미합니다.\r\n    - 각 단어는 공백문자(스페이스 바) 하나로 구분되어 있습니다.\r\n    - 예를 들면, \"cpp and - and senior and pizza 500\"은 \"cpp로 코딩테스트를 봤으며, 경력은 senior 이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 500점 이상 받은 사람은 모두 몇 명인가?\"를 의미합니다.\r\n\r\n### 입출력 예\r\n<img src=\"https://user-images.githubusercontent.com/63226023/153607140-6278337f-e49e-44d4-97d5-ee0f002150ba.png\">\r\n\r\n\r\n### 풀이\r\n문제의 요구사항을 보고 `어떠한 query가 맞나` -> `점수 비교` 라고 간단하게 생각을 해보았을 때 key-value 형태로 나타내어 일단 `HashMap`을 사용해야 하겠다고 생각하였다.\r\n\r\ninfo와 query에서 `-`는 해당 조건을 고려하지 않는다고 하였으므로 info에서 query로 나올 수있는 `모든 조합`을 `-`를 포함하여 만들어 해당하는 query는 다 같은 info의 점수로 저장한다.   \r\n점수를 여러개 저장하기 위하려면 (String, List) 형태를 사용하였다.\r\n```java\r\n // 모든 나올수 있는 조합을 뽑아서 List에 넣는다\r\nprivate void DFS(String str, int depth, String[] info) {\r\n    if (depth == 4) {\r\n        // 해당 조합의 사용자 정보가 저장 안되어있다면\r\n        if (!allInfoValue.containsKey(str)) {\r\n            ArrayList<Integer> list = new ArrayList<>();\r\n            // 점수 저장\r\n            list.add(Integer.parseInt(info[4]));\r\n            allInfoValue.put(str, list);\r\n        } else {\r\n            // 해당 조합의 사용자 전보가 저장되어 있으면 -> list를 가져와서 해당 점수만 추가\r\n            allInfoValue.get(str).add(Integer.parseInt(info[4]));\r\n        }\r\n        return;\r\n    }\r\n    DFS(str + \"-\", depth + 1, info);\r\n    DFS(str + info[depth], depth + 1, info);\r\n}\r\n```\r\n점수의 비교를 위하여 `오름차순`으로 점수를 저장을하여 `이진탐색`을 사용하여 시간복잡도를 더 줄이는 방법을 사용한다.\r\n```java\r\n// 해당 key값에 대한 점수를 오름차순으로 모두 정렬한다.\r\nArrayList<String> keys = new ArrayList<String>(allInfoValue.keySet());\r\nfor (String str: keys) {\r\n    Collections.sort(allInfoValue.get(str));\r\n}\r\n\r\n// 이진탐색을 사용하여 answer을 구해준다.\r\n    private int searchValue(String query, int score) {\r\n        // 해당하는 질의에 만족하지 않으면\r\n        if (!allInfoValue.containsKey(query)) {\r\n            return 0;\r\n        } else {\r\n            ArrayList<Integer> value = allInfoValue.get(query);\r\n            int start = 0, end = value.size() - 1;\r\n            // 이진탐색\r\n            while (start <= end) {\r\n                int mid = (start + end) / 2;\r\n                if (value.get(mid) < score) {\r\n                    start = mid + 1;\r\n                } else {\r\n                    end = mid - 1;\r\n                }\r\n            }\r\n            return value.size() - start;\r\n        }\r\n    }\r\n```\r\n# 코드\r\n\r\n```java\r\nimport java.util.*;\r\n\r\nclass Solution {\r\n    HashMap<String, ArrayList<Integer>> allInfoValue = new HashMap<>();\r\n    public int[] solution(String[] info, String[] query) {\r\n        int[] answer = new int[query.length];\r\n        // 모든 경우의 key값을 구한다.\r\n        for (String str : info) {\r\n            DFS(\"\", 0, str.split(\" \"));\r\n        }\r\n        // 해당 key값에 대한 점수를 오름차순으로 모두 정렬한다.\r\n        ArrayList<String> keys = new ArrayList<String>(allInfoValue.keySet());\r\n        for (String str: keys) {\r\n            Collections.sort(allInfoValue.get(str));\r\n        }\r\n\r\n        // 원하는 값 구하기\r\n        for (int i = 0; i < query.length; i++) {\r\n            // java and backend and junior and pizza 100 -> javabackendjuniorpizza 100\r\n            String replace = query[i].replaceAll(\" and \", \"\");\r\n            String[] str = replace.split(\" \");\r\n            answer[i] = searchValue(str[0], Integer.parseInt(str[1]));\r\n        }\r\n        return answer;\r\n    }\r\n\r\n    // 모든 나올수 있는 조합을 뽑아서 List에 넣는다\r\n    private void DFS(String str, int depth, String[] info) {\r\n        if (depth == 4) {\r\n            // 해당 조합의 사용자 정보가 저장 안되어있다면\r\n            if (!allInfoValue.containsKey(str)) {\r\n                ArrayList<Integer> list = new ArrayList<>();\r\n                // 점수 저장\r\n                list.add(Integer.parseInt(info[4]));\r\n                allInfoValue.put(str, list);\r\n            } else {\r\n                // 해당 조합의 사용자 전보가 저장되어 있으면 -> list를 가져와서 해당 점수만 추가\r\n                allInfoValue.get(str).add(Integer.parseInt(info[4]));\r\n            }\r\n            return;\r\n        }\r\n        DFS(str + \"-\", depth + 1, info);\r\n        DFS(str + info[depth], depth + 1, info);\r\n    }\r\n\r\n    // 이진탐색을 사용하여 answer을 구해준다.\r\n    private int searchValue(String query, int score) {\r\n        // 해당하는 질의에 만족하지 않으면\r\n        if (!allInfoValue.containsKey(query)) {\r\n            return 0;\r\n        } else {\r\n            ArrayList<Integer> value = allInfoValue.get(query);\r\n            int start = 0, end = value.size() - 1;\r\n            // 이진탐색\r\n            while (start <= end) {\r\n                int mid = (start + end) / 2;\r\n                if (value.get(mid) < score) {\r\n                    start = mid + 1;\r\n                } else {\r\n                    end = mid - 1;\r\n                }\r\n            }\r\n            return value.size() - start;\r\n        }\r\n    }\r\n}\r\n```"},{"excerpt":"안드로이드 앱은 되면 'ANR(애플리케이션 응답 없음)' 오류가 발생하게 된다❗ 앱에서 개발을 하다보면 비동기 백그라운드 작업 을 통하여 이러한 ANR이 발생하지 않도록 노력을 해야한다.  처음으로 앱을 개발할때 네트워크 통신을 할때 위와 같은 문제에 봉착하여 큰 난관에 빠졌었던 기억이 많다. 이번 포스팅을 시작으로 비동기 작업 을 공부하며 정리해 보려고…","fields":{"slug":"/thread-coroutine/"},"frontmatter":{"date":"February 07, 2022","title":"Thread와 Coroutine 짚고 넘어가기","tags":["OS","비동기"]},"rawMarkdownBody":"<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/152731810-a0d2ddc8-cbee-48b0-8398-3b6deb4f0233.png\"></p>\r\n\r\n> - 안드로이드 앱은 `UI 스레드가 너무 오랫동안 차단`되면 'ANR(애플리케이션 응답 없음)' 오류가 발생하게 된다❗\r\n> - 앱에서 개발을 하다보면 __비동기 백그라운드 작업__ 을 통하여 이러한 ANR이 발생하지 않도록 노력을 해야한다. \r\n\r\n처음으로 앱을 개발할때 네트워크 통신을 할때 위와 같은 문제에 봉착하여 큰 난관에 빠졌었던 기억이 많다. 이번 포스팅을 시작으로 __비동기 작업__ 을 공부하며 정리해 보려고 한다🤔\r\n\r\n📍 잠깐 짚고 넘어가기\r\n> __동기(synchronous : 동시에 일어나는)__ : 요청을 보내면 결과값이 오기까지 작업을 멈춘다.   \r\n> __비동기(Asynchronous : 동시에 일어나지 않는)__ : 요청을 보내면 작업을 멈추지 않고 다른 일을 수행한다.\r\n- - -\r\n\r\n# Thread 개요\r\n스레드는 멀티태스킹 운영체제의 초석으로 __메인 프로세스 내__ 에서 __작은 프로세스가 실행__ 되는 것으로 생각할 수 있다. \r\n\r\n> 📍스레드의 목적은 앱 내부에서 __병렬로 실행될 수 있는 코드__ 를 만드는 것\r\n\r\n# 🤔알아보고 가기\r\n## Process vs Thread\r\n프로세스와 비슷해보이는 스레드를 알아보기전에 `~ 프로그램`이라는 말을 많이 들어봤을 것이다.   \r\n프로그램의 예시는 흔히 위도우 컴퓨터에서 볼 수 있는 __.exe__ 파일이라고 생각하면 된다.\r\n> 📍Program : __보조기억장치에 존재하는 실행파일__\r\n\r\n이러한 `프로그램`은 사용자가 클릭을 하여 운영체제가 `실행`을 하게 해야한다. 즉 실행되고 있는 프로그램이 __프로세스__ 라고 할 수 있다.\r\n\r\n <p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/152743857-ac10d808-8324-461b-9f97-40a07e1eeadb.png\"></p>\r\n\r\n> 📍Process : __메모리에 올라와 실행되고 있는 프로그램__ 의 인스턴스\r\n\r\n🔔프로세스는 다음과 같은 특징이 있다.\r\n - 프로세스는 하나 이상의 스레드(메인 스레드)를 포함한다.\r\n - 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.\r\n - 다른 프로세스의 자원에 접근을 하려면 프로세스간 통신(IPC: Inter-Process-Communication)을 사용해야 한다.\r\n - 프로세스는 각각 __Code, Data, Stack, Heap의 구조__ 로 되어있는 __독립된 메모리 영역__ 을 할당 받는다.\r\n\r\n - - -\r\n\r\n 그렇다면 하나의 예시로 크롬창(하나의 프로세스)으로 웹 서핑을 하고 있다고 생각해 보자. 사용자들은 백그라운드로 게임을 다운하면서 웹 서핑을 계속 하고싶을 것이다. 이러한 __하나의 프로세스에서 더 작인 실행 단위__ 를 여러 __스레드__ 를 통하여 실행하게 된다.\r\n\r\n <p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/152743769-aa8ae95c-6af9-4369-98f1-92504df1bb76.png\"></p>\r\n\r\n > 📍Thread : 독립적인 메모리공간(Stack)을 가지는 __프로세스 내에서 실행되는 여러 흐름 단위__\r\n\r\n 🔔스레드는 다음과 같은 특징이 있다.\r\n - 하나의 스레드는 __독립적인 메모리공간(Stack)__ 을 할당 받고 프로세스의 Code, Data, Heap 영역은 공유한다.\r\n - 각 스레드는 Stack 메모리를 공유할 수 없다.\r\n\r\n# 동시성 vs 병렬성\r\nThread와 코루틴은 모두 __동시성 프로그래밍__ 을 위한 기술이다.\r\n## 동시성 (Concurrency)\r\n<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/152747561-c8870560-b07d-403a-8cbb-695a0fba3cce.png\"></p>\r\n\r\n동시성 프로그래밍은 여러 작업을 __동시에 실행__ 하는 것이다. 말은 동시에 실행이라고 하였지만 이는 __작업들을 잘게 쪼게어 빠르게 번갈아가며 수행__ 하여 두 작업은 __동시에 실행되는 것__ 처럼 느껴지게 하는 것이다.\r\n\r\n## 병렬성 (Parallelism)\r\n<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/152748798-19726566-bf04-4b27-9453-cd23b31f6b21.png\"></p>\r\n\r\n병렬성 프로그래밍은 말 그대로 여러 작업을 __한 번에 동시에 실행__ 하는 것이다. 즉 병렬성은 실행시키는 자원(CPU 코어)이 여러개(멀티코어)일때 가능한 방법이다.\r\n\r\n# Thread vs Coroutine\r\nThread와 Coroutine은 둘다 __동시성을 보장__ 하기 위해 사용된다. 처음 코루틴에 대한 용어를 알게되어 찾아봤을때는 스레드와 별반 차이를 몰랐었다. 스레드와 코루틴의 개념을 알아보면서 둘의 차이점을 알아보았다.\r\n\r\n## Thread\r\n- 작업의 단위 -> __Thread__\r\n    - Thread는 독립적인 메모리공간(Stack)을 가진다\r\n- 동시성 보장 수단: __Context Switching__\r\n    - OS 커널에 의한 __Context Switching__ 을 사용한다.\r\n    - 블로킹 : (Thread 1) 이 (Thread 2) 의 결과가 나오기까지 기다려야한다면 (Thread 1)은 __블로킹__ 되어 그 시간동안 해당 자원을 사용하지 못한다.\r\n\r\n> __🤔Context Switching?__   \r\n> - CPU에서 여러 프로세스를 번갈아 가면서 작업을 처리하는 데 이 과정을 Context Switching라 한다.   \r\n> - 구체적으로, 동작중인 프로세스가 대기 할때 해당 프로세스의 정보(Context)를 보관하고 있다가 다음 순서의 프로세스가 동작할때 해당 정보(Context)를 통하여 상태를 복구하는 작업을 말한다.\r\n\r\n<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/152752310-17cd2826-0ad2-476f-aa85-e059b251d86b.png\"></p>\r\n\r\n위의 그림을 보면 작업 단위는 모두 Thread인것을 볼 수 있다. 위의 그림에서 __동시성이 보장__ 이 되는 과정을 보자.\r\n\r\n- Thread A 에서 작업 1을 수행중에 작업 2가 필요할때 이를 __비동기로 호출__ 하게 된다.\r\n- 이 때 Thread A 는 __작업을 멈추고(블로킹)__ 되고, __Thread B 로 Context Switching__ 이 일어나 작업 2 를 수행한다.\r\n- 작업 2가 완료되면 해당 결과값을 __Thread A 로 Context Switching__ 이 일어나 작업 1에 반환하게 되고, 동시에 수행할 작업 3과 작업 4는 각각 Thread C 와 Thread D 에 할당된다.\r\n- OS 커널에서는 __Preempting Scheduling__ 을 통하여 각 작업에 대해 __얼만큼 수행할지 또는 어떤 작업을 먼저 수행할지를 결정__ 하여 그에 맞게 동작을 하게 하여 __동시성을 보장__ 하게 되는 것이다.\r\n\r\n## Coroutine\r\n- 작업의 단위 -> __Object(Coroutine)__\r\n    - 여러 작업에 각각 __Object__ 를 할당한다.\r\n    - __Coroutine Object__ 는 객체를 담는 __JVM Heap__ 에 적재됩니다.\r\n- 동시성 보장 수단: __Programmer Switching__ = ~~No Context Switching~~\r\n    - __프로그래머의 코딩__ 을 통해 Switching 시점을 마음대로 정한다.\r\n    - __Suspend__ (Non-Blocking): `Object 1(작업 1)`이 `Object 2(작업 2)`의 __결과가 나오기까지 기다려야한다__ 면\r\n    `Object 1(작업 1)`는 __Suspend(중지)__ 되지만 `Object 1(작업 1)`를 수행하던 __Thread 는 그대로 유효__ 하기 때문에 `Object 2(작업 2)` 도 `Object 1(작업 1)` 과 __동일한 Thread 에서 실행__ 될 수 있다.\r\n\r\n<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/152752334-57ccdaa1-cea6-43d4-a17f-72444f42a64d.png\"></p>\r\n\r\n작업의 단위는 __Coroutine Object__ 이므로 작업 1 수행중에 비동기 작업 2가 발생하더라도 작업 1을 수행하던 같은 __Thread에서 작업 2를 수행할 수 있으며__, __하나의 Thread__ 에서 __여러개의 Coroutine Object__ 들을 수행할 수도 있다.\r\n\r\n위의 그림에서 작업 1에서 작업 2의 전환에 있어서 __Thread A 위에서 Coroutine Object 객체들만 교체__ 만  이뤄지기 때문에 Context Switching 은 필요가 없다.   \r\nCoroutine은 한 Thread 에 __다수의 작업(Objcet)__ 을 수행할 수 있음과 __Context Switching 이 필요없기__ 때문에 __Lightweight Thread__ 라고도 불린다.\r\n\r\n다만 위의 세번째 그림에서 처럼 작업 3, 작업 4를 위해 Thread C가 동시에 실행이 된다면, __동시성을 보장__ 하기 위하여 Context Switching이 필요하다. 따라서 Coroutine의 __No Context Switching 이라는 장점__ 을 최대한 활용하기 위해 ~~여러 Thread 를 사용하는 것~~보다 __단일 Thread 에서 여러 Coroutine Object 들을 실행하는 것__ 이 좋다😮\r\n\r\n> 💡Coroutine 은 ~~Thread 의 대안~~이 아니라 __기존의 Thread__ 를 __더 잘게 쪼개어 사용__ 하기위한 개념이다.   \r\n>    - 작업의 단위가 Thread가 아닌 Object 단위로 축소하면서 __단일 Thread가 여러 코루틴을 다룰 수 있기 때문__ 에 작업의 수만큼 Thread를 생성하지 않아도 되어 __메모리 낭비, Context Switching__ 의 비용 낭비를 할 필요가 없다.\r\n\r\n\r\n# 마무리 정리\r\n처음 Coroutine의 용어를 접했을 때는 Thread와의 차이를 알지 못하고 같은 작업을 한다고 생각하였었다😂\r\n\r\n앱 개발에서 __비동기 작업__(DB 트랜잭션, 네트워킹 요청등)은 거의 필수적으로 사용한다고 생각한다. 이러한 __비동기 작업__ 은 앞서 정리한 내용과 같이 __Coroutine을 활용__ 하여 비용절감을 할 수 있기 때문에 안드로이드 공부를 꾸준히 해가면서 많이 접하고 적극적으로 사용해봐야겠다👍\r\n\r\n- - -\r\n\r\n# References\r\n\r\n- [https://velog.io/@haero_kim/Thread-vs-Coroutine-%EB%B9%84%EA%B5%90%ED%95%B4%EB%B3%B4%EA%B8%B0#process-with-thread]()\r\n- [https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html]()\r\n- [https://velog.io/@gparkkii/ProgramProcessThread]()"},{"excerpt":"문제 설명 지도개발팀에서 근무하는 제이지는 지도에서 도시 이름을 검색하면 해당 도시와 관련된 맛집 게시물들을 데이터베이스에서 읽어 보여주는 서비스를 개발하고 있다.\n이 프로그램의 테스팅 업무를 담당하고 있는 어피치는 서비스를 오픈하기 전 각 로직에 대한 성능 측정을 수행하였는데, 제이지가 작성한 부분 중 데이터베이스에서 게시물을 가져오는 부분의 실행시간이…","fields":{"slug":"/programmers-kakao-blind-2018-1/"},"frontmatter":{"date":"February 05, 2022","title":"프로그래머스 2018 KAKAO RECRUITMENT - [1차]캐시","tags":["Algorithm","programmers"]},"rawMarkdownBody":"### 문제 설명\r\n\r\n지도개발팀에서 근무하는 제이지는 지도에서 도시 이름을 검색하면 해당 도시와 관련된 맛집 게시물들을 데이터베이스에서 읽어 보여주는 서비스를 개발하고 있다.\r\n이 프로그램의 테스팅 업무를 담당하고 있는 어피치는 서비스를 오픈하기 전 각 로직에 대한 성능 측정을 수행하였는데, 제이지가 작성한 부분 중 데이터베이스에서 게시물을 가져오는 부분의 실행시간이 너무 오래 걸린다는 것을 알게 되었다.\r\n어피치는 제이지에게 해당 로직을 개선하라고 닦달하기 시작하였고, 제이지는 DB 캐시를 적용하여 성능 개선을 시도하고 있지만 캐시 크기를 얼마로 해야 효율적인지 몰라 난감한 상황이다.\r\n\r\n어피치에게 시달리는 제이지를 도와, DB 캐시를 적용할 때 캐시 크기에 따른 실행시간 측정 프로그램을 작성하시오.\r\n\r\n### 입력 형식\r\n* 캐시 크기(`cacheSize`)와 도시이름 배열(`cities`)을 입력받는다.\r\n* `cacheSize`는 정수이며, 범위는 0 ≦ `cacheSize` ≦ 30 이다.\r\n* `cities`는 도시 이름으로 이뤄진 문자열 배열로, 최대 도시 수는 100,000개이다.\r\n* 각 도시 이름은 공백, 숫자, 특수문자 등이 없는 영문자로 구성되며, 대소문자 구분을 하지 않는다. 도시 이름은 최대 20자로 이루어져 있다.\r\n\r\n### 출력 형식\r\n* 입력된 도시이름 배열을 순서대로 처리할 때, \"총 실행시간\"을 출력한다.\r\n\r\n### 제한사항\r\n* 캐시 교체 알고리즘은 `LRU`(Least Recently Used)를 사용한다.\r\n* `cache hit`일 경우 실행시간은 `1`이다.\r\n* `cache miss`일 경우 실행시간은 `5`이다.\r\n\r\n### 입출력 예\r\n<img src=\"https://user-images.githubusercontent.com/63226023/152626198-05c7d28f-2480-4a3b-945d-c974c35638d4.png\">\r\n\r\n### 풀이\r\n문제에서 요구하는 __LRU__ 캐시 교환 알고리즘은 __가장 최근에 사용된 적이 없는 캐시의 메모리부터 대체하며 새로운 데이터로 갱신__ 하는 방법이다. 가장 사용안됨 Last -> 새로 교체는 FIFO구조로 보아 __Queue__ 를 사용하였다. \r\n\r\n- 캐시가 hit면 1을 더하고 데이터를 삭제후 다시 캐시에 넣어줘서 업데이트\r\n- 캐시가 miss면 5를 더함\r\n    - 캐시 크기가 남아있다면 그냥 데이터를 캐시에 넣어줌\r\n    - 캐시가 꽉 차있다면 `캐시 교환`을 해줌\r\n\r\n# 코드\r\n\r\n```java\r\nimport java.util.LinkedList;\r\nimport java.util.Queue;\r\n\r\nclass Solution {\r\n    public int solution(int cacheSize, String[] cities) {\r\n        int answer = 0;\r\n        if (cacheSize == 0) {\r\n            return answer += 5 * cities.length;\r\n        }\r\n        Queue<String> LRU = new LinkedList<>();\r\n        for (String str : cities) {\r\n            String city = str.toUpperCase();\r\n            if (LRU.isEmpty()) {\r\n                LRU.offer(city);\r\n                answer += 5;\r\n            } else {\r\n                // cache hit!\r\n                if (checkCache(LRU, city)) {\r\n                    answer += 1;\r\n                    LRU.remove(city);\r\n                    LRU.offer(city);\r\n                } else { // cache miss!\r\n                    if (LRU.size() == cacheSize) {\r\n                        LRU.poll();\r\n                    }\r\n                    LRU.offer(city);\r\n                    answer += 5;\r\n                }\r\n            }\r\n        }\r\n        return answer;\r\n    }\r\n    // 캐쉬에 해당 도시가 있으면 true\r\n    private boolean checkCache(Queue<String> LRU, String city) {\r\n        return LRU.contains(city);\r\n    }\r\n}\r\n```\r\n"},{"excerpt":"이전의 포스팅은 를 추가하였었다.😀\n안드로이드 Jetpack의 LiveData 적용하기 이번에는 ACC 구성요소의 DataBinding 을 LiveData와 함께 사용하여 프로젝트를 더 개선된 형태로 만들어 보려고 한다. DataBinding(데이터 바인딩) 데이터 바인딩 의 주목적은 UI 레이아웃의 뷰(xml)와 앱 코드에 저장된 데이터(주요사용->Vi…","fields":{"slug":"/databinding/"},"frontmatter":{"date":"February 02, 2022","title":"안드로이드 DataBinding + LiveData 적용하기","tags":["Android","DataBinding","ACC"]},"rawMarkdownBody":"<img src=\"https://user-images.githubusercontent.com/63226023/151594101-266890b7-079a-47c5-9daa-2afbc335ccb7.png\">\r\n\r\n이전의 포스팅은 `ViewModel에 LiveData`를 추가하였었다.😀\r\n[안드로이드 Jetpack의 LiveData 적용하기](https://ppeper.github.io/android/android-livedata/) 이번에는 ACC 구성요소의 __DataBinding__ 을 LiveData와 함께 사용하여 프로젝트를 더 개선된 형태로 만들어 보려고 한다.\r\n- - - \r\n# DataBinding(데이터 바인딩)\r\n__데이터 바인딩__ 의 주목적은 __UI 레이아웃의 뷰(xml)와 앱 코드에 저장된 데이터(주요사용->ViewModel 인스턴스)와 연결__ 하는 __간단한 방법__ 을 제공하는 것이다.\r\n\r\n> 📍 데이터 바인딩을 통하여 불필요한 코드를 줄여줄수 있다.\r\n\r\n데이터 바인딩은 `LiveData 컴포넌트와 같이 사용`될 때 특히 좋다. [LiveData 컴포넌트](https://ppeper.github.io/android/android-livedata/)는 실시간으로 데이터의 변경을 감시하기 때문에 __데이터 바인딩__ 을 사용하여 UI와 앱 코드와 연결을 하게되면 데이터가 자동으로 LiveData 값을 변경할 수도 있다. 데이터 바인딩은 초기의 설정 외에 개발자가 추가로 작성할 코드가 필요 없다는 것도 큰 장점이다.\r\n\r\n# 데이터 바인딩 사용하기\r\n데이터 바인딩을 사용하기 위하 초기 작업은 다음과 같다.\r\n- 프로젝트 빌드 구성\r\n- 데이터 바인딩 레이아웃 파일 변환\r\n- 레이아웃 파일 Data 요소 추가\r\n- 바인딩 클래스 구성\r\n- 바인딩 표현식 사용\r\n\r\n간단한 예시를 데이터 바인딩을 사용하도록 바꾸면서 각각의 사용법을 알아갈 것이다.\r\n\r\n## 1. 프로젝트 빌드 구성\r\n데이터 바인딩을 사용하려면 우선 __build.gradle__(Module: 앱이름.app)에  다음을 추가해야 한다.\r\n```gradle\r\nandroid {\r\n    .\r\n    .\r\n    .\r\n    buildFeatures {\r\n        dataBinding true\r\n    }\r\n}\r\n```\r\n\r\n전의 포스팅까지의 예시에 데이터 바인딩을 추가하기에 앞서 필요없진 코드를 삭제해 준다. 또한 사용자가 Convert 버튼을 클릭하였을때 ViewModel의 함수를 호출하여 환전된 값을 LiveData 변수에 넣어주도록 추가한다. \r\n\r\n```kotlin\r\nclass MainViewModel: ViewModel() {\r\n    private val usd_to_eu_rate = 0.74f\r\n    var dollarValue: MutableLiveData<String> = MutableLiveData()\r\n    private var _result: MutableLiveData<Float> = MutableLiveData()\r\n    val result: LiveData<Float> get() = _result\r\n\r\n    fun convertValue() {\r\n        dollarValue.let {\r\n            if (!it.value.equals(\"\")) {\r\n                _result.value = it.value?.toFloat()?.times(usd_to_eu_rate)\r\n            } else {\r\n                _result.value = 0f\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n## 2. 데이터 바인딩 레이아웃 파일 변환\r\n앱을 구성하는 `UI는 XML 레이아웃 파일`에 포함된다. 데이터 바인딩을 사용하기 위해서는 __기존 XML 레이아웃 파일을 데이터 바인딩 레이아웃 파일로 변환__ 해야 한다. \r\n\r\n> 📍 루트 뷰를 __Layout 컴포넌트__ 로 교체\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\">\r\n\r\n    <androidx.constraintlayout.widget.ConstraintLayout\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"match_parent\"\r\n        tools:context=\".MainActivity\">\r\n\r\n\r\n        <EditText\r\n            android:id=\"@+id/dollarText\"\r\n            android:layout_width=\"wrap_content\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:layout_marginTop=\"100dp\"\r\n            android:ems=\"10\"\r\n            android:inputType=\"numberDecimal\"\r\n            app:layout_constraintEnd_toEndOf=\"parent\"\r\n            app:layout_constraintStart_toStartOf=\"parent\"\r\n            app:layout_constraintTop_toTopOf=\"parent\" />\r\n            .\r\n            .\r\n            .\r\n    </androidx.constraintlayout.widget.ConstraintLayout>\r\n</layout>\r\n```\r\n\r\n## 3. 레이아웃 파일 Data 요소 추가\r\n데이터 바인딩 레이아웃 파일로 바꿨다면 이제 프로젝트의 UI 컨트롤러(ViewModel이나 Activity 및 Fragment)와 __바인딩__ 되어야 한다. \r\n\r\n이 __클래스의 이름__ 이 __데이터 바인딩 레이아웃 파일에 선언__ 되어야 하고, __클래스의 인스턴스를 참조하는 변수 이름__ 을 설정해야 한다. 이때 data 요소를 추가한다.\r\n\r\n> 📍 __data__ 요소에는 __variable__, __import__ 가 포함된다.\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\">\r\n\r\n    <data>\r\n        <variable\r\n            name=\"myViewModel\"\r\n            type=\"com.kyonggi.viewmodelexample.MainViewModel\" />\r\n    </data>\r\n    .\r\n    .\r\n    .\r\n</layout>\r\n```\r\n\r\n예시의 코드를 보면 __MainViewModel 클래스__(이때 클래스는 전체 패키지 이름으로 지정해야한다.) 타입의 __변수이름 myViewModel__ 을 사용한다고 지정하였다고 해석하면 된다.\r\n\r\ndata 요소중 두 번째는 다른 클래스를 __import__ 할 수 있으며, 이 클래스는 __레이아웃 파일의 어디서든지 바인딩 표현식에서 참조가 가능하다.__ \r\n\r\n## 4. 바인딩 클래스 구성\r\n위의 바인딩 레이아웃 파일의 data 요소에서 참조하는 각 클래스는 __레이아웃 파일의 CamelCase로 변환후 Binding이 붙은 형태__ 로 생성된다.(예시에서 MainViewModelBinding)\r\n\r\n이 클래스는 __레이아웃 파일에 지정된 바인딩 정보__ 를 포함하며 이것을 __바인딩되는 객체의 변수와 함수__ 에 연결한다.\r\n\r\n바인딩 클래스는 자동으로 생성되지만 __대응되는 데이터 바인딩 레이아웃 파일에 대해 바인딩 클래스의 인스턴스를 생성__ 하는 코드는 생성해 줘야한다. 이때 __DataBindingUtil 클래스__ 를 사용한다.\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n    private lateinit var binding: ActivityMainBinding\r\n    private lateinit var viewModel: MainViewModel\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        binding = DataBindingUtil.setContentView(this, R.layout.activity_main)\r\n        binding.lifecycleOwner = this\r\n        viewModel = ViewModelProvider(this).get(MainViewModel::class.java)\r\n        // viewModel과 data 요소와 결합\r\n        binding.myViewModel = viewModel\r\n\r\n    }\r\n}\r\n```\r\n\r\n__DataBindingUtil.setContentView(this, R.layout.activity_main)__ 을 통하여 바인딩 클래스를 생성해준다. ViewModel과 LiveData를 함께 사용하기 위해 __binding.lifecycleOwner = this__ 를 통하여 바인딩 객체가 Activity가 존재하는 동안에 메모리에 남아있고 소멸될때 바인딩 객체도 소멸되도록 생명주기 소유자(lifecycleOwner)를 현재 Activity로 설정해 준다. 마지막으로 __binding.myViewModel = viewModel__ 을 통하여 레이아웃 data 요소의 변수 myViewModel을 ViewModel과 바인딩해준다.\r\n\r\n## 5. 바인딩 표현식 사용\r\n바인딩 표현식은 __단방향__ 과 __양방향__ 이 있다. 또한 바인딩의 표현식은 __산술 표현식, 함수 호출, 문자열 결합, 배열 요소 사용, 비교 연산__ 등을 수행 할 수 있다.\r\n\r\n단방향 표현식은 __@로 사작하며 중괄호({}) 안에 표현식을 넣는다.__ 예를 들어 data 요소의 변수이름이 viewmodel이고 result 변수를 포함하는 ViewModel 인스턴스라면 다음과 같이 바인딩 표현식을 사용할 수 있다.\r\n\r\n```xml\r\nandroid:text=\"@{viewmodel.result}\"\r\n```\r\n단방향 바인딩은 대응 되는 데이터 모델 값이 변경되면 레이아웃 뷰의 값도 변경되지만 그 반대의 경우는 안된다. \r\n\r\n양방향 표현식은  __@=__ 으로 선언하면 된다. 예시로 EditText 뷰 같은경우는 사용자가 다른 값을 입력하면 이것과 대응되는 데이터 모델의 값이 입력 값으로 변경된다.\r\n\r\n> 단향향 바인딩:  __@로 사작하며 중괄호({}) 안에 표현식을 넣는다.__   \r\n> 양방향 바인딩: __@=로 사작하며 중괄호({}) 안에 표현식을 넣는다.__ \r\n\r\n- - -\r\n\r\n이제 다시 예시로 가서 바인딩 표현식을 레이아웃 파일에 바인딩 해준다. 첫 번째로 TextView의 ViewModel 의 result 값을 바인딩 해준다.\r\n\r\n```xml\r\n        <TextView\r\n            android:id=\"@+id/resultText\"\r\n            android:layout_width=\"wrap_content\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:text='@{safeUnbox(myViewModel.result) == 0.0 ? \"Enter value\" : String.valueOf(safeUnbox(myViewModel.result))}'\r\n            app:layout_constraintBottom_toBottomOf=\"parent\"\r\n            app:layout_constraintEnd_toEndOf=\"parent\"\r\n            app:layout_constraintStart_toStartOf=\"parent\"\r\n            app:layout_constraintTop_toTopOf=\"parent\" />\r\n```\r\n\r\n바인딩 표현식은 result값이 0이면 값을 입력하라고 \"Enter value\"로 알려주고 0이 아니면 환전된 값을 변환하여 사용자에게 보여준다.\r\n\r\n여기서 값이 변경되는것은 __ViewModel의 값은 변경될 필요가 없기 때문에 단방향 바인딩__ 을 사용하였다. 반면에 사용자가 입력을하는 EditText 값은경우 __사용자가 직전에 입력한 값으로 ViewModel의 값이 변경될 수 있도록(장치의 회전이 일어났을때 현재 값을 보여줘야한다.) 양방향 바인딩을 사용한다.__\r\n\r\n```xml\r\n        <EditText\r\n            android:id=\"@+id/dollarText\"\r\n            android:layout_width=\"wrap_content\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:layout_marginTop=\"100dp\"\r\n            android:ems=\"10\"\r\n            android:text=\"@={myViewModel.dollarValue}\"\r\n            android:inputType=\"numberDecimal\"\r\n            app:layout_constraintEnd_toEndOf=\"parent\"\r\n            app:layout_constraintStart_toStartOf=\"parent\"\r\n            app:layout_constraintTop_toTopOf=\"parent\" />\r\n```\r\n\r\n마지막으로 Convert 버튼을 누르면 처음에 추가한 __convertValue() 함수__ 를 호출하기 위해 바인딩 해준다.\r\n\r\n```xml\r\n        <Button\r\n            android:id=\"@+id/convertButton\"\r\n            android:layout_width=\"wrap_content\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:layout_marginTop=\"50dp\"\r\n            android:text=\"Convert\"\r\n            android:onClick=\"@{() -> myViewModel.convertValue()}\"\r\n            app:layout_constraintEnd_toEndOf=\"parent\"\r\n            app:layout_constraintStart_toStartOf=\"parent\"\r\n            app:layout_constraintTop_toBottomOf=\"@+id/resultText\" />\r\n```\r\n\r\n앱을 실행해보면 \"Enter value\" 메시지와 올바르게 환전이 되는지를 확인할 수 있다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/152167733-87c2d584-9059-46ae-82b4-849834117724.png\" width=\"21.5%\"> <img src=\"https://user-images.githubusercontent.com/63226023/152167779-94bd6551-938e-4a1b-9cf8-34537bcac9fe.png\" width=\"21%\"> <img src=\"https://user-images.githubusercontent.com/63226023/152167810-57480cd8-4dca-482a-b427-82d49c40f82f.png\" width=\"56%\">\r\n- - -\r\n\r\n# References\r\n- [안드로이드 데이터 결합 라이브러리](https://developer.android.com/topic/libraries/data-binding?hl=ko)"},{"excerpt":"이번 포스팅은 안드로이드 안드로이드 ACC 구성 요소중 하\n나인 에 대해서 알게된 내용을 정리하려고 한다.😀\nViewModel을 사용하여 간단한 화폐 변환을 하는 예제에 LiveData 를 추가하여 좀 더 개선해 보려고 한다. LiveData 핵심 요약 LiveData 는 관찰 가능한(obserable) 데이터 홀더 클래스 이다. LiveData 의 인스…","fields":{"slug":"/livedata/"},"frontmatter":{"date":"January 31, 2022","title":"안드로이드 Jetpack의 LiveData 적용하기","tags":["Android","LiveData","ACC"]},"rawMarkdownBody":"<img src=\"https://user-images.githubusercontent.com/63226023/151594101-266890b7-079a-47c5-9daa-2afbc335ccb7.png\">\r\n\r\n이번 포스팅은 안드로이드 안드로이드 ACC 구성 요소중 하\r\n나인 `LiveData`에 대해서 알게된 내용을 정리하려고 한다.😀\r\n[ViewModel을 사용하여](https://ppeper.github.io/android/android-viewmodel/) 간단한 화폐 변환을 하는 예제에 __LiveData__ 를 추가하여 좀 더 개선해 보려고 한다.\r\n- - - \r\n# LiveData 핵심 요약\r\n\r\n__LiveData__ 는 관찰 가능한(obserable) __데이터 홀더 클래스__ 이다. __LiveData__ 의 인스턴스에 포함된 데이터는 __앱의 다른 객체__ 들이`(Activity나 Fragment와 같은 UI 컨트롤러)` 관찰할 수 있다. 또한 LiveData는 __활동 생명 주기 상태__ 를 인식하여 앱의 __메모리 누수__ 의 발생을 줄여준다.\r\n\r\n`Observer` 클래스를 사용하여 __실시간으로 데이터가 변경__ 되는지 감시하고 있다가 UI 컨트롤러(Activity)에게 알려주고, 알림을 받은 UI 컨트롤러는 데이터를 이용하여 UI를 업데이트한다.😮\r\n\r\n여기서 `Observer`가 관찰하는 데이터는 `LiveData라는 데이터 홀더 클래스`를 가지고 있는 데이터만 감시를 하게된다.\r\n\r\n__LiveData__ 는 LifeCycleOwner가 기본적으로 구현되어 있는 Activity와 Fragment에서 __getLifecycle()__ 함수를 통하여 생명 주기를 가져와 __활성화된 상태__ 에서만 변경사항을 알림을 받아 앞서 언급한 __메모리 누수__ 의 발생을 줄여줄 수 있는것이다.👌\r\n> `Observer` 클래스로 표현되는 __관찰자__ 의 수명주기가 `STARTED` 또는 `RESUMED` 상태일때 __활성화__(수신) ⭕\r\n\r\n> 수명주기가 끝나는 순간 __관찰자__ 는 __비 활성화__(수신 거부)❌   \r\n> `Lifecycle` 객체의 상태가 `DESTROYED`로 변경되면 __관찰자를 삭제__ 가 가능. \r\n\r\n## LiveData의 사용의 장점\r\n- 데이터 상태와 UI의 일치 보장\r\n    - `LiveData`는 데이터의 변경시 `Observer` 객체에 알린다. 따라서 `Observer`가 대신 UI를 업데이트하여 __데이터와 UI의 일치를 보장__ 한다.\r\n- 메모리 누수 없음\r\n    - `Observer`는 UI 컨트롤러(Activity/Fragment)의 수명 주기(Lifecycle) 객체에 결합이 되어있으므로 수명 주기가 끝나면 자동으로 삭제된다.\r\n- 중지된 활동으로 인한 비정상 종료 없음\r\n    - `Oberver`의 수명 주기가 __비활성 상태__ 에 있으면 어떤 `LiveData`의 이벤트를 수신하지 않기 때문에 비정상 종료가 없다.\r\n- 수명 주기의 자동화\r\n    - UI 구성 요소는 __데이터를 관찰__ 만 하기 때문에 관찰을 중지나 다시시작을 하지 않는다. 따라서 `LiveData`는 __데이터를 관찰하는 동안__ 관련 수명 주기 상태의 변경을 인식하여 자동으로 관리한다.\r\n- 최신 데이터 유지\r\n    - 수명 주기가 비활성화에서 활성화가 될때는 최신의 데이트를 수신한다.\r\n- 적절한 구성 변경\r\n    - 기기의 회전이 일어나면 기존에는 `savedInstanceState` 를 통하여 데이터를 저장하였다고 복원하는 방식이였지만 `LiveData`를 사용하면 최신의 데이터를 즉시 받을 수 있다.\r\n- 리소스 공유\r\n    - `LiveData` 객체가 한번 시스템 서비스에 연결되면 리소스가 필요한 모든 관찰자(Observer)가 `LiveData` 객체를 볼 수 있다.\r\n\r\n- - -\r\n\r\n# ViewModel에 LiveData 추가하기\r\n기존의 MainViewModel 클래스에 결과로 보여질 값을 `LiveData`의 사용으로 바꿔준다.   \r\nLiveData의 사용은 __캡슐화__ 를 통하여 접근할 수 있게 해준다.\r\n\r\n> 캡슐화💊: 객체의 변수와 함수를 하나로 묶고 실제 구현 내용 일부를 내부에 감추어 외부에서 쉽게 사용하지 못하도록 한다.\r\n\r\n## MutableLiveData vs LiveData\r\n`MutableLiveData`는 변경이 가능하고 `LiveData`는 변경이 불가능 하다는 의미이다. \r\n\r\n`ViewModel`의 관점에서 `LiveData`를 보게되면\r\n- ViewModel은 __변경이 불가능한 LiveData__ 객체만 외부 관찰자에게 보여줘야한다.\r\n    - -> View(외부)에서는 LiveData 데이터를 변경하지 못해야 한다.\r\n\r\n- `LiveData`를 사용하면 __실시간으로 데이터가 변경__ 을 관찰해야 하지만 변경이 불가능하면 이것 또한 모순이다😂\r\n\r\n\r\n> 📍 따라서 __public__ 으로 `LiveData`을 만들고 __private__ 으로 `MutableLiveData`를 선언하여 외부에서는 관찰만 하고, 내부에서는 수정을 하는 방식으로 사용을 하게된다.\r\n\r\n`LiveData`을 변경을 할때는 `MutableLiveData`의 사용 말고도 다음의 방법이 있다.\r\n- __Room 등의 라이브러리를 사용한다면__ Room의 데이터가 바뀌면 해당 LiveData로 바뀐 Data를 즉시 수정해준다.\r\n- Room 등의 사용이 없다면 `viewModel`에서 __MutableLiveData를 생성하여 LiveData와 연결__ 을 하고, 데이터의 변경은 __MutableLiveData를 사용__ 한다.\r\n\r\n\r\n```kotlin\r\n// Room 등의 라이브러리를 사용하여 데이터를 직접 할당\r\nval livedata : LiveData<Float> = repository.함수이름\r\n\r\n// MutableLiveData를 사용하여 직접 데이터를 가공하여 사용\r\nprivate val _livedata : MutableLiveData<Float> = MutableLiveData()\r\nval livedata: LiveData<Float> get() = _livedata\r\n```\r\n\r\n- - -\r\n\r\n## 1. LiveData 추가\r\n앞서 설명한 `LiveData`를 __MainViewModel__ 클래스에 선언해준다.\r\n```kotlin\r\nclass MainViewModel: ViewModel() {\r\n    private val usd_to_eu_rate = 0.74f\r\n    private var dollarText = \"\"\r\n    private var _result: MutableLiveData<Float> = MutableLiveData()\r\n    val result: LiveData<Float> get() = _result\r\n\r\n    fun setAmount(value: String) {\r\n        this.dollarText = value\r\n        _result.value = value.toFloat() * usd_to_eu_rate\r\n    }\r\n}\r\n```\r\n## 2. Observer 객체 생성\r\n`LiveData`를 선언하였다면 `Observer` 인터페이스를 구현하는 객체를 생성하여 `LiveData`의 데이터 변경을 관찰할 수 있다.\r\n\r\n일반적으로는 `UI 컨트롤러(Activity/Fragment)`에 `Observer` 객체를 만든다. `Observer` 인터페이스는 `LiveData`의 데이터 값이 변경될때 호출되는 __onChange()__ 함수를 구현하면 된다.\r\n\r\n```kotlin\r\n// 데이터 관찰을 위한 옵저버 설정 -> onChange() 함수의 구현\r\nval resultObserver = Observer<Float> { result ->\r\n    binding.resultText.text = result.toString()\r\n}\r\n```\r\n## 3. observe() 함수 호출\r\n__observe()__ 함수를 사용하여` LiveData` 객체와 `Observer` 객체를 연결합니다. observe() 메서드는 __LifecycleOwner__ 객체와 __Observer 객체__ 를 파라미터로 받는다. \r\n```kotlin\r\n// viewModel를 Observer와 연결\r\nviewModel.result.observe(this, resultObserver)\r\n```\r\n이렇게 하면 __ViewModel과 Observer 객체가 연결__ 이되고 __Observer 객체는 LiveData 객체를 (여기선 변수 result)를 구독__ 하여 데이터의 변경사항에 대한 알림을 받는다.\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n    private lateinit var binding: ActivityMainBinding\r\n    private lateinit var viewModel: MainViewModel\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        binding = ActivityMainBinding.inflate(layoutInflater)\r\n        setContentView(binding.root)\r\n        viewModel = ViewModelProvider(this).get(MainViewModel::class.java)\r\n\r\n        // 데이터 관찰을 위한 옵저버 설정\r\n        val resultObserver = Observer<Float> { result ->\r\n            binding.resultText.text = result.toString()\r\n        }\r\n        // viewModel를 Observer와 연결\r\n        viewModel.result.observe(this, resultObserver)\r\n\r\n        with(binding) {\r\n            convertButton.setOnClickListener {\r\n                if (dollarText.text.isNotEmpty()) {\r\n                    viewModel.setAmount(dollarText.text.toString())\r\n                } else {\r\n                    resultText.text = \"No Value\"\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n`LiveData`를 사용하여 실시간으로 데이터의 변경을 감지하도록 개선해 보았다. 다음에는 `DataBinding`을 `LiveData`와 같이 사용해보면서 `DataBinding`을 알아보도록 하겠다.\r\n\r\n> 📍[DataBinding + LiveData 적용하기](https://ppeper.github.io/android/android-databinding/)\r\n- - -\r\n\r\n# References\r\n- [안드로이드 LiveData 개요](https://developer.android.com/topic/libraries/architecture/livedata?hl=ko)\r\n- [LiveData 와 MutableLiveData](https://comoi.io/300)"},{"excerpt":"이번 포스팅은 안드로이드 안드로이드 ACC 구성 요소중 하\n나인 에 대해서 알게된 내용을 정리하려고 한다.😀 ViewModel에 대해 ViewModel 클래스는 UI 관련 데이터만을 저장하고 관리하도록 설계되어 있어 View(Activity/Fragment)의 UI 컨트롤러의 과도한 책임을 분담하여 코드가 복잡해지고 거대해지는것 을 방지하고 화면 회전등을…","fields":{"slug":"/viewmodel/"},"frontmatter":{"date":"January 30, 2022","title":"안드로이드 Jetpack의 ViewModel 사용해보기","tags":["Android","ViewModel","ACC"]},"rawMarkdownBody":"<img src=\"https://user-images.githubusercontent.com/63226023/151594101-266890b7-079a-47c5-9daa-2afbc335ccb7.png\">\r\n\r\n이번 포스팅은 안드로이드 안드로이드 ACC 구성 요소중 하\r\n나인 `ViewModel`에 대해서 알게된 내용을 정리하려고 한다.😀\r\n- - - \r\n# ViewModel에 대해\r\n__ViewModel__ 클래스는 UI 관련 데이터만을 저장하고 관리하도록 설계되어 있어 __View__(Activity/Fragment)의 UI 컨트롤러의 과도한 책임을 분담하여 __코드가 복잡해지고 거대해지는것__ 을 방지하고 화면 회전등을 하여도 __데이터를 유지__ 하게 해준다.\r\n\r\n > MVVM 패턴에서 말하던 ViewModel이 이런거구나~😀\r\n\r\n❗조심할 점은 일반적으로 MVVM 패턴에서 말하는 __ViewModel__ 과 __ACC-ViewModel__ 은 다르다!!\r\n\r\n[안드로이드 공식문서](https://developer.android.com/topic/libraries/architecture/viewmodel)에서도 ViewModel을 설명할때 MVVM 패턴에 대한 언급이 전혀 없다. 따라서 ViewModel과 구분하기 위하여 안드로이드에서는 __ACC-ViewModel__ 이라고 많이 부른다. __ACC-ViewModel__ 을 알아보기전에 둘의 차이점에 대해서 알아보자.\r\n\r\n# ViewModel vs ACC-ViewModel\r\n__[MVVM 패턴](https://ppeper.github.io/android/android-acc/)에서 ViewModel__ 을 보게되면 View로 부터 독립적이게 되어 View를 위한 데이터만을 가지고있도록 하는것으로 코드의 유지 보수를 좋게해준다는 장점이 있다. \r\n\r\n__ACC-ViewModel__ 은 안드로이드의 생명 주기를 고려하여 UI 관련 데이터를 저장하고 관리하도록 설계되었다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/151693012-5e82e66a-68f0-466c-bb06-6af052697228.png\" width=\"50%\">\r\n\r\n위의 그림을 보면 ViewModel은 Activity가 최초 생성되고 파괴되기 전까지 생명 주기를 유지하여 데이터의 보존을 하는것을 알 수 있다.\r\n\r\n정리하면 __MVVM 패턴에서의 ViewModel은 View에서 필요한 데이터를 바인딩과 데이터의 가공을 처리__ 하기 위한 것이고 __안드로이드 ACC-ViewModel은 생명주기를 고려하여 데이터의 유연한 관리__ 라고 할 수 있을것 같다.\r\n\r\n두 ViewModel의 개념을 정리해보니 서로 다른 개념이라는 것을 볼 수 있다. 결론적으로 __ACC-ViewModel__ 을 사용한다고 해서 MVVM 패턴이 되는것이 아니고 __ACC-ViewModel__ 은 안드로이드 앱 개발시 __MVVM 패턴을 쉽게~~(지않다..)~~ 개발할 때 도와주는 역할이다. \r\n\r\n> 📍정리: 안드로이드 개발 편의를 위한 이름만 ViewModel\r\n\r\n추후에 공부해볼 ACC 구성요소의 `LiveData`, `dataBinding`등 활용하여 MVVM 패턴에서 말하는 ViewModel로 써 ACC-ViewModel을 사용이 가능하다.\r\n\r\n# ACC-ViewModel 사용하기\r\nViewModel의 예시를 위해서 `activity_main.xml`을 다음과 같이 구상하자.   \r\n(각 Id는 `EditText(Number) -> dollarText`, `TextView -> resultText`, `button -> convertButton`)\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/151698396-82cbeecd-fd77-4eb4-bfbc-06198b2a9f61.png\" width=\"30%\">\r\n\r\nViewModel을 생성하여 환전을 하여 보여주는 함수를 만들어 준다.\r\n```kotlin\r\nclass MainViewModel: ViewModel() {\r\n    private val usd_to_eu_rate = 0.74f\r\n    private var dollarText = \"\"\r\n    private var result = 0f\r\n\r\n    fun setAmount(value: String) {\r\n        this.dollarText = value\r\n        result = value.toFloat() * usd_to_eu_rate\r\n    }\r\n\r\n    fun getResult(): Float {\r\n        return result\r\n    }\r\n}\r\n```\r\n데이터 변경을 관찰하기 위해서는 ViewModel의 참조를 얻어야한다. 이때 __ViewModelProvider 클래스__ 를 사용한다.\r\n```kotlin\r\nval viewModel = ViewModelProvider(this)\r\n```\r\n__ViewModelProvider__ 인스턴스가 생성되면 __get()__ 함수를 호출하여 위에서 만든 `MainViewModel` ViewModel 클래스를 인자로 전달한다.\r\n```kotlin\r\nval viewModel = ViewModelProvider(this).get(MainViewModel::class.java)\r\n```\r\n환전하여 보여줄 코드를 모두 작성한후 간단한 예시를 실행해 본다.\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n    private lateinit var binding: ActivityMainBinding\r\n    private lateinit var viewModel: MainViewModel\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        binding = ActivityMainBinding.inflate(layoutInflater)\r\n        setContentView(binding.root)\r\n        viewModel = ViewModelProvider(this).get(MainViewModel::class.java)\r\n\r\n        with(binding) {\r\n            convertButton.setOnClickListener {\r\n                if (dollarText.text.isNotEmpty()) {\r\n                    viewModel.setAmount(dollarText.text.toString())\r\n                    resultText.text = viewModel.getResult().toString()\r\n                } else {\r\n                    resultText.text = \"No Value\"\r\n                }\r\n            }\r\n\r\n            resultText.text = viewModel.getResult().toString()\r\n        }\r\n    }\r\n}\r\n```\r\n화면의 회전을 하더라도 데이터가 유지되는것을 확인할 수 있다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/151699362-56c37016-7e8e-4de1-b21a-62ead07b4d31.png\" width=\"30%\"> <img src=\"https://user-images.githubusercontent.com/63226023/151699371-f4c84168-c820-4b22-aefe-951c7e2abd2d.png\" width=\"60%\">\r\n\r\n\r\nViewModel의 간단한 예시에서는 생성자의 아무런 인자가 없다. 그래서 별도의 의존성에 대한 고민을 할 필요가 없이 __ViewModelProvider__ 를 사용하여 __ViewModel__ 을 생성하였다.\r\n\r\n실제로는 생성자에 아무런 매개변수를 쓰지않고 사용하는 경우가 거의 없을것이고, ViewModel에서 사용자에게 보여줄 UI에 표시할 데이터를 보여주기 위하여 여러 인스턴스가 있을것이다.   \r\n앞으로 차근차근 공부해가며 진정한 __MVVM 패턴에 맞는 ViewModel__ 을 사용하기 위해 공부를 해야겠다.😁\r\n\r\n> 📍[안드로이드 Jetpack의 LiveData 적용하기](https://ppeper.github.io/android/android-livedata/)\r\n\r\n- - -\r\n# References\r\n- [안드로이드 ViewModel 개요](https://developer.android.com/topic/libraries/architecture/viewmodel?hl=ko)\r\n\r\n"},{"excerpt":"안드로이드 앱 개발을 시작하면 Activity에 거의 모든 동작하는 코드 를 직접 넣는다. 이렇게 모든 코드를 넣다보면 구조화된 코드의 작성이 없게되고 추후에 유지 보수 가 어려워진다. 처음 안드로이드 프로젝트를 진행하면서 기능을 바꾸거나 추가할 때 어느 부분을 수정해야하는지 굉장히 난해했던 경험이 있었고 자연스럽게 디자인 패턴을 공부를 하고 적용을 해봐…","fields":{"slug":"/android-acc/"},"frontmatter":{"date":"January 29, 2022","title":"안드로이드 MVVM 패턴과 ACC 알아보기","tags":["Android","MVVM","ACC"]},"rawMarkdownBody":"<img src=\"https://user-images.githubusercontent.com/63226023/151594101-266890b7-079a-47c5-9daa-2afbc335ccb7.png\">\r\n\r\n안드로이드 앱 개발을 시작하면 __Activity에 거의 모든 동작하는 코드__ 를 직접 넣는다. 이렇게 모든 코드를 넣다보면 __구조화된 코드의 작성이 없게되고 추후에 유지 보수__ 가 어려워진다.\r\n\r\n처음 안드로이드 프로젝트를 진행하면서 __기능을 바꾸거나 추가할 때 어느 부분을 수정해야하는지__ 굉장히 난해했던 경험이 있었고 자연스럽게 디자인 패턴을 공부를 하고 적용을 해봐야겠다는 생각이 들었다.😎 \r\n\r\n<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/151658824-a9a66cb5-dadb-4931-b03a-eba217a1c345.png\" width=\"70%\"></p>\r\n\r\n\r\n> 이렇게 모든 동작들을 하나의 Acitivity에 넣다보면 스파게티 코드가 된다...\r\n\r\n\r\n다행이 구글에서 `Jetpack`을 출시하여 __안드로이드 아키텍쳐 컴포넌트(ACC)__ 를 포함하여 __MVVM 패턴__ 에 따른 앱 개발을 하도록 제공하고 있다.   \r\n이번 포스팅은 __안드로이드 아키첵처 컴포넌트(ACC)__ 와 __MVVM 패턴__ 에 대해 정리를 해보려고 한다.\r\n\r\n- - -\r\n\r\n# 📍 MVC vs MVVM\r\nMVVM 디자인 패턴을 알아보기 전에 이전에 사용하던 MVC 패턴을 알아보자!\r\n\r\nMVC 패턴은 __Model-View-Controller__ 의 약자로 기능별로 나타내면 다음과 같다.\r\n\r\n- Model : Data와 관련한 처리를 한다.\r\n- View : Controller로 부터 알림을 받고, Model을 참조하여 사용자가 볼 화면을 구성한다.\r\n- Controller : 사용자의 입력을 받는다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/151660484-18f2e9c3-8733-46b2-ac8a-9e9c89a054d4.png\">\r\n\r\n\r\n> 1. __Controller__ 는 사용자의 입력을 받는다.   \r\n> 2. Controller는 입력에 따라서 __Model의 갱신__ 을 요청한다.\r\n> 3. __View__ 는 __Model을 참조__ 하여 __사용자가 볼 화면(UI)를 업데이트__ 한다.\r\n\r\n안드로이드에서는 __Controller__ 의 역할과 __View__ 의 역할을 함께하게 된다(OnClickListener 등). 따라서 기존의 단순한 형태의 MVC 패턴에 따른 Activity에 모든 코드를 넣으면 이런 단점들이 발생하였다.\r\n\r\n- 앱에 기능을 추가할때 마다 __Activity의 코드양이 많아짐__\r\n- __View와 Model 간의 결합도__ 가 높아짐\r\n- __코드 복잡도__ 가 높아질 수 있음\r\n- __유지보수__ 가 어려워짐\r\n\r\n따라서 MVC 패턴은 앱의 규모가 커지면 커질수록 유지보수가 굉장이 어려워 진다는 단점이 있다. 이러한 __MVC 패턴의 단점__ 을 보완하기 위하여 나온것이 __MVVM 패턴__ 이다.\r\n\r\n__MVVM 패턴__ 은 기존 MVC에서 Model과 View는 동일하지만 __ViewModel__ 을 추가한 형태이다. \r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/151661992-50183d81-a040-4d8d-91d1-8a89a3853b44.png\" width=\"60%\">\r\n\r\n\r\n앞서 말한 MVC 패턴은 Controller(Activity)가 View와 Model간 상호작용을 하였다.   \r\nMVVM 패턴에서는 __View__ 는 __ViewModel의 데이터를 관찰__ 하여 UI를 갱신한다. 또한 __ViewModel__ 은 __Model__ 로부터 데이터의 갱신을 및 요청한 데이터를 받는다. \r\n\r\n결론적으로 __View에서 사용자에게 보여줄 데이터__ 는 __ViewModel__ 이 가지고 있고 이를 __관찰__ 하기 때문에 `MVC 패턴과 다르게` __View가 데이터를 가져오기위해 DB에 접근을 하지 않고 오직 UI 갱신에만 신경쓰게 된다.__\r\n\r\n따라서 MVVM 패턴을 적용하게 된다면 안드로이드에서 __다음과 같은 장점을 가진다.__\r\n\r\n- View의 UI 갱신이 간단하다.(ViewModel의 데이터를 관찰하고 있기 때문이다)\r\n- ViewModel이 데이터를 가지고 있으므로 __메모리 누수__ 방지 (View와 Model간의 상호작용이 없어 생명주기에 의존하지 않는다)\r\n- 기능별로 __모듈화__ 가 잘 되어 있기 때문에 유지 보수가 용이.\r\n\r\n이러한 MVVM 패턴을 잘 활용한다면 좋은 앱을 개발할 수 있을것이다. 그렇지만 MVC 패턴은 쉽게 구현을 할 수 있었지만 MVVM 패턴은 __구조가 복잡하다는 단점__ 이 있다.\r\n\r\n구글에서는 이러한 __MVVM 패턴__ 을 비교적 간편하게 적용할 수 있도록 __ACC__ 라는 것을 제공한다.\r\n\r\n\r\n# 안드로이드 아키텍처 컴포넌트(ACC)\r\n구글에서 제공하는 안드로이드 Jetpack의 구성요소중 하나인 ACC 는 아래의 그림과 같다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/151663025-31f02dd5-30e2-4035-b924-12d9df521945.png\">\r\n\r\n## ViewModel\r\nViewModel은 앞서 설명한대로 UI를 갱신할 __데이터만을 가지고 있으며__ View와 분리되어 있어서 __생명주기에 영향__ 을 미치지 않는다.(예: 앱의 회전등이 일어날때)\r\n\r\n## LiveData\r\nLiveData는 데이터 홀더이며 저장된 데이터(ViewModel)을 관찰할 수 있게(Obserable) 해준다. 또한 Activity / Fragment의 생명주기를 인식하여 활동을 하고 있을 때만(Activity가 활성화) 동작을 하게되어 이는 __메모리 누수__ 의 발생을 줄여준다.\r\n\r\n## RoomDatabase\r\nRoomDatabase는 __SQLite 데이터베이스를 쉽게 사용__ 할 수 있도록 해주는 라이브러리이다. 별도의 쿼리문을 쓰지 않더라도 더욱 직관적이고 편하게 데이터베이스를 사용할 수 있다.\r\n\r\n## Repository\r\nViewModel이 데이터베이스나 외부의 웹 서비스로부터 데이터를 주고받기 위해, 데이터 API를 들고 있는 클래스이다. 따라서 ViewModel은 직접 데이터베이스나 웹 서비스에 접근하지 않고 Repository에 접근하여 일관성 있게 데이터를 가져올 수 있다.\r\n\r\n- - -\r\n# 정리하며👍\r\n구글에서 제공하는 __ACC__ 의 여러가지 구성 요소들을 활용하여 __MVVM 패턴__ 을 적용하고 사용할 수 있다. \r\n> ACC와 MVVM에 대해선 알겠는데 이를 적용시킬수 있을까..😅😅\r\n\r\nMVVM 패턴이 __좋은것은 알겠지만 이를 어떻게 적용을 시킬지에 대한 의문__ 과 ACC 가 도움을 주는지는 알겠지만 __사용을 어떻게 해야할 지 아직까지 잘 생각이 들지 않는다.__\r\n\r\n앞으로 ACC의 구성 요소와 많은 코드, 예제를 보면서 __패키지의 구조 및 코드의 구현 방식__ 을 많이 접해봐야겠다는 생각이 들었다. \r\n\r\n"},{"excerpt":"안드로이드 Jetpack은 2018년도에 릴리스가 되어 많은 시간이 지났지만 공부하기전에 이해하기 쉽게 정리를 하고가는것은 공부하는데 매우 효과적이라고 생각하여 조금 늦었지만 Jetpack에 대해서 정리해 보려고 한다.(나를 위한 포스팅😅) 안드로이드 JetPack이란 안드로이드 Jetpack은 개발자가 고품질 앱을 손쉽게 개발할 수 있도록 지원하는 라이…","fields":{"slug":"/android-jetpack/"},"frontmatter":{"date":"January 28, 2022","title":"안드로이드 Jetpack에 대해","tags":["Android","Jetpack"]},"rawMarkdownBody":"<img src=\"https://user-images.githubusercontent.com/63226023/151514551-8a7c0b07-7e4b-4f1e-8b69-627943968edc.png\">\r\n\r\n > 안드로이드 Jetpack은 2018년도에 릴리스가 되어 많은 시간이 지났지만 공부하기전에 이해하기 쉽게 정리를 하고가는것은 공부하는데 매우 효과적이라고 생각하여 조금 늦었지만 Jetpack에 대해서 정리해 보려고 한다.~~(나를 위한 포스팅😅)~~\r\n\r\n- - -\r\n\r\n# 안드로이드 JetPack이란\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/151520051-09f02d64-7e6a-440c-b688-ee8210acc3a5.png\">\r\n\r\n안드로이드 Jetpack은 개발자가 __고품질 앱을 손쉽게 개발할 수 있도록 지원하는 라이브러리, 도구, 권장사항__ 등의 모음이다.\r\n\r\n구글은 안드로이드 앱을 만드는 특정한 방법을 제공하지 않았던것에 비해 `Jetpack 컴포넌트`를 출시한 후에는 개발자들이 아키텍처 지침의 핵심 원리를 준수하며 앱 개발시 `더 빠르고 쉽게 공통 작업`을 수행할 수 있게 해준다.\r\n\r\n> 안드로이드 Jetpack은 앱 개발시 더 빠르고 쉽게 개발하도록 도와주는 라이브러리의 모음이다😀.\r\n\r\n이전에는 안드로이드 앱 개발시 하나의 Activity에 UI를 보여주고 로직을 처리하는 코드를 모든 코드를 포함하였었다😅. Jepack이 출시된 이후에 안드로이드 아키텍처 컴포넌트(ACC)의 구글에서 권장하는 아키텍처 패턴을 통하여 각 역할을 분리하여 코드의 가독성과 재 사용성을 높이게 되었다.\r\n\r\n\r\n# 안드로이드 Jetpack 종류\r\n\r\n안드로이드 Jetpack의 구성요소는 기존의 지원 라이브러리(Support library)와 아키텍처 구성 요소를 통합하여 4가지 섹션으로 분류된다. 또한 안드로이드 Jetpack 라이브러리의 네이밍은 `[androidx.*(name)]`으로  구성되어 있다.\r\n\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/151522973-e36a254c-9612-41bd-844a-e5fef84e87f4.png\">\r\n\r\n- - -\r\n\r\n# References\r\n- [Android Jetpack](https://developer.android.com/jetpack?hl=ko)\r\n- [Android Developers Blog](https://android-developers.googleblog.com/2018/05/use-android-jetpack-to-accelerate-your.html)"},{"excerpt":"안드로이드의 첫 개발을 진행하면서 채팅기능을 만들어 보면서 푸시알림의 기능을 넣지 못했던것이 많이 생각났다.(공모전에 대한 회고도 조만간 작성해야겠다😢) 따라서 이번 포스팅은 알림에 대해서 정리해 보려고 한다. 알림(Notification) 알림에는 로컬 알림과 원격 알림(푸시 알림)이 있다. 은 장치에서 실행 중인 앱에서 생성되며 은 원격 서버에서 생성…","fields":{"slug":"/notification/"},"frontmatter":{"date":"January 27, 2022","title":"안드로이드 알림(Notification) 만들기","tags":["Android","Notification"]},"rawMarkdownBody":"<img src=\"https://user-images.githubusercontent.com/63226023/151293802-06329eaf-2910-4f76-ba0b-03f171184691.png\" width=\"90%\">\r\n\r\n안드로이드의 첫 개발을 진행하면서 채팅기능을 만들어 보면서 푸시알림의 기능을 넣지 못했던것이 많이 생각났다.(공모전에 대한 회고도 조만간 작성해야겠다😢) 따라서 이번 포스팅은 알림에 대해서 정리해 보려고 한다.\r\n- - -\r\n# 알림(Notification)\r\n알림에는 __로컬__ 알림과 __원격__ 알림(푸시 알림)이 있다. `로컬 알림`은 장치에서 실행 중인 앱에서 생성되며 `원격 알림`은 원격 서버에서 생성되어 장치에 전송된다.   \r\n이번 알림은 안드로이드 앱에서 로컬 알림을 생성하는 방법과 기본적인 구조를 통하여 알림에 대해서 알아보려고 한다.   \r\n알림에 대한 예시코드는 기본적으로 버튼에 `sendNotification()` 함수를 onclick으로 설정하여 보여 줄 것이다. [(알림 예시코드)](https://github.com/ppeper/Android_Arctic-Fox/tree/main/NotifyDemo)\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/151316170-56467781-ab13-452d-8615-2f5230e7662c.png\" width=\"20%\">\r\n\r\n알림을 생성하기 위해선 크게 다음과 같이 생성한다.\r\n\r\n> 1. 알림 채널 생성 & 등록(__NotificationChannel__)\r\n> 2. 알림 콘텐츠 설정(__NotificationCompat.Builder__)\r\n> 3. 알림 표시(__NotificationManagerCompat.notify()__)\r\n> 4. 알림 탭 작업 설정(__PendingIntent__)\r\n\r\n## 1. 알림 채널 생성 & 등록\r\n알림의 콘텐츠를 설정하기 위해 __NotificationCompat.Builder__ 객체의 경우 `채널 ID`를 제공해야 한다. 따라서 알림의 콘텐츠를 생성하기 이전에 `알림 채널`을 만들어야 한다.\r\n> ❗Android 8.0(API 수준 26) 이상에서는 호환성을 유지하기 위해 필요하지만 이전 버전에서는 무시된다고 한다.\r\n\r\n\r\n알림 채널 설정을 통하여 `소리`, `진동`, `색상`등을 설정 할 수 있다. 기본적으로 알림 채널을 만들기 위해서는 다음과 같다.\r\n1. `고유한 채널 ID`, `사용자가 볼 수 있는 이름`, `중요도` 를 사용하여 __NotificationChannel__ 객체를 구성한다.\r\n> NotificationChannel(String id, CharSequence name, int importance)\r\n2. 선택적으로 `setDescription()` 를 사용하여 시스템 설정에서 사용자에게 보여주는 설명을 지정할 수 있다.\r\n3. 생성된 NotificationChannel 객체를 __createNotificationChannel()__ 함수에 전달하여 등록한다.\r\n\r\n```kotlin\r\nprivate fun createNotificationChannel(\r\n        id: String, name: String,\r\n        description: String\r\n    ) {\r\n        val importance = NotificationManager.IMPORTANCE_LOW\r\n        val channel = NotificationChannel(id, name, importance)\r\n\r\n        channel.description = description\r\n        channel.enableLights(true)\r\n        channel.lightColor = Color.RED\r\n        channel.enableVibration(true)\r\n        channel.vibrationPattern =\r\n            longArrayOf(100,200,300,400,500,400,300,200,400)\r\n\r\n        notificationManager?.createNotificationChannel(channel)\r\n    }\r\n\r\n```\r\nNotificationChannel 매개변수로 들어가는 중요도는 NotificationManager를 통하여 사용하여 가져올 수 있다. \r\n\r\n```kotlin\r\nprivate var notificationManager: NotificationManager? = null\r\n.\r\n.\r\n.\r\n notificationManager =\r\n            getSystemService(\r\n                Context.NOTIFICATION_SERVICE) as NotificationManager\r\n\r\n// 체널 등록\r\ncreateNotificationChannel(\r\n            \"com.kyonggi.notifydemo.news\",\r\n            \"NotifyDemo News\",\r\n            \"Example News Channel\"\r\n        )\r\n```\r\n\r\n중요도 설정은 채널에 있는 모든 알림의 중단 수준에 영향을 미치게 되고 `NotificationChannel` 생성자에서 지정해야 한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/151309445-b36b29ea-6043-428a-8352-84c64b586c97.png\">\r\n\r\n앱을 실행하여 설정을 가보면 \"NotifyDemo News\"로 설정한 이름의 채널을 볼 수 있다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/151308576-9677ec3a-1eac-4dc5-b6ff-8049496e7414.png\" width=\"30%\">\r\n\r\n앱에서 알림 채널을 삭제를 하려면 `NotificationManager`의 deleteNotificationChannel() 함수를 호출하면 된다. 매개변수는 삭제할 채널의 id를 받는다.\r\n```kotlin\r\nval channelID = \"com.kyonggi.notifydemo.news\"\r\nnotificationManager?.deleteNotificationChannel(channelID)\r\n```\r\n\r\n중요도 설정은 채널에 있는 모든 알림의 중단 수준에 영향을 미치게 되고 `NotificationChannel` 생성자에서 지정해야 한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/151309445-b36b29ea-6043-428a-8352-84c64b586c97.png\">\r\n\r\n## 2. 알림 콘텐츠 설정\r\n\r\n> 안드로이드 developer 페이지에서 기본적인 알림에 대한 템플릿을 보여준다😎 \r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/151313708-87094c32-59e6-4b10-aebb-775de27ee731.png\">\r\n\r\n알림의 콘텐츠를 설정하기 위해서는 __NotificationCompat.Builder__ 객체를 사용하여 알림을 생성해야한다.\r\n\r\n- `setSmallIcon()` : 알림 설정시 유일한 필수 콘텐츠.\r\n- `setContentTitle()` : 알림의 제목\r\n- `setContentText()` : 알림의 본문 내용.\r\n\r\n    - `setPriority()` : 알림의 우선순위. 우선순위에 따라 Android 7.1 이하에서 알림이 얼마나 강제적인지 결정된다.\r\n\r\n    > ❗Android 8.0 이상의 경우 알림 채널의 생성(NotificationChannel)에서 중요도를 대신 설정해야 한다.\r\n- `setNumber()` : 앱 아이콘을 길게 누르면 나오는 팝업에서 두 개 이상의 알림이 대기 중일 때 알림 개수를 보여준다.\r\n\r\n```kotlin\r\n val channelID = \"com.kyonggi.notifydemo.news\"\r\n\r\n val notification = NotificationCompat.Builder(\r\n            this,\r\n            channelID\r\n        ).setContentTitle(\"Example Notification\")\r\n            .setContentText(\"This is an example notification.\")\r\n            .setSmallIcon(android.R.drawable.ic_dialog_info)\r\n            .setChannelId(channelID)\r\n            .setNumber(10)\r\n            .build()\r\n```\r\n위에서 설정한 channelID를 setChannelId()로 등록을 하면 기본적인 알림의 생성이 완료된다.\r\n\r\n## 3. 알림 표시\r\n알림을 표시하기 위해서는 `NotificationManagerCompat.notify()`를 호출해야 한다.   \r\nnotify() 함수는 매개변수로 `알림 ID`와 `NotificationCompat.Builder`에 대한 `.build()`를 전달해야 한다.   \r\n(예시에선 변수 notification)\r\n\r\n```kotlin\r\n.\r\n.\r\nval notificationID = 101\r\n\r\n val notification = NotificationCompat.Builder(\r\n            this,\r\n            channelID\r\n        ).\r\n         .\r\n            .build()\r\n\r\nnotificationManager?.notify(notificationID, notification)\r\n```\r\n앱을 실행하여 버튼을 클릭하면 기본 알림이 오는것을 볼 수 있다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/151315879-8a3a7949-df18-4d86-b8e2-824d128ae4eb.png\" width=\"30%\">\r\n\r\n## 4. 알림 탭 작업 설정\r\n위에서 알림을 만들었지만 클릭을 하더라도 어떤 형태의 액션도 수행할 수 없다. 대부분 알림을 처리하는 앱은 해당 앱의 액티비티를 시작시킨다. 이러한 작업을 추가하기 위해서는 해당 액티비티를 시작시키는 인텐트를 구성해야한다.\r\n\r\n실행해야하는 액티비티가 ResultActivity로 지정하여 Intent를 생성한다.\r\n```kotlin\r\nval resultIntent = Intent(this, ResultActivity::class.java)\r\n```\r\n\r\n이후 이 인텐트를 `PendingIntent` 인스턴스에 포함해야 한다.[(PendingIntent 개념)](https://ppeper.github.io/android/pendingIntent/) PendingIntent 객체는 다른 앱에 인텐트를 전달할 수 있게 하며, 전달받은 앱은 향후에 인텐트를 수행할 수 있게 한다.\r\n```kotlin\r\nval pendingIntent = PendingIntent.getActivity(\r\n    this, 0, resultIntent, PendingIntent.FLAG_UPDATE_CURRENT\r\n)\r\n```\r\n위에서 설정한 notification 변수에 `setContentIntent()`를 호출하여 PendingIntent 객체를 지정하면 된다.\r\n```kotlin\r\nval notification = NotificationCompat.Builder(\r\n            this,\r\n            channelID\r\n        ).\r\n         .  \r\n            .setContentIntent(pendingIntent)\r\n            .build()\r\n```\r\n\r\n> 이제 상단바에서 알림을 클릭하면 ResultActivity로 가는것을 볼 수 있다👌\r\n\r\n### 알림에 액션 추가하기\r\n알림에서 액션을 추가하면 또 다른 방법으로 액티비티를 시작시킬 수 있다. 액션은 생성된 알림 메시지의 밑에 `버튼`으로 나타나며, 사용자가 탭을 하여 특정 인텐트를 시작할 수 있다.\r\n\r\n알림 액션은 __NotificationCompat.Action.Builder__ 를 통해 action을 생성 할 수 있다.\r\n```kotlin\r\n val action: NotificationCompat.Action =\r\n            NotificationCompat.Action.Builder(android.R.drawable.ic_dialog_info, \"Open\", pendingIntent).build()\r\n``` \r\n생성된 action을 notification에서 `addAction()`을 통하여 지정할 수 있다.\r\n```kotlin\r\nval notification = NotificationCompat.Builder(\r\n            this,\r\n            channelID\r\n        ).\r\n         .  \r\n            .setContentIntent(pendingIntent)\r\n            .addAction(action)\r\n            .build()\r\n```\r\n\r\n또 다른 방법은 __addAction(int icon, CharSequence title, PendingIntent intent)__ 로 설정하는 방법이다.\r\n\r\n```kotlin\r\nval notification = NotificationCompat.Builder(\r\n            this,\r\n            channelID\r\n        ).\r\n         .  \r\n            .setContentIntent(pendingIntent)\r\n            .addAction(android.R.drawable.ic_dialog_info, \"Open\", pendingIntent)\r\n            .build()\r\n```\r\n\r\n앱을 실행하여 알림창을 보면 설정한 `Open` 액션이 나타나게 된다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/151322843-071287c7-50e7-49c8-9419-bcdd3271a374.png\" width=\"30%\">\r\n\r\n# 알림 메시지 묶기\r\nAndroid 7.0(API 수준 24)부터는 관련된 알림을 그룹으로 표시할 수 있다. 알림을 묶으려면 각 알림을 __같은 그룹__ 에 속하도록 지정해 한다. 알급 그룹을 위해 __고유 식별자__ 를 생성하여 `setGroup()`으로 호출하면 된다.\r\n```kotlin\r\nval GROUP_KEY_NOTIFY = \"group_key_notify\"\r\n\r\nvar builder = NotificationCompat.Builder(this, channelID)\r\n    .\r\n    .\r\n    .\r\n    .setGroup(GROUP_KEY_NOTIFY)\r\n```\r\n\r\n또한 그룹 요약을 설정하기 위해서는 `setGroupSummary(true)`를 호출해야 한다. (예시코드의 주석처리 해제후 sendNotification() 함수 내부의 제일 끝으로 볼 수 있다)\r\n\r\n- - -\r\n\r\n# 알림 직접 응답\r\nAndroid 7.0(API 수준 24)에서 도입된 직접 응답 기능을 사용하면 알림에서 사용자가 텍스트를 입력하여 알림 관련 앱에 전달할 수 있다.   \r\n예시는 기본적인 알림에서와 동일하지만 `직접 응답`은 사용자의 입력이 textView를 통하여 보여주는점이 다르다. [(직접 응답 알림 예시코드)](https://github.com/ppeper/Android_Arctic-Fox/tree/main/DirectReply)\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/151329014-e1d0b614-194a-4f66-ad8b-d70c81eadf96.png\" width=\"20%\">\r\n\r\n## RemoteInput 객체 생성\r\n<img src=\"https://user-images.githubusercontent.com/63226023/151330082-32633069-2932-4ccf-85d5-2e7aaf07f1de.png\">\r\n\r\n알림에서 직접 응답 텍스트 입력을 가능하게 해주기 위해서는 __RemoteInput__ 객체를 생성해야 한다. __RemoteInput__ 객체 또한 기본 알림과 같이 `인텐트`와 `사용자가 입력한 텍스트`를 PendingIntent가 포함될 수 있게 해준다.\r\n\r\n__RemoteInput.Builder()__ 함수를 사용하여 RemoteInput 객체를 생성하게 되고 여기서 필요한 것이 두가지이다.\r\n\r\n> 1. 인텐트의 `사용자의 입력`을 추출하기 위한 __키 문자열__\r\n> 2. 알림의 `텍스트 입력 필드`에 나타낼 __라벨 문자열__\r\n\r\n```kotlin\r\n private val KEY_TEXT_REPLY = \"key_text_reply\"\r\n\r\n fun sendNotification(view: View) {\r\n        val replyLabel = \"Enter your reply here\"\r\n        val remoteInput = RemoteInput.Builder(KEY_TEXT_REPLY)\r\n            .setLabel(replyLabel)\r\n            .build()\r\n\r\n        .\r\n        .\r\n        .\r\n    }\r\n```\r\n이제 기본 알림과 마찬가지로 생성된 RemoteInput 객체를 `알림 액션`객체에 포함시켜야 한다.   \r\n그 전에 PendingIntent 객체를 생성하여 사용자가 응답한 입력을 추출할 수 있게 생성해 준다.\r\n\r\n```kotlin\r\nval resultIntent = Intent(this, MainActivity::class.java)\r\n\r\n        val resultPendingIntent = PendingIntent.getActivity(\r\n            this, 0, resultIntent, PendingIntent.FLAG_UPDATE_CURRENT\r\n        )\r\n```\r\n\r\n이후 알림 액션에 `addRemoteInput()`을 호출하여 생성한 __RemoteInput__ 객체를 연결해 준다.\r\n\r\n```kotlin\r\nval icon = Icon.createWithResource(\r\n    this,\r\n    android.R.drawable.ic_dialog_info\r\n)\r\n\r\nval replyAction = Notification.Action.Builder(\r\n    icon, \"Reply\", resultPendingIntent)\r\n    .addRemoteInput(remoteInput)\r\n    .build()\r\n```\r\n\r\n끝으로 생성된 `알림`을 적용하고 표시한다.\r\n```kotlin\r\nval newMessageNotification = Notification.Builder(this, channelID)\r\n        .setColor(ContextCompat.getColor(this,\r\n        R.color.design_default_color_primary))\r\n        .setSmallIcon(android.R.drawable.ic_dialog_info)\r\n        .setContentTitle(\"My Notification\")\r\n        .setContentText(\"This is a test Message\")\r\n        .addAction(replyAction)\r\n        .build()\r\n\r\nval notificationManager = getSystemService(\r\n    Context.NOTIFICATION_SERVICE) as NotificationManage\r\nnotificationManager.notify(\r\n    notificationId,\r\n    newMessageNotification\r\n)\r\n```\r\n앱을 실행해 보면 생성된 `직접 응답 알림`을 확인해 볼 수 있다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/151334603-3688781f-8352-4035-9816-a85b98c31f98.png\" width=\"30%\"> <img src=\"https://user-images.githubusercontent.com/63226023/151334622-e927ef45-28b6-4c2c-a283-77dd70ec5b91.png\" width=\"32%\">\r\n\r\n## 직접 응답 입력 데이터 수신하기\r\n사용자가 알림의 직접 입력을 하였으므로 앱에서 입력 데이터를 받아와야 할 것이다. 앞서 말했던 textView를 통하여 입력데이터의 수신을 확인해 본다.\r\n\r\n사용자의 입력 데이터를 가져오기 위해서는 위에서 생성한 __RemoteInput.getResultsFromIntent()__ 를 통하여 Bundle 객체를 반환하여 가져온다.\r\n\r\n```kotlin\r\n private fun handleIntent() {\r\n        val intent = this.intent\r\n        val remoteInput = RemoteInput.getResultsFromIntent(intent)\r\n        if (remoteInput != null) {\r\n            val inputString = remoteInput.getCharSequence(\r\n                KEY_TEXT_REPLY).toString()\r\n            binding.textView.text = inputString\r\n        }\r\n }\r\n```\r\n여기서 전에 RemoteInput 객체 생성시 사용한 Key값`(KEY_TEXT_REPLY)`으로 Bundle 값을 가져온다.\r\n\r\n알림에서 응답 텍스트를 입력하고 전송하게되면 전송된 응답 텍스트의 액티비티 수신 확인을 기다리는 것을 나타낸다. 알림 전송시 사용한 동일한 ID로 알림을 업데이트 하여 사용자에게 `답장이 올바르게 수신되고 처리`되었음을 확인하기 위해 필요하다.\r\n```kotlin\r\nprivate fun handleIntent() {\r\n        .\r\n        .\r\n        val repliedNotification = Notification.Builder(this, channelID)\r\n            .setSmallIcon(android.R.drawable.ic_dialog_info)\r\n            .setContentText(\"Reply received\")\r\n            .build()\r\n\r\n        notificationManager?.notify(notificationId, repliedNotification)\r\n    }\r\n}\r\n```\r\n앱을 실행하여 메시지를 보내게 되면 생성한 `repliedNotification`으로 알림이 바뀌는것을 볼 수 있다.   \r\n-> (텍스트 \"Hello\"로 직접응답 메시지 전송)\r\n\r\n<img src = \"https://user-images.githubusercontent.com/63226023/151365468-0f00e889-943f-4b47-8072-c1eb231d4480.png\" width=\"30%\"> <img src = \"https://user-images.githubusercontent.com/63226023/151365476-72cf2f63-e0a2-476d-900e-121ecfad7251.png\">\r\n\r\n- - -\r\n\r\n# References\r\n- [Android developer 알림 개요](https://developer.android.com/training/notify-user/build-notification?hl=ko)\r\n"},{"excerpt":"안드로이드의 개념을 다시 한번 보면서 Notification(알림)을 처음으로 공부해 보았다. 알림 구현에서 를 사용하라고 하여 사용했지만 명확한 개념을 알려주지 않고 넘어가 와 가 무엇이 다른지 궁금하여 정리해 보았다. PendingIntent 안드로이드 developer에서 PendingIntent는 다른 응용 프로그램(프로세스)이 동일한 권한 및 I…","fields":{"slug":"/pendingintent/"},"frontmatter":{"date":"January 25, 2022","title":"안드로이드 PendingIntent의 개념","tags":["Android","PendingIntent"]},"rawMarkdownBody":"- - -\r\n안드로이드의 개념을 다시 한번 보면서 Notification(알림)을 처음으로 공부해 보았다. 알림 구현에서 `PendingIntent`를 사용하라고 하여 사용했지만 명확한 개념을 알려주지 않고 넘어가 `PendingIntent`와 `Intent`가 무엇이 다른지 궁금하여 정리해 보았다.\r\n\r\n# PendingIntent\r\n > 안드로이드 developer에서 PendingIntent는 다른 응용 프로그램(프로세스)이 동일한 권한 및 ID를 사용하는 것처럼 지정한 작업을 수행할 수 있는 권한을 해당 응용 프로그램에 부여하게 된다고 설명한다.~~(이게 무슨의미지..?😅)~~\r\n\r\nPendingIntent 객체는 이름에서 볼 수 있듯이 __Intent__ 를 가지고 있는 클래스이다. 앞의 `Pending`이 붙은것을 보면 PendingIntent의 특징을 어느정도 유추해 볼 수 있다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/150944701-1b6b8e8c-bab9-428e-8f7a-9524222e2e34.png\" >\r\n\r\n\r\n__Pending__ 은 __보류__ 라는 의미를 가진 단어이다. 이를 합쳐보면 PendingIntent는 `보류중인 인텐트` 라고 할 수 있다.\r\n\r\n보류중이라는 것은 나중에 어느 시점에 실행이 된다는 뜻이므로 PendingIntent는 __바로 실행을 하지 않고 어느 특정 시점에 실행을 하는 Intent__ 라는 의미로 파악할 수 있다. 어느 특정시점이라고 하면 이는 보통 __앱이 구동되지 않고__ 있을 시점이다. \r\n\r\n사용 예시로 Notification(알림)이 있다. 어플리케이션 안에서 __대용량 데이터를 다운__ 받을 시 보통 사용자는 다운로드 중에는 다른 앱을 사용하다가 __다운로드가 완료__ 되었을때 푸시알림을 통하여 앱으로 다시 돌아가는 경우를 본적이 있을것이다. \r\n\r\n푸시알림을 하기위한 `Notification`은 안드로이드 시스템의 __NotificationManager__ 을 통하여 `Intent`가 실행하게 된다. 이는 다른 프로세스에서 Intent를 실행하는 것으로 PendingIntent를 사용이 필수적이다.\r\n\r\n> 🔔 PendingIntent를 통하여 `앱이 구동되지 않을때` 다른 프로세스(예: Notification)에게 권한을 허가하여 `Intent`(지정한 작업)를 수행 할 수 있게 한다.\r\n\r\n- - -\r\n## PendingIntent 생성하기\r\nPendingIntent 객체는 각 컴포넌트마다 생성자의 호출방식이 다르다.\r\n\r\n### - Activity\r\n ```PendingIntent.getActivity(Context, Int, Intent, Int)```\r\n\r\n### - BroadcastReceiver\r\n ```PendingIntent.getBroadcast(Context, Int, Intent, Int)```\r\n\r\n### - Service\r\n ```PendingIntent.getService(Context, Int, Intent, Int)```\r\n\r\n\r\n각 컴포넌트마다 파라미터는 __Context, Int, Intent, Int__ 는 공통으로 구성되어 있다.\r\n\r\n## 파라미터 정보\r\n1. __Context__ : 해당 `context` 정보이다.\r\n2. __Int__ : `requestCode`로 `PendingIntent`를 가져올때 구분을 하기위하여 사용한다.\r\n3. __Intent__ : 실행할 `Intent`이다.\r\n4. __Int__ : 플래그의 값 이다.\r\n    - `FLAG_CANCEL_CURRENT` : 전에 생성한 `PendingIntent`를 취소 후 새로 사용\r\n    - `FLAG_UPDATE_CURRENT` : 전에 생성한 `PendingIntent`가 있다면, `Extra Data` 를 모두 교체\r\n    - `FLAG_NO_CREATE` : 전에 생성한 `PendingIntent`가 있다면 재사용 (없으면 `Null` 리턴)\r\n    - `FLAG_ONE_SHOT` : `PendingIntent`를 일회성으로 사용\r\n\r\n# References\r\n- [PendingIntent - Android Developers](https://developer.android.com/reference/android/app/PendingIntent)"},{"excerpt":"서비스(Service) 안드로이드 Service 클래스는 앱이 백그라운드 작업을 시작시켜 수행할 수 있게 특별히 설계되었다. 작업을 빨리 수행하고 종료하는 브로드캐스트 수신자와는 다르게, 서비스는 실행 시간이 길면서 사용자 인터페이스를 필요로 하지 않는 작업을 수행 한다. (예시: 음악을 스트리밍을 하거나, 다른앱을 사용하면서 전화를 한다.) 서\n비스는 …","fields":{"slug":"/android-service/"},"frontmatter":{"date":"January 24, 2022","title":"안드로이드 서비스(Service) 개요","tags":["Android","Service"]},"rawMarkdownBody":"- - -\r\n# 서비스(Service)\r\n안드로이드 Service 클래스는 앱이 백그라운드 작업을 시작시켜 수행할 수 있게 특별히 설계되었다. 작업을 빨리 수행하고 종료하는 [브로드캐스트 수신자](https://ppeper.github.io/android/broadcast/)와는 다르게, 서비스는 실행 시간이 길면서 사용자 인터페이스를 필요로 하지 않는 작업을 수행 한다. (예시: 음악을 스트리밍을 하거나, 다른앱을 사용하면서 전화를 한다.)\r\n\r\n서\r\n비스는 백그라운드에서 작업을 처리한다고 하였기 때문에 별도의 스레드에서 실행된다고 오해할수 있다. 하지만 서비스는 기본적으로 자신이 시작된 컴포넌트와 같은 __메인 스레드__ 에서 실행이 되기 때문에 CPU를 많이 사용하는 작업을 서비스가 실행을 해야한다면 새로운 스레드에서 수행되어야 한다.\r\n\r\n- __백그라운드__ 에서 작업을 하는 컴포넌트이다.\r\n- 서비스는 시작된 컴포넌트와 같은 __메인 스레드__ 에서 실행된다.\r\n\r\n크게 나누게되면 서비스는 두가지로 나눌 수 있다.\r\n\r\n- 스타트 서비스\r\n    - 포그라운드\r\n    - 백그라운드\r\n- 바운드 서비스\r\n\r\n작게는 서비스에는 세가지의 유형으로 나눌 수 있다.\r\n\r\n- 포그라운드\r\n- 백그라운드\r\n- 바운드\r\n\r\n- - -\r\n\r\n## 포그라운드\r\n\r\n포그라운드 서비스는 _사용자에게 보이는 작업_ 을 실행한다. 예를 들어 음악을 듣게 된다면 이는 포그라운드 서비스로 `알림`을 표시해야 한다. \r\n서비스이기 때문에 사용자와 상호작용을 하지않아도 계속 실행이 된다.\r\n\r\n<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/150674062-e2b31742-a117-44f5-8882-7b57727c20ac.png\" width=\"50%\"></p>\r\n\r\n## 백그라운드\r\n\r\n백그라운드 서비스는 _사용자에게 보이지 않는 작업_ 을 실행한다.\r\n공식 홈페이지에서는 앱이 스토리지와 관련된 기능을 수행하는 서비스를 사용한다면, 보통 그것은 백그라운드 서비스라고 한다.\r\n\r\n > 참고 : 앱이 API 레벨 26 이상인 경우, 앱 자체가 포그라운드에 있지 않을 때 시스템이 백그라운드 서비스 실행에 제한을 건다. 이와 같은 경우 앱은 `예약된 작업(scheduled job)`을 사용해야한다.\r\n\r\n## 바운드\r\n바운드 서비스는 자신을 시작시킨 컴포넌트와의 상호작용을 허용하고 그 결과를 받을 수도 있다. 상호 작용을 위해 바운드 서비스는 __`bindService()`__ 를 통하여 앱 구성 요소를 서비스에 바인딩할 수 있다.\r\n\r\n바인딩된 서비스는 __바인딩한 구성 요소와 상호작용__ 을 하면서 요청을 주고 결과를 받을 수 있게 되는 __클라이언트-서버 구조__ 를 제공한다. 또한 __IPC(프로세스 간 통신)__ 의 구현을 통해서 이러한 상호작용이 프로세스 간에도 일어날수 있다. 또한 동시에 여러 컴포넌트가 한 서비스에 바인딩될 수 있다.\r\n\r\n바인딩한 서비스가 더 이상 필요로 하지 않을 떄는 __`unbindService`__ 함수를 호출하여 바인딩을 해제할 수 있고 모든 구성 요소가 서비스에서 바인딩을 하제하면 해당 서비스는 안드로이드 런타임 시스템에 의해 종료된다.\r\n\r\n바운드 서비스는 __`onBind()`__ 함수의 구현을 포함한다. 이 함수는 서비스가 __최초로 생성__ 될 때 그리고 그 이후에 다른 구성 요소가 __해당 서비스에 바인딩__ 할 때 자동 호출 된다. \r\n이 함수의 목적은 바인딩한 컴포넌트에 __IBinder__ 타입의 객체를 반환한다.\r\n\r\n- 바운드 서비스 요약\r\n    - 바인딩을 통하여 구성 요소와 상호작용을 한다.\r\n    - __bindService()__ 함수를 통하여 서비스에 바인딩한다.\r\n    - __onBind()__ 함수를 통하여 __IBinder__ 타입의 객체를 반환한다.\r\n\r\n- - -\r\n\r\n# 서비스 생명주기\r\n\r\n<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/63226023/150674329-805df55b-0cde-4a26-915a-1cc42fb9343a.png\" width=\"50%\"></p>\r\n\r\n서비스는 안드로이드 Service 클래스의 서브 클래스로 생성된다. 그리고 생성되는 서비스의 특성에 따라 다음의 콜랙 함수를 오버라이딩해야 한다.\r\n\r\n- onCreate() - 서비스가 생성될 때 호출되며, 이 함수가 호출된 이후 다음에 __onStartCommand()__ 함수가 호출되거나 __onBind()__ 함수가 최초 호출된다.\r\n- onStartCommand() - 다른 컴포넌트가 __startService()__ 함수를 호출하여 서비스를 시작시킬 때 호출된다.(바운드 서비스의 경우 구현할 필요가 없다)\r\n- onBind() - 컴포넌트가 __bindService()__ 함수를 호출하여 서비스에 바인딩할 때 호출된다. 바인드 서비스를 구현할 때는 이 함수에서 __IBinder__ 객체를 반환해야 한다. 이 객체는 서비스가 클라이언트와 통신할 때 사용한다. 스타트 서비스의 경우는 이 함수에서 null 값을 반환하도록 구현해야 한다.\r\n- onDestroy() - 서비스가 소멸될 때 호출된다.\r\n\r\n\r\n# 소멸된 서비스 재시작 옵션 제어\r\n서비스 클래스에서 오버라이딩한 __onStartCommand()__ 콜백 함수는 정수값을 반환해야 한다. 이것은 안드로이드 런타임 시스템에 의해 서비스가 소멸될 경우에 서비스를 어떻게 할 것인지 정의를 하는 값이다.\r\n\r\n- __START_NOT_STICKY__ - 처리 대기 중인 인텐트가 없다면 서비스가 소멸될 때 __다시 시작하지 말라고__ 시스템에게 알려 준다.\r\n- __START_STICKY__ - 만일 onStartCommand() 함수의 실행이 끝나고 복귀한 이후에 서비스의 소멸이 일어나면 서비스가 소멸된 후 가능한 빨리 __다시 시작되어야 한다__ 는 것을 나타낸다.\r\n- __START_REDELIVER_INTENT__ - 만일 onStartCommand() 함수의 실행이 끝나고 복귀한 이후에 서비스의 소멸되었다면 __현재의 인텐트__ 를 onStartCommand() 함수에 __다시 전송__ 하여 해당 서비스가 다시 시작되어야 한다는 것을 나타낸다. 그리고 그다음에 처리 대기 중인 인텐트가 전달된다.\r\n\r\n# Manifest 파일에 서비스 선언\r\n서비스가 사용될 수 있으려면 Manifest 파일에 선언이 되어야 한다. 이에 적합하게 구성된 __`<service>`__ 요소를 `<application>` 항목에 추가하면 된다.\r\n```xml\r\n.\r\n.\r\n.\r\n    <application\r\n            android:icon=\"@mipmap/ic_launcher\"\r\n            android:label=\"@string/app_name\">\r\n            <service\r\n                android:name=\".MyService\">\r\n            </service>\r\n    </application>\r\n```\r\n\r\n기본적으로 서비스는 public으로 선언된다. 즉, 서비스가 있는 앱 패키지 __외부의 컴포넌트가 액세스__ 할 수 있다는 의미이다. 서비스를 private으로 만들려면 __android:exported__ 속성을 false로 선언해야 한다.\r\n```xml\r\n<service \r\n    android:name=\".MyService\"\r\n    android:exported=\"false\">\r\n</service>\r\n```\r\n- - -\r\n\r\n\r\n# References\r\n\r\n- [안드로이드 서비스 개요](https://developer.android.com/guide/components/services?hl=ko)\r\n"},{"excerpt":"문제 설명 양의 정수 이 주어집니다. 이 숫자를 진수로 바꿨을 때, 변환된 수 안에 아래 조건에 맞는 소수(Prime number)가 몇 개인지 알아보려 합니다.  처럼 소수 양쪽에 0이 있는 경우  처럼 소수 오른쪽에만 0이 있고 왼쪽에는 아무것도 없는 경우  처럼 소수 왼쪽에만 0이 있고 오른쪽에는 아무것도 없는 경우  처럼 소수 양쪽에 아무것도 없는…","fields":{"slug":"/programmers-kakao-blind-2020-3/"},"frontmatter":{"date":"January 23, 2022","title":"프로그래머스 2022 KAKAO RECRUITMENT - k진수에서 소수 개수 구하기","tags":["Algorithm","programmers"]},"rawMarkdownBody":"\r\n### 문제 설명\r\n양의 정수 `n`이 주어집니다. 이 숫자를 `k`진수로 바꿨을 때, 변환된 수 안에 아래 조건에 맞는 소수(Prime number)가 몇 개인지 알아보려 합니다.\r\n\r\n* __`0P0`__ 처럼 소수 양쪽에 0이 있는 경우\r\n* __`P0`__ 처럼 소수 오른쪽에만 0이 있고 왼쪽에는 아무것도 없는 경우\r\n* __`0P`__ 처럼 소수 왼쪽에만 0이 있고 오른쪽에는 아무것도 없는 경우\r\n* __`P`__ 처럼 소수 양쪽에 아무것도 없는 경우\r\n* 단, __`P`__ 는 각 자릿수에 0을 포함하지 않는 소수입니다.\r\n   * 예를 들어, 101은 __`P`__ 가 될 수 없습니다.\r\n\r\n예를 들어, 437674을 3진수로 바꾸면 `211`0`2`0100`11`입니다. 여기서 찾을 수 있는 조건에 맞는 소수는 왼쪽부터 순서대로 211, 2, 11이 있으며, 총 3개입니다. (211, 2, 11을 `k`진법으로 보았을 때가 아닌, 10진법으로 보았을 때 소수여야 한다는 점에 주의합니다.) 211은 `P0` 형태에서 찾을 수 있으며, 2는 `0P0`에서, 11은 `0P`에서 찾을 수 있습니다.\r\n\r\n정수 `n`과 `k`가 매개변수로 주어집니다. `n`을 `k`진수로 바꿨을 때, 변환된 수 안에서 찾을 수 있는 위 조건에 맞는 소수의 개수를 return 하도록 solution 함수를 완성해 주세요.\r\n\r\n### 제한사항\r\n* 1 ≤ `n` ≤ 1,000,000\r\n* 3 ≤ `k` ≤ 10\r\n\r\n### 입출력 예\r\n<img src=\"https://user-images.githubusercontent.com/63226023/150669729-1c8bb414-e177-4eee-ac87-4c0b7de5f459.png\">\r\n\r\n### 제한시간 안내\r\n* 정확성 테스트 : 10초\r\n\r\n\r\n### 풀이\r\n문제의 요구사항을 보면 주어진 수를 K 진법으로 교체후 이를 __'0'__ 을 기준으로 나누어 소수인지를 확인하여 그 개수를 리턴하는 문제였다.\r\n\r\n예시에서 나온 437674를 3진수로 바꾼 예시만 보더라도 __'int'__ 형이 가질 수 있는 최대값을 넘기 때문에 __'long'__ 형으로 받아야 한다는 것을 먼저 생각하였다. 그 후 주어진 K값의 주어진 진법으로 교체와 __'0'__ 을 기준으로 split하여 소수인지 확인을 하여 구하는 값을 리턴하였다.\r\n\r\n# 코드\r\n\r\n```java\r\nclass K_Prime {\r\n    public int solution(int n, int k) {\r\n        int answer = 0;\r\n        String[] split = convert(n,k).split(\"0\");\r\n        // 소수인지 확인\r\n        for (String sNumber: split) {\r\n            if (!sNumber.equals(\"\") && isPrime(Long.parseLong(sNumber))) answer++;\r\n        }\r\n\r\n        return answer;\r\n    }\r\n\r\n    // k진법으로 교체\r\n    private String convert(int n, int k) {\r\n        StringBuilder sb = new StringBuilder();\r\n        if (k == 10) {\r\n            return String.valueOf(n);\r\n        }\r\n        while (n != 0) {\r\n            int remainder = n % k;\r\n            sb.insert(0, remainder);\r\n            n /= k;\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    // 소수 확인\r\n    public boolean isPrime(long num) {\r\n        if (num == 1) return false;\r\n        for (long i = 2; i <= Math.sqrt(num); i++) {\r\n            if (num % i == 0) return false;\r\n        }\r\n        return true;\r\n    }\r\n}  \r\n```\r\n\r\n"},{"excerpt":"브로드캐스트(Broadcast) 앱의 액티비티를 시작시키는 메커니즘을 제공하는 것과 더불어 인텐트는 시스템의 다른 컴포넌트에 시스템 차원의 메시지를 전파하는 방법으로 사용될 수 있다. 예를 들어 안드로이드 시스템은 부팅이나 배터리가 부족할때와 같은 시스템 이벤트가 발생하면 브로드캐스트 를 전송한다.  브로드캐스트(방송)를 보낸다고 하면 어떠한 정의된 방법…","fields":{"slug":"/broadcast/"},"frontmatter":{"date":"January 20, 2022","title":"안드로이드 브로드캐스트(Broadcast)","tags":["Android","Broadcast"]},"rawMarkdownBody":"- - -\r\n# 브로드캐스트(Broadcast)\r\n앱의 액티비티를 시작시키는 메커니즘을 제공하는 것과 더불어 인텐트는 시스템의 다른 컴포넌트에 시스템 차원의 메시지를 전파하는 방법으로 사용될 수 있다. 예를 들어 안드로이드 시스템은 부팅이나 배터리가 부족할때와 같은 시스템 이벤트가 발생하면 __브로드캐스트__ 를 전송한다. \r\n\r\n브로드캐스트(방송)를 보낸다고 하면 어떠한 정의된 방법으로 `포장`을 하고 보내는 사람이 있으면 받는 `수신자`가 있을것이다. 안드로이드에서는 이를 __브로드캐스트 인텐트__, __브로드캐스트 수신자__ 를 사용한다.\r\n\r\n## 브로드캐스트 인텐트 개요\r\n브로드캐스트 인텐트는 Activity 클래스의 `sendBroadcast()` 또는 `sendStickyBroadcast()` 또는 `sendOrderedBroadcast()` 함수를 호출하여 전파되는 Intent 객체다. [(안드로이드 인텐트 개념)](https://ppeper.github.io/android/intent/)\r\n\r\n브로드캐스트 인텐가 생성될 때는 __액션 문자열__ 을 포함해야 한다. 그리고 선택적인 데이터와 카테고리 문자열을 추가로 포함할 수 있다. 즉, 일반적인 인텐트와 마찬가지로 __putExtra(String, Bundle)__ 를 사용하여 데이터를 브로드캐스트 인텐트에 추가할 수 있다. \r\n\r\n```kotlin\r\nval intent = Intent()\r\nintent.action = \"com.example.Broadcast\"\r\nintent.putExtras(\"MyData\", 1000)\r\nsendBroadcast(intent)\r\n```\r\n\r\n위의 예시는 안드로이드 3.0 이전 버전을 실행 중인 장치에서는 성공적으로 브로드캐스트 수신자를 시작시킬 수 있을 것이다. 그러나 3.0 이상 버전에서는 론칭(실행)을 제어하는 보안 조치가 도입되어 브로드캐스트 수신자에 의해 이 인텐트가 수신되지 않는다고 한다. -> __사용 정지된__ 앱의 컴포넌트가 인텐트를 통하여 시작되는 것을 막는 조치다.\r\n\r\n앱이 방금 설치되어서 이전에 론칭(시작)된 적이 없거나 장치의 앱 매니저를 사용해서 사용자가 수동으로 정지시켰을 경우, 해당 앱은 사용 정지된 상태에 있다고 간주된다. \r\n\r\n```kotlin\r\nval intent = Intent()\r\nintent.action = \"com.example.Broadcast\"\r\nintent.putExtras(\"MyData\", 1000)\r\n-> intent.flags = Intent.FLAG_INCLUDE_STOPPED_PACKAGES\r\nsendBroadcast(intent)\r\n```\r\n\r\n이것을 해결하려면 인텐트에 __FLAG_INCLUDE_STOPPED_PACKAGES__ 플래그를 추가하여 사용 정지된 앱의 컴포넌트를 시작시키는 것이 인텐트에 허용된다는 것을 나타낼 수 있다.~~(Flags를 찾아보며 알아가야겠다..))~~\r\n\r\n\r\n## 브로드캐스트 수신자 개요\r\n브로드캐스트 인텐트가 생성이 되었다면 받을 수신자를 등록해야 한다. 브로드캐스트 수신자는 __BroadcastReceiver__ 클래스로 부터 상속받고 __onReceive()__ 함수를 오버라이딩하여 구현 한다.\r\n\r\n브로드캐스트 인텐트와 받을 브로드캐스트 리시버가 있으면 수신자가 누군지 정해주어야 할 것이다. 안드로이드에서는 이를 __manifest 파일__ 및 __컨텍스트__(예: 액티비티 내부)에의 두가지 방식으로 수신자를 등록하여 브로드캐스트 인텐트를 수신할 수 있다. \r\n\r\n인텐트 필터에 특정 브로드캐스트 인텐트를 나타내는 __액션 문자열__ 을 정의하면 안드로이드에서 이 액션 문자열과 일치하는 브로드캐스트 인텐트가 감지되면 해당 브로드캐스트 수신자의 __onReceive()__ 함수가 호출된다. \r\n\r\n### Manifest.xml에 수신자 등록\r\n브로드캐스트 수신자를 매니페스트 파일에 등록할 때는 __`<receiver>`__ 항목을 추가해야 한다.\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    package=\"com.kyonggi.sendbroadcast\">\r\n\r\n    <application\r\n        android:allowBackup=\"true\"\r\n        android:icon=\"@mipmap/ic_launcher\"\r\n        android:label=\"@string/app_name\"\r\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\r\n        android:supportsRtl=\"true\"\r\n        android:theme=\"@style/Theme.SendBroadcast\">\r\n        <receiver\r\n            android:name=\".MyReceiver\"\r\n            android:enabled=\"true\"\r\n            android:exported=\"true\">\r\n        </receiver>\r\n                .\r\n                .\r\n                .\r\n    </application>\r\n</manifest>\r\n```\r\n\r\n안드로이드 8.0 이전 버전이 실행되는 경우에는 수신자와 관련된 인텐트 필터를 manifest 파일의 receiver에 둘 수 있다. 예시에서는 \"com.exmaple.Broadcast\"를 포함하는 브로드캐스트 인텐트를 리스닝한다.\r\n```xml\r\n<receiver \r\n    android:name=\".MyReceiver\">\r\n        <intent-filter>\r\n            <action android:name=\"com.example.Broadcast\">\r\n            </action>\r\n        </intent-filter>\r\n</receiver>\r\n```\r\n\r\n### 컨텍스트에 수신자 등록\r\n\r\n반면에 안드로이드 8.0 이상 버전에서는 코드에서 적합한 __IntentFilter__ 객체를 생성한 후 Activity 클래스의 __registerReceiver()__ 함수를 호출하여 등록해야 한다.\r\n\r\n```kotlin\r\nval filter = IntentFilter()\r\nfilter.addAction(\"com.example.Broadcast\")\r\nval receiver = MyReceiver()\r\nregisterReceiver(receiver, filter)\r\n```\r\n\r\n코드에서 등록된 브로드캐스트 수신자가 더 이상 필요하지 않을 때는 Activity 클래스의 __`unregisterReceiver(receiver: BroadcastReceiver!)`__ 함수를 호출하여 등록을 해지할 수 있다.\r\n\r\n```kotlin\r\nunregisterReceiver(receiver)\r\n```\r\n- - -\r\n\r\n# 예제 코드\r\n\r\n- activity_main.xml\r\n\r\n 버튼과 onclick 속성으로 broadcastIntent()를 함수를 구현한다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/150098676-4b56e257-eb45-4a40-be66-b8f2c751fc62.png\" height=\"50%\">\r\n\r\n- MainActivity class\r\n\r\nMainActivity에서 브로드캐스트 인텐트를 지정해주고 액션 문자열은 __com.kyonggi.sendbroadcast__ 로 지정한다.\r\n\r\n그 다음은 \"브로드캐스트 수신자\"의 인텐트 필터에 위의 액션 문자과 일치하는 __`<action>`__ 요소를 정의할 것이다.\r\n\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n    .\r\n    .\r\n    // 브로드캐스트 인텐트를 전송\r\n    fun broadcastIntent(view: View) {\r\n        val intent = Intent()\r\n        intent.action = \"com.kyonggi.sendbroadcast\"\r\n        intent.flags = Intent.FLAG_INCLUDE_STOPPED_PACKAGES\r\n        sendBroadcast(intent)\r\n    }\r\n}\r\n```\r\n- MyReceiver class\r\n\r\n1. 브로드캐스트 리시버는 __BroadcastReceiver()__ 와 __onReceive()__ 를 구현해야 한다고 하였다.\r\n2. 예시에서는 Toast메시지를 통하여 브로드캐스트 인텐트를 수신하였는지 확인할 것이다.\r\n\r\n```kotlin\r\nclass MyReceiver : BroadcastReceiver() {\r\n\r\n    override fun onReceive(context: Context, intent: Intent) {\r\n        val message = \"Broadcast intent detected \" + intent.action\r\n        Toast.makeText(context, message, Toast.LENGTH_SHORT).show()\r\n    }\r\n}\r\n```\r\n\r\n브로드캐스트 인텐트와 브로드캐스트 리시버가 완성되었기 때문에 이제 수신자를 등록해 주어야 한다.\r\n\r\n수신자는 위에서 말한 인텐트 필터를 통하여 액션 문자열과 리시버를 포함해야한다. \r\n\r\nMyReceiver를 생성하였을 때 안드로이드 스튜디오에서 자동으로 __`<receiver>`__ 요소를 manifest 파일에 추가해 주었다. 지금 실행하는 안드로이드는 8.0 이상이기때문에 코드로 __IntentFilter__ 를 설정해 주어야한다.\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    // 브로드캐스트 인텐트를 지정해야한다.\r\n    var receiver: BroadcastReceiver? = null\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        .\r\n        .\r\n        configureReceiver()\r\n    }\r\n\r\n    private fun configureReceiver() {\r\n        val filter = IntentFilter()\r\n        filter.addAction(\"com.kyonggi.sendbroadcast\")\r\n        receiver = MyReceiver()\r\n        registerReceiver(receiver, filter)\r\n    }\r\n\r\n    override fun onDestroy() {\r\n        super.onDestroy()\r\n        unregisterReceiver(receiver)\r\n    }\r\n    .\r\n    .\r\n}\r\n```\r\nonDestroy() 함수는 브로드캐스트 수신자가 더 이상 필요 없을 때 등록을 해지하기 위해 필요하다.\r\n\r\n안드로이드 장치에서 Send Broadcast 버튼을 터치하면 처음 등록한 Toast 메시지가 나타나는걸 볼 수 있다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/150101172-d94e1502-ab10-4e7a-9a7a-58f529acfa1c.png\" height=\"50%\">\r\n\r\n- 추가: 장치의 외부 전원이 끊어졌을 때 전송되는 시스템 브로드캐스트 인텐트를 리스닝 하도록 브로드캐스트 수신자의 인텐트 필터를 변경해 보자. 이때 사용되는 액션은 __android.intent.action.ACTION_POWER_DISCONNECTED__ 이다.\r\n\r\n```kotlin\r\n    private fun configureReceiver() {\r\n        val filter = IntentFilter()\r\n        filter.addAction(\"android.intent.action.ACTION_POWER_DISCONNECTED\")\r\n        receiver = MyReceiver()\r\n        registerReceiver(receiver, filter)\r\n    }\r\n```\r\n\r\n이제 다시 앱을 실행하여 전원을 공급을 하지 않게되면 다음과 같은 Toast 메시지가 나올것이다. (에뮬레이터에서 실행 중이라면 확장 제어 대화상자 -> Battery선택 -> Charger connection을 AC charger 선택 했다가 None으로 변경)\r\n\r\n``` > Broadcast intent detected android.intent.action.ACTION_POWER_DISCONNECTED```\r\n\r\n\r\n[시스템 브로드캐스트 인텐트 수신 예시](https://github.com/ppeper/Android_Arctic-Fox/tree/main/SendBroadcast)\r\n- - -\r\n\r\n# References\r\n- [안드로이드 브로드캐스트 개요](https://developer.android.com/guide/components/broadcasts?hl=ko)\r\n\r\n"},{"excerpt":"문제 설명 신입사원 무지는 게시판 불량 이용자를 신고하고 처리 결과를 메일로 발송하는 시스템을 개발하려 합니다. 무지가 개발하려는 시스템은 다음과 같습니다. 각 유저는 한 번에 한 명의 유저를 신고할 수 있습니다. 신고 횟수에 제한은 없습니다. 서로 다른 유저를 계속해서 신고할 수 있습니다. 한 유저를 여러 번 신고할 수도 있지만, 동일한 유저에 대한 신…","fields":{"slug":"/programmers-kakao-blind-2020-2/"},"frontmatter":{"date":"January 20, 2022","title":"프로그래머스 2022 KAKAO RECRUITMENT - 신고 결과 받기","tags":["Algorithm","programmers"]},"rawMarkdownBody":"\r\n- - -\r\n### 문제 설명\r\n신입사원 무지는 게시판 불량 이용자를 신고하고 처리 결과를 메일로 발송하는 시스템을 개발하려 합니다. 무지가 개발하려는 시스템은 다음과 같습니다.\r\n\r\n* 각 유저는 한 번에 한 명의 유저를 신고할 수 있습니다.\r\n    * 신고 횟수에 제한은 없습니다. 서로 다른 유저를 계속해서 신고할 수 있습니다.\r\n    * 한 유저를 여러 번 신고할 수도 있지만, 동일한 유저에 대한 신고 횟수는 1회로 처리됩니다.\r\n\r\n* k번 이상 신고된 유저는 게시판 이용이 정지되며, 해당 유저를 신고한 모든 유저에게 정지 사실을 메일로 발송합니다.\r\n    * 유저가 신고한 모든 내용을 취합하여 마지막에 한꺼번에 게시판 이용 정지를 시키면서 정지 메일을 발송합니다.\r\n\r\n다음은 전체 유저 목록이 [\"muzi\", \"frodo\", \"apeach\", \"neo\"]이고, k = 2(즉, 2번 이상 신고당하면 이용 정지)인 경우의 예시입니다.\r\n\r\n<img src = \"https://user-images.githubusercontent.com/63226023/150295190-4e88d4cf-f7ce-44c5-992e-1341efe30350.png\">\r\n\r\n각 유저별로 신고당한 횟수는 다음과 같습니다.\r\n\r\n<img src = \"https://user-images.githubusercontent.com/63226023/150295269-95f0c657-f21e-43c3-a6c0-b2e7f0f3dc96.png\">\r\n\r\n위 예시에서는 2번 이상 신고당한 \"frodo\"와 \"neo\"의 게시판 이용이 정지됩니다. 이때, 각 유저별로 신고한 아이디와 정지된 아이디를 정리하면 다음과 같습니다.\r\n\r\n<img src = \"https://user-images.githubusercontent.com/63226023/150295291-4a52f6d3-482f-4215-8393-8a08d0566bee.png\">\r\n\r\n따라서 \"muzi\"는 처리 결과 메일을 2회, \"frodo\"와 \"apeach\"는 각각 처리 결과 메일을 1회 받게 됩니다.\r\n\r\n이용자의 ID가 담긴 문자열 배열 `id_list`, 각 이용자가 신고한 이용자의 ID 정보가 담긴 문자열 배열 `report`, 정지 기준이 되는 신고 횟수 `k`가 매개변수로 주어질 때, 각 유저별로 처리 결과 메일을 받은 횟수를 배열에 담아 return 하도록 solution 함수를 완성해주세요.\r\n\r\n### 제한사항\r\n* 2 ≤ `id_list`의 길이 ≤ 1,000\r\n    * 1 ≤ `id_list`의 원소 길이 ≤ 10\r\n    * `id_list`의 원소는 이용자의 id를 나타내는 문자열이며 알파벳 소문자로만 이루어져 있습니다.\r\n    * `id_list`에는 같은 아이디가 중복해서 들어있지 않습니다.\r\n\r\n* 1 ≤ `report`의 길이 ≤ 200,000\r\n    * 3 ≤ `report`의 원소 길이 ≤ 21\r\n    * `report`의 원소는 \"이용자id 신고한id\"형태의 문자열입니다.\r\n    * 예를 들어 \"muzi frodo\"의 경우 \"muzi\"가 \"frodo\"를 신고했다는 의미입니다.\r\n    * id는 알파벳 소문자로만 이루어져 있습니다.\r\n    * 이용자id와 신고한id는 공백(스페이스)하나로 구분되어 있습니다.\r\n    * 자기 자신을 신고하는 경우는 없습니다.\r\n\r\n* 1 ≤ `k` ≤ 200, `k`는 자연수입니다.\r\n    * return 하는 배열은 `id_list`에 담긴 id 순서대로 각 유저가 받은 결과 메일 수를 담으면 됩니다.\r\n\r\n### 입출력 예\r\n\r\n<img src = \"https://user-images.githubusercontent.com/63226023/150296370-6f07b381-c923-436c-b870-43a2a89539fd.png\">\r\n\r\n### 풀이\r\n가장 처음 신고내용이 중복이 안된다고 하였으므로 집합(Set)을 사용하여 중복된 신고를 빼야한다고 생각하였다. \r\n```java\r\nHashSet<String> reportFilter = new HashSet<String>(Arrays.asList(report));\r\n```\r\n그 이후 reportFilter를 가지고 각 인원의 신고당한 횟수를 저장하고 이미 신고를 당했으면 HashMap에 __getOrDefault()__ 를 통하여 +1을 해주었다.\r\n\r\n각 인원이 신고한 사람들을 따로 리스트를 만들어서 저장을 하려하다가 __getOrDefault()__ 함수로 신고를 한사람이 2명 이상이면 __\" \"__ 에 다음 신고자를 저장하는 방법을 사용해 보았다.\r\n\r\n```java\r\n    // 신고내용 저장 && 신고당한사람 Count\r\n    private void setReports(HashMap<String, String> hm, HashMap<String, Integer> reportCount, HashSet<String> reportFilter) {\r\n        for (String str : reportFilter) {\r\n            String[] split = str.split(\" \");\r\n            // 신고자가 신고한 사람들 저장 -> 이미 신고한사람이 있으면 그 뒤에 \" \"후 다음 신고한 인원 저장\r\n            hm.put(split[0], hm.getOrDefault(split[0], \"\") + \" \" +split[1]);\r\n            // 신고당한 사람 Count -> 이미 신고를 당했으면 +1\r\n            reportCount.put(split[1], reportCount.getOrDefault(split[1], 0) + 1);\r\n        }\r\n    }\r\n```\r\n\r\n신고자를 매개변수로 받아서 그 사람이 신고한 사람들이 __k__ 이상으로 신고당했으면 count를 하여 return 하는 함수를 사용하였다.\r\n\r\n> -> 여기서 처음 신고자의 문자열을 저장할때 __\" \"__ 을 저장으로 시작하였으므로 split 한후에 1번 인덱스부터 확인하였다. (0번은 \"\"(빈문자열))\r\n\r\n```java\r\n    private int count(String person, HashMap<String, String> hm, HashMap<String, Integer> reportCount, int k) {\r\n        int count = 0;\r\n        // 신고자가 신고한 리스트 가져옴\r\n        String str = hm.getOrDefault(person, \"\");\r\n        String[] list = str.split(\" \");\r\n        for (int i = 1; i < list.length; i++) {\r\n            String check = list[i];\r\n            if (reportCount.getOrDefault(check, 0) >= k) count++;\r\n        }\r\n        return count;\r\n    }\r\n```\r\n\r\n__전체 코드__\r\n\r\n```java\r\nimport java.util.Arrays;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\n\r\nclass Report {\r\n    public int[] solution(String[] id_list, String[] report, int k) {\r\n        int[] answer = new int[id_list.length];\r\n        HashSet<String> reportFilter = new HashSet<String>(Arrays.asList(report));\r\n        HashMap<String, String> hm = new HashMap<>();\r\n        HashMap<String, Integer> reportCount = new HashMap<>();\r\n        setReports(hm, reportCount, reportFilter);\r\n\r\n        // 결과값 구하기\r\n        for (int i = 0; i < id_list.length; i++) {\r\n            answer[i] = count(id_list[i], hm, reportCount, k);\r\n        }\r\n\r\n        return answer;\r\n    }\r\n\r\n    // 신고내용 저장 && 신고당한사람 Count\r\n    private void setReports(HashMap<String, String> hm, HashMap<String, Integer> reportCount, HashSet<String> reportFilter) {\r\n        for (String str : reportFilter) {\r\n            String[] split = str.split(\" \");\r\n            // 신고자가 신고한 사람들 저장 -> 이미 신고한사람이 있으면 그 뒤에 \" \"후 다음 신고한 인원 저장\r\n            hm.put(split[0], hm.getOrDefault(split[0], \"\") + \" \" +split[1]);\r\n            // 신고당한 사람 Count -> 이미 신고를 당했으면 +1\r\n            reportCount.put(split[1], reportCount.getOrDefault(split[1], 0) + 1);\r\n        }\r\n    }\r\n\r\n    private int count(String person, HashMap<String, String> hm, HashMap<String, Integer> reportCount, int k) {\r\n        int count = 0;\r\n        // 신고자가 신고한 리스트 가져옴\r\n        String str = hm.getOrDefault(person, \"\");\r\n        String[] list = str.split(\" \");\r\n        for (int i = 1; i < list.length; i++) {\r\n            String check = list[i];\r\n            if (reportCount.getOrDefault(check, 0) >= k) count++;\r\n        }\r\n        return count;\r\n    }\r\n}\r\n```\r\n\r\n"},{"excerpt":"Context?? 안드로이드 개발시 의 사용은 거의 모든 곳에서 사용되며 필자 또한 당연하게 생각하고 사용하였다.  를 자세하게 알고 사용하지 못하면 안드로이드 어플리케이션 개발시 메모리 누수가 쉽게 발생할 수 있다고 하여 제대로 정리를 하려고 한다. 안드로이드에서 Context(문맥, 맥락)는 현재 사용되고 있는 앱에 대한 전역 환경 정보 라고 한다. …","fields":{"slug":"/android-context/"},"frontmatter":{"date":"January 17, 2022","title":"안드로이드 Context의 개념","tags":["Android","Context"]},"rawMarkdownBody":"- - -\r\n\r\n# Context??\r\n안드로이드 개발시 `Context`의 사용은 거의 모든 곳에서 사용되며 필자 또한 당연하게 생각하고 사용하였다. \r\n\r\n`Context`를 자세하게 알고 사용하지 못하면 안드로이드 어플리케이션 개발시 메모리 누수가 쉽게 발생할 수 있다고 하여 제대로 정리를 하려고 한다.\r\n\r\n안드로이드에서 Context(문맥, 맥락)는 __현재 사용되고 있는 앱에 대한 전역 환경 정보__ 라고 한다.\r\n\r\n- Application의 현재의 상태(맥락)을 나타낸다.\r\n- Application, Activity의 정보를 얻기 위해 사용한다.\r\n- Resources, DB, SharedPreferences에 접근할 때 사용된다.\r\n- Context class는 Activity, Application class의 부모 클래스이다.\r\n\r\n\r\n```kotlin\r\n    Intent(applicationContext,ExampleActivity::class.java)\r\n    Intent(baseContext, ExampleActivity::class.java)\r\n    Intent(application, ExampleActivity::class.java)\r\n    Intent(this@MainActivity, ExampleActivity::class.java)\r\n```\r\n\r\n안드로이드 많이쓰이는 `Intent 객체` 에서 파라미터로 Context를 넘겨주는데 이 예시에서도 이렇게 __applicationContext__, __baseContext__, __application__, __this@액티비티__ 가 있다. ~~(그래서 다들 뭐가 다른건데...ㅜㅜ)~~ -> Context에 대해서 제대로 알아보자!!\r\n\r\n- - -\r\n\r\n# 자주 사용하는 Context의 종류\r\n- __Application Context__: Application에 관한 정보를 담은 Context\r\n- __Activity Context__: Activity 관한 정보를 담은 Context, -> Activity마다 존재한다\r\n\r\n## - Application Context\r\nApplication Context는 싱글톤 객체로 존재하고 kotlin에서는 `applicationContext`라는 함수로 접근이 가능하다. 이 Context는 어플리케이션 내 생명주기와 바인딩이 되어있다. \r\n\r\nApplication Context는 라이프사이클이 현재 Context와 분리된 Context가 필요하거나 활동 범위를 넘어 Context를 전달할 때 사용할 수 있다. -> 이 객체에 Activity Context를 넘겨주면 Application이 실행되는 동안에는 Activity에서 참조가 계속 발생하여 가비지 콜렉팅이 되지않아 __메모리 누수__ 가 일어나게 된다!\r\n\r\n한 예시로 Room을 사용하기위해 초기화할때 Context가 필요한대 이때 applicationContext를 사용한다. 그 이유는 Room은 어플리케이션이 실행되는동안 지속적으로 사용되는 __싱글톤__ 객체이기 때문에 `applicationContext`을 사용하는 것이다.\r\n\r\n## - Activity Context\r\nActivity Context는 반대로 Activity의 생명주기와 바인딩이 되어있다. 따라서 활동 범위내에서 Context를 넘겨주거나 현재 Context의 생명주기와 연결된 Context가 필요할때 사용된다.\r\n\r\n한 예시로 안드로이드에서 Dialog를 사용한다고 하였을때 이는 activity내에서만 사용이 되는 경우일 것이다. 이 경우 Application Context를 사용하면 불필요한 메모리 누수가 일어날 것이다. 따라서 이경우 __Activity Context__ 를 사용하는 것이 좋을 것이다.\r\n\r\n\r\n > 정리: __어플리케이션내__ 에서 초기화를 해야하거나 __싱글톤__ 객체를 초기화할때는 `Application Context`를 Activity에서 사용되는 UI 컨트롤러 객체(예시: Toast)들은 Activity Context를 사용하는 것을 권장한다.\r\n\r\n- - -\r\n\r\n이제 Context에 대해서 알게되었으니 위의 예시에서의 __applicationContext__, __baseContext__, __application__, __this@액티비티__ 를  나누어 보자!!\r\n\r\n- __Application Context__\r\n    - applicationContext, application: 현재 활성화된 액티비티만이 아닌 Application 전체에 대한 Context가 필요할때 사용.\r\n- __Activity Context__\r\n    - baseContext: 다른 컨텍스트로부터 어떤 컨텍스트에 접근해야하는경우에 ContextWrapper를 쓴다. ContextWrapper 내부에서 참조 된 Context는 baseContext를 통해 액세스된다.\r\n    - this@: View.getContext()와 같으며 현재 실행되고 있는 View의 Context를 return하는데 보통 현재의 Activity의 Context가 된다.\r\n\r\n# Rule of Thumb\r\n대부분의 경우 현재의 스코프에 맞는 Context를 사용하면 된다. 해당 Context 참조가 현재 생명주기에 넘어서지 않는 지만 판단해서 대입하면 된다. Activity, Service를 넘어서 다른 객체에서 Context를 참조해야하는 경우는 Application Context의 사용을 권장한다.\r\n\r\n# References\r\n\r\n - [[번역] 안드로이드 Context(컨텍스트)이해하기](https://velog.io/@l2hyunwoo/Context-In-Android)\r\n - [안드로이드에서 Context란 무엇일까](https://rejrecords.wordpress.com/2015/07/23/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%EC%97%90%EC%84%9C-context%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/)\r\n - [Understanding Context In Android Application](https://blog.mindorks.com/understanding-context-in-android-application-330913e32514)"},{"excerpt":"image 안드로이드 4대 컴포넌트 안드로이드 공부를 시작하면 \"안드로이드 4대 컴포넌트\" 라는 말을 많이 봤을 것이다.  4대 컴포넌트는 안드로이드의 대표적인 구성으로 \"액티비티\", \"브로드캐스트\", \"서비스\", \"콘텐트 제공자\" 가 있다. 이 주요 컴포넌트들은 안드로이드에서 를 사용하여 상호작용 할 수 있다. (안드로이드 Intent) 인텐트를 이용하…","fields":{"slug":"/recyclerview/"},"frontmatter":{"date":"January 17, 2022","title":"안드로이드 4대 컴포넌트란","tags":["Android","Component"]},"rawMarkdownBody":"- - -\r\n![image](https://user-images.githubusercontent.com/63226023/149742986-8d8addf4-938f-4578-88ba-84dba51d3a01.png)\r\n\r\n# 안드로이드 4대 컴포넌트\r\n안드로이드 공부를 시작하면 __\"안드로이드 4대 컴포넌트\"__ 라는 말을 많이 봤을 것이다. \r\n\r\n4대 컴포넌트는 안드로이드의 대표적인 구성으로 __\"액티비티\"__, __\"브로드캐스트\"__, __\"서비스\"__, __\"콘텐트 제공자\"__ 가 있다. 이 주요 컴포넌트들은 안드로이드에서 `Intent`를 사용하여 상호작용 할 수 있다. [(안드로이드 Intent)](https://ppeper.github.io/android/intent/)\r\n\r\n인텐트를 이용하여 상호작용을 하는것 이외에도 다음과 같은 공통적인 특성을 가진다!\r\n\r\n- __하나의 컴포넌트는 독립적인 형태이다.__\r\n- __컴포넌트들은 각각 고유의 기능을 수행한다.__\r\n\r\n- - -\r\n## 1. 액티비티(Activity)\r\n어떠한 어플리케이션을 사용할때 보여지는 화면들이 액티비티이다. 액티비티는 즉 __사용자와 상호작용을 하는 컴포넌트__ 라고 할 수 있다.\r\n\r\n사용자와 상호작용을 한다고 하였으므로 모든 안드로이드 어플은 최소 \"하나의 액티비티\"를 포함한다.\r\n\r\n생명주기에서 알아봤듯이 [(안드로이드 생명주기(Lifecycle))](https://ppeper.github.io/android/lifecycle/) 액티비티는 고유의 Lifecycle을 가지고 각 생명주기 함수를 이용하여 특정한 지점에 내가 원하는 동작을 수행을 할 수 있다. \r\n\r\n- 액티비티는 사용자와 상호작용하는 컴포넌트이다.\r\n- 모든 안드로이드 어플은 최소 하나의 액티비티를 포함한다.\r\n- 고유의 Lifecycle이 존재한다.\r\n- 두 개 이상의 액티비티를 사용자에게 보여줄 수 없다.\r\n\r\n__-> 어플을 사용하다보면 두 개 이상 상호작용하는것을 볼 수 있는데요??__\r\n\r\n안드로이드의 환경이 발전됨에 따라 한 화면에서 많은 정보를 보여줘야 하는 경우가 생김에 따라 프래그먼트(Fragment) 개념이 등장하게 되었다.[(안드로이드 Fragment)](https://ppeper.github.io/android/fragment/)\r\n\r\n안드로이드 3.0(API Level 11)부터는 프래그먼트(Fragment)가 추가되었다. 프래그먼트(Fragment)는 4대 구성요소로 보지는 않지만 한 화면에서 화면 분활 및 동적인 사용자 UI를 동적으로 변경하는데 활용도가 높다. \r\n\r\n- - -\r\n## 2. 브로드캐스트(Broadcast Receiver)\r\n브로드캐스트는 시스템(OS)의 다른 컴포넌트에 시스템 차원의 메시지를 전파하는 방법으로 사용될 수 있다. 이때 사용하는것이 브로드캐스트이다.\r\n\r\n브로드캐스트(Broadcast)는 방송이라는 단어로 뜻에 맞게 생각해보면 쉽게 이해 할 수 있다. 스마트폰의 배터리가없을때나 문자메시지가 오게되면 안드로이드 OS에서 그에 맞는 정보는 __Broadcast(방송)__ 을 해준다고 생각할 수 있다.\r\n\r\n- __Broadcast(방송)__ 을 통해 안드로이드 시스템의 여러 컴포넌트가 알 수 있다.\r\n- 브로드캐스트는 안드로이드 시스템에 의해 사용된다.\r\n\r\n- - -\r\n## 3. 서비스(Service)\r\n서비스는 사용자와 직접 상호작용을 하는 컴포넌트는 아니다. \r\n\r\n안드로이드 Service는 앱이 __백그라운드 작업__ 을 시작시켜 수행할 수 있게 설계되어있는 컴포넌트이다.(예를 들어, 인터넷 연결을 통해 파일을 다운로드하거나 사용자에게 음악을 스트리밍 서비스한다.)\r\n\r\n서비스는 백그라운드에서 작업을 처리한다고 하였기 때문에 별도의 스레드에서 실행된다고 오해할수 있다. 하지만 서비스는 기본적으로 자신이 시작된 컴포넌트와 같은 __메인 스레드__ 에서 실행이 되기 때문에 CPU를 많이 사용하는 작업을 서비스가 실행을 해야한다면 새로운 스레드에서 수행되어야 한다.\r\n\r\n- __백그라운드__ 에서 작업을 하는 컴포넌트이다.\r\n- 서비스는 시작된 컴포넌트와 같은 __메인 스레드__ 에서 실행된다.\r\n\r\n- - -\r\n## 4. 콘텐트 제공자(Content provider)\r\n콘텐츠 제공자는 애플리케이션이 자체적으로 __저장된 데이터, 다른 앱이 저장한 데이터에 대한 액세스 권한을 관리__ 하도록 돕고 다른 앱과 데이터를 공유할 방법을 제공한다.\r\n\r\n즉 콘텐트 제공자를 통하여 다른 어플리케이션이 앱 데이터를 __안전하게__ 액세스를 하여 사용할 수 있다.\r\n\r\n- 데이터의 안전한 액세스를 할 수 있게 제공.\r\n\r\n\r\n\r\n"},{"excerpt":"문제 설명 카카오에 신입 개발자로 입사한 \"콘\"은 선배 개발자로부터 개발역량 강화를 위해 다른 개발자가 작성한 소스 코드를 분석하여 문제점을 발견하고 수정하라는 업무 과제를 받았습니다. 소스를 컴파일하여 로그를 보니 대부분 소스 코드 내 작성된 괄호가 개수는 맞지만 짝이 맞지 않은 형태로 작성되어 오류가 나는 것을 알게 되었습니다.\n수정해야 할 소스 파일…","fields":{"slug":"/programmers-kakao-blind-2020-1/"},"frontmatter":{"date":"January 16, 2022","title":"프로그래머스 2020 KAKAO BLIND RECRUITMENT - 괄호 변환","tags":["Algorithm","programmers"]},"rawMarkdownBody":"\r\n### 문제 설명\r\n\r\n카카오에 신입 개발자로 입사한 \"콘\"은 선배 개발자로부터 개발역량 강화를 위해 다른 개발자가 작성한 소스 코드를 분석하여 문제점을 발견하고 수정하라는 업무 과제를 받았습니다. 소스를 컴파일하여 로그를 보니 대부분 소스 코드 내 작성된 괄호가 개수는 맞지만 짝이 맞지 않은 형태로 작성되어 오류가 나는 것을 알게 되었습니다.\r\n수정해야 할 소스 파일이 너무 많아서 고민하던 \"콘\"은 소스 코드에 작성된 모든 괄호를 뽑아서 올바른 순서대로 배치된 괄호 문자열을 알려주는 프로그램을 다음과 같이 개발하려고 합니다.\r\n\r\n### 용어의 정리\r\n\r\n`'('` 와 `')'` 로만 이루어진 문자열이 있을 경우, `'('` 의 개수와 `')'` 의 개수가 같다면 이를 균형잡힌 괄호 문자열이라고 부릅니다.\r\n그리고 여기에 `'('`와 `')'`의 괄호의 짝도 모두 맞을 경우에는 이를 올바른 괄호 문자열이라고 부릅니다.\r\n예를 들어, `\"(()))(\"`와 같은 문자열은 \"균형잡힌 괄호 문자열\" 이지만 \"올바른 괄호 문자열\"은 아닙니다.\r\n반면에 `\"(())()\"`와 같은 문자열은 \"균형잡힌 괄호 문자열\" 이면서 동시에 \"올바른 괄호 문자열\" 입니다.\r\n\r\n`'('` 와 `')'` 로만 이루어진 문자열 w가 \"균형잡힌 괄호 문자열\" 이라면 다음과 같은 과정을 통해 \"올바른 괄호 문자열\"로 변환할 수 있습니다.\r\n\r\n```\r\n1. 입력이 빈 문자열인 경우, 빈 문자열을 반환합니다. \r\n2. 문자열 w를 두 \"균형잡힌 괄호 문자열\" u, v로 분리합니다. 단, u는 \"균형잡힌 괄호 문자열\"로 더 이상 분리할 수 없어야 하며, v는 빈 문자열이 될 수 있습니다. \r\n3. 문자열 u가 \"올바른 괄호 문자열\" 이라면 문자열 v에 대해 1단계부터 다시 수행합니다. \r\n  3-1. 수행한 결과 문자열을 u에 이어 붙인 후 반환합니다. \r\n4. 문자열 u가 \"올바른 괄호 문자열\"이 아니라면 아래 과정을 수행합니다. \r\n  4-1. 빈 문자열에 첫 번째 문자로 '('를 붙입니다. \r\n  4-2. 문자열 v에 대해 1단계부터 재귀적으로 수행한 결과 문자열을 이어 붙입니다. \r\n  4-3. ')'를 다시 붙입니다. \r\n  4-4. u의 첫 번째와 마지막 문자를 제거하고, 나머지 문자열의 괄호 방향을 뒤집어서 뒤에 붙입니다. \r\n  4-5. 생성된 문자열을 반환합니다.\r\n```\r\n\r\n__\"균형잡힌 괄호 문자열\"__ p가 매개변수로 주어질 때, 주어진 알고리즘을 수행해 `\"올바른 괄호 문자열\"`로 변환한 결과를 return 하도록 solution 함수를 완성해 주세요.\r\n\r\n### 매개변수 설명\r\n* p는 `'('` 와 `')'` 로만 이루어진 문자열이며 길이는 2 이상 1,000 이하인 짝수입니다.\r\n* 문자열 p를 이루는 `'('` 와 `')'` 의 개수는 항상 같습니다.\r\n* 만약 p가 이미 \"올바른 괄호 문자열\"이라면 그대로 return 하면 됩니다.\r\n\r\n### 입출력 예\r\n\r\n|     p      |   result   |\r\n| :--------- | :--------- | \r\n| \"(()())()\" | \"(()())()\" |\r\n|    \")(\"    |\t   \"()\"   |\r\n| \"()))((()\" | \"()(())()\" |\r\n\r\n### 풀이\r\n처음 문제를 보았을때 문제가 길어서 이해하는데가 오래 걸렸다. 문제의 핵심은 -> 결국 괄호의 짝은 다 맞지만 __\"올바른 괄호 문자열\"__ 을 리턴하는 것과 용어의 정리에서 `재귀` 쓰라고 문제에 적혀있는 대로만 작성하면 된다고 생각하여 차근차근 풀어 나갔다.\r\n\r\n* 크게 두가지로 나누어 접근하였다.\r\n\r\n1. \"올바른 괄호인지 확인\"\r\n\r\n```java\r\n    private boolean isParenthesis(String p) {\r\n        if (p.charAt(0) == ')') {\r\n            return false;\r\n        } else {\r\n            Stack<Character> stack = new Stack<Character>();\r\n            for (char ch: p.toCharArray()) {\r\n                if (ch == '(') {\r\n                    stack.push(ch);\r\n                } else {\r\n                    if (stack.isEmpty()) {\r\n                        return false;\r\n                    }\r\n                    stack.pop();\r\n                }\r\n            }\r\n            return stack.isEmpty();\r\n        }\r\n    }\r\n```\r\n많은 알고리즘 문제에서 나오는 `괄호` 문제에서 스택을 이용하여 확인하였다.\r\n\r\n2. 용어의 정리에서 주어진 1 ~ 4까지 작성\r\n\r\n```java\r\n // 균형잡힌 괄호 문자열 split\r\n    private String split(String p) {\r\n        if (p.equals(\"\")) {\r\n            return p;\r\n        }\r\n        int start = 0, end = 0, index = 0;\r\n        // 문자열 u, v로 나누기 index\r\n        for (int i = 0; i < p.length(); i++) {\r\n            if (p.charAt(i) == '(') {\r\n                start++;\r\n            } else {\r\n                end++;\r\n            }\r\n            if (start == end) {\r\n                index = i;\r\n                break;\r\n            }\r\n        }\r\n        StringBuilder u = new StringBuilder(p.substring(0, index + 1));\r\n        StringBuilder v = new StringBuilder(p.substring(index + 1));\r\n```\r\n문제에서 나온 문자열 u, v로 나누기위해 변수 두개를 설정하여 열린괄호와 닫힌괄호의 개수가 같은 -> \"균형잡힌 괄호 문자열\"로 나누어서 두 변수 설정하였다.\r\n\r\n```java\r\n // 3 : 올바른 괄호 확인 -> 올바르면 올바른 문자열(u)에 v를 1단계부터 다시하여 붙임\r\n        if (isParenthesis(u.toString())) {\r\n            u.append(split(v.toString()));\r\n        } else { // 4 : 올바른 괄호 x -> 빈 문자열에 '(' 에 문자열 v에 대해 1단계부터 다시하여 붙이고 ')'를 다시 붙임\r\n            // 4-1, 4-2, 4-3\r\n            StringBuilder sb = new StringBuilder(\"(\" + split(v.toString()) + \")\");\r\n            // 4-4 첫번째와 마지막 분자 제거후 나머지 문자열 괄호 방향 바꿈\r\n            u.deleteCharAt(u.length() - 1);\r\n            u.deleteCharAt(0);\r\n            u = new StringBuilder(reverse(u.toString()));\r\n            return sb.append(u.toString()).toString();\r\n        }\r\n        return u.toString();\r\n    }\r\n```\r\n3 ~ 4번에서 주어진 문제대로 `\"올바른 문자열\"`과 아닌것을 구분하여 작성하였다. 괄호 방향의 바꿈은 `reverse`함수를 작성하였다.\r\n\r\n```java\r\n    private String reverse(String p) {\r\n        StringBuilder sb = new StringBuilder();\r\n        for (String s : p.split(\"\")) {\r\n            if (s.equals(\")\")) {\r\n                sb.append(\"(\");\r\n            } else if (s.equals(\"(\")){\r\n                sb.append(\")\");\r\n            }\r\n        }\r\n        return sb.toString();\r\n    }\r\n```\r\n\r\n__전체 코드__\r\n```java\r\nimport java.util.Stack;\r\n\r\nclass Parenthesis {\r\n    public String solution(String p) {\r\n        StringBuilder sb = new StringBuilder();\r\n        // p가 빈문자열이면 빈문자열 , 올바은 괄호면 올바른 괄호 리턴\r\n        if (p.equals(\"\") || isParenthesis(p)) {\r\n            return p;\r\n        } else {\r\n            sb.append(split(p));\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    // 균형잡힌 괄호 문자열 split\r\n    private String split(String p) {\r\n        if (p.equals(\"\")) {\r\n            return p;\r\n        }\r\n        int start = 0, end = 0, index = 0;\r\n        // 문자열 u, v로 나누기 index\r\n        for (int i = 0; i < p.length(); i++) {\r\n            if (p.charAt(i) == '(') {\r\n                start++;\r\n            } else {\r\n                end++;\r\n            }\r\n            if (start == end) {\r\n                index = i;\r\n                break;\r\n            }\r\n        }\r\n        StringBuilder u = new StringBuilder(p.substring(0, index + 1));\r\n        StringBuilder v = new StringBuilder(p.substring(index + 1));\r\n\r\n        // 3 : 올바른 괄호 확인 -> 올바르면 올바른 문자열(u)에 v를 1단계부터 다시하여 붙임\r\n        if (isParenthesis(u.toString())) {\r\n            u.append(split(v.toString()));\r\n        } else { // 4 : 올바른 괄호 x -> 빈 문자열에 '(' 에 문자열 v에 대해 1단계부터 다시하여 붙이고 ')'를 다시 붙임\r\n            // 4-1, 4-2, 4-3\r\n            StringBuilder sb = new StringBuilder(\"(\" + split(v.toString()) + \")\");\r\n            // 4-4 첫번째와 마지막 분자 제거후 나머지 문자열 괄호 방향 바꿈\r\n            u.deleteCharAt(u.length() - 1);\r\n            u.deleteCharAt(0);\r\n            u = new StringBuilder(reverse(u.toString()));\r\n            return sb.append(u.toString()).toString();\r\n        }\r\n        return u.toString();\r\n    }\r\n\r\n    private boolean isParenthesis(String p) {\r\n        if (p.charAt(0) == ')') {\r\n            return false;\r\n        } else {\r\n            Stack<Character> stack = new Stack<Character>();\r\n            for (char ch: p.toCharArray()) {\r\n                if (ch == '(') {\r\n                    stack.push(ch);\r\n                } else {\r\n                    if (stack.isEmpty()) {\r\n                        return false;\r\n                    }\r\n                    stack.pop();\r\n                }\r\n            }\r\n            return stack.isEmpty();\r\n        }\r\n    }\r\n\r\n    private String reverse(String p) {\r\n        StringBuilder sb = new StringBuilder();\r\n        for (String s : p.split(\"\")) {\r\n            if (s.equals(\")\")) {\r\n                sb.append(\"(\");\r\n            } else if (s.equals(\"(\")){\r\n                sb.append(\")\");\r\n            }\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n\r\n```\r\n"},{"excerpt":"Intent?? 인텐트는 하나의 액티비티가 다른 액티비티를 시작할 수 있는 메시징 시스템이며, 이때  클래스 인스턴스를 사용한다. 액티비티가 안드로이드 런타임에 인텐트를 요청하면 해당 인텐트에 부합되는 액티비티를 안드로이드 런타임이 찾아서 시작한다. Intent 유형 인텐트의 유형에는  인텐트와  인텐트가 있다. 명시적 인텐트 : 클래스 이름으로 액티비티…","fields":{"slug":"/intent/"},"frontmatter":{"date":"January 09, 2022","title":"안드로이드 인텐트의 개념","tags":["Android","Intent"]},"rawMarkdownBody":"- - -\r\n# Intent??\r\n인텐트는 하나의 액티비티가 다른 액티비티를 시작할 수 있는 메시징 시스템이며, 이때 `android.content.Intent` 클래스 인스턴스를 사용한다. 액티비티가 안드로이드 런타임에 인텐트를 요청하면 해당 인텐트에 부합되는 액티비티를 안드로이드 런타임이 찾아서 시작한다.\r\n\r\n# Intent 유형\r\n인텐트의 유형에는 `명시적` 인텐트와 `암시적` 인텐트가 있다.\r\n- __명시적 인텐트__ : 클래스 이름으로 액티비티를 참조하여 특정 액티비티의 시작을 안드로이드 런타임에 요청한다.\r\n- __암시적 인텐트__ : 우리가 하기를 원하는 작업(액션 타입)을 안드로이드 런타임에 알려준다. 그러면 그런 작업을 할 수 있다고 자신을 등록한 액티비티를 안드로이드 런타임이 찾아서 시작한다.(이것을 `인텐트 레졸루션`이라고 한다). 하나 이상 찾을 경우는 사용자가 선택할 수 있게 해준다.\r\n\r\n## 명시적 인텐트\r\n명시적 인텐트는 수신하는 액티비티의 __컴포넌트 이름__(실제로는 클래스 이름)을 참조하여 특정 액티비티의 시작을 요청할 때 사용된다.\r\n\r\n명시적 인텐트는 Intent 클래스의 새로운 인스턴스를 생성하여 요청한다. 그 이후 인텐트 객체를 `startActivity()`함수를 호출하여 사용한다.\r\n\r\n```kotlin\r\nval intent = Intent(this, ActivityB::class.java)\r\nstartActivity(intent)\r\n```\r\n\r\nstartActivity() 함수를 호출하기 이전에 인텐트에 데이터를 추가 할 수 있다. 이때 인텐트 객체의 `putExtra()` 함수를 호출한다. 데이터는 Bundle 형태로 `키-값` 형태의 쌍으로 된 것이어야 한다.\r\n\r\n```kotlin\r\nval intent = Intent(this, ActivityB::class.java)\r\nintent.putExtra(\"myString\", \"This is a message for ActivityB\")\r\nintent.putExtra(\"myInt\", 100)\r\nstartActivity(intent)\r\n```\r\n\r\n수신 액티비티에서는 Bundle 객체로 데이터를 받는다. 이 객체는 `getIntent().getExtras()`를 호출하여 얻을 수 있다. Activity 클래스의 `getIntent()` 함수는 수신 액티비티를 시작했던 객체를 반환한다. 그리고 Intent 클래스의 `getExtras()` 함수는 데이터를 포함하는 해당 인텐트의 Bundle 객체를 반환한다.\r\n\r\n```kotlin\r\nval extras = intent.extras ?: return\r\n\r\nval myString = extras.getString(\"myString\")\r\nval myInt = extras.getInt(\"myInt\")\r\n```\r\n\r\n인텐트를 사용해서 같은 앱에 있는 다른 액티비티를 시작을 할때는 해당 액티비티가 앱의 manifest 파일에 정의 되어있어야한다. \r\n\r\n`AndroidManifest.xml`\r\n```xml\r\n.\r\n.\r\n<activity\r\n    android:name=\"ActivityB\"\r\n    android:label=\"ActivityB\" >\r\n</activity>\r\n```\r\n## 암시적 인텐트\r\n암시적 인텐트는 수행될 액션과 수신 액티비티에 의해 처리되는 데이터 타입을 지정하여 시작될 액티비티를 식별한다. \r\n\r\n예를 들어, URI 객체 형태로 웹 페이지의 URL을 동반하는 __ACTION_VIEW__ 액션 타입은 웹 브라우저의 능력을 갖는 액티비티를 찾아서 시작시키라고 안드로이드 시스템에 요청한다.\r\n\r\n```kotlin\r\nval intent = Intent(Intent.ACTION_VIEW,\r\n        URi.parse(\"https://www.ebookfrenzy.com\"))\r\nstartActivity(intent)\r\n```\r\n이 코드ㄴ의 `암시적 인텐트`가 액티비티에 요청되면 장치의 안드로이드 시스템에서 http 데이터의 __ACTION_VIEW__ 요청을 처리할 능력이 있다고 등록된 액티비티를 검색한다. \r\n\r\n- 일치하는 액티비티가 하나만 발견 -> 해당 액티비티 실행\r\n- 두 개 이상 발견 -> 사용자가 액티비티를 선택하게 해준다\r\n\r\n    > 이것을 __인텐트  레졸루션__ 이라고 한다.\r\n\r\n- - -\r\n\r\n## 인텐트 필터 사용하기\r\n액티비티가 자신이 지원하는 액션과 데이터 처리 능력을 안드로이드 인텐트 레졸루션  프로세스에 알리는 메커니즘이 __인텐트 필터__ 이다.\r\n\r\n위의 예시에서 요청된 인텐트에 의해 액티비티가 실행되려면 __ACTION_VIEW__ 타입의 지원을 나타내는 인텐트 필터를 `AndroidManifest.xml`에 포함해야한다. 이때 http 형식의 데이터, 즉 웹 페이지를 보여 줄 수 있다는 것도 같이 지정한다.\r\n\r\n또한 MainActivity가 암시적 인텐트로 시작될 수 있도록 인텐트 필터도 추가되어 있어야 한다.\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    package=\"com.kyonggi.explicitintent\">\r\n\r\n    <uses-permission android:name=\"android.permission.INTERNET\" />\r\n\r\n    <application\r\n        android:allowBackup=\"true\"\r\n        android:icon=\"@mipmap/ic_launcher\"\r\n        android:label=\"@string/app_name\"\r\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\r\n        android:supportsRtl=\"true\"\r\n        android:theme=\"@style/Theme.ExplicitIntent\">\r\n        <activity\r\n            android:name=\".ActivityB\"\r\n            android:exported=\"false\" />\r\n        <activity\r\n            android:name=\".MainActivity\"\r\n            android:exported=\"true\">\r\n            <intent-filter>\r\n                <action android:name=\"android.intent.action.VIEW\" />\r\n\r\n                <category android:name=\"android.intent.category.DEFAULT\" />\r\n                <data android:scheme=\"http\" />\r\n            </intent-filter>\r\n        </activity>\r\n    </application>\r\n\r\n</manifest>\r\n```\r\n\r\n# References\r\n- [안드로이드 인텐트 및 인텐트 필터](\"https://developer.android.com/guide/components/intents-filters?hl=ko#kotlin\")\r\n\r\n\r\n"},{"excerpt":"프래그먼트란? 프래그먼트는 대표적으로 큰 화면은 가진 태블릿과 같은 기기에서 보다 역동적이고 유연한 UI 디자인을 지원하는 것이 목적이다.  image 이러한 큰화면에서 하나의 액티비티를 통한 레이아웃을 구성하기엔 구현하기도 버겁고 유지보수에도 좋지 않을것이다. 이러한 버거움을 해결하고자 나온것이 프래그먼트이다. 프래그먼트는 액티비티 내부에서 독립적으로 …","fields":{"slug":"/fragment/"},"frontmatter":{"date":"January 03, 2022","title":"안드로이드 Fragment 사용","tags":["Android","Fragment"]},"rawMarkdownBody":"- - -\r\n# 프래그먼트란?\r\n프래그먼트는 대표적으로 큰 화면은 가진 태블릿과 같은 기기에서 보다 역동적이고 유연한 UI 디자인을 지원하는 것이 목적이다. \r\n\r\n![image](https://user-images.githubusercontent.com/63226023/147904530-ac4f95b4-3ef3-4b52-a23d-c5ba3ae59414.png)\r\n\r\n이러한 큰화면에서 하나의 액티비티를 통한 레이아웃을 구성하기엔 구현하기도 버겁고 유지보수에도 좋지 않을것이다. 이러한 버거움을 해결하고자 나온것이 프래그먼트이다.\r\n\r\n프래그먼트는 액티비티 내부에서 독립적으로 앱의 UI(사용자 인터페이스)를 처리한다. 그리고 앱이 실행되는 런타임 시에는 UI를 동적으로 변경하기 위해 프래그먼트를 액티비티에 추가하거나 제거할 수 있다.\r\n\r\n프래그먼트는 액티비티의 일부로만 사용될 수 있고, 혼자서 독립적으로 실행되는 앱 요소로는 생성될 수 없다.(다른 액티비티에 재사용할 수 있는 \"하위 액티비티\"와 같은 개념)\r\n\r\n## 프래그먼트 사용법\r\n프래그먼트를 사용하기 위해서는 다음과 같은 방법이 사용된다.\r\n1. `onCreateView()` 사용\r\n2. 액티비티에 프래그먼트 추가\r\n3. 프래그먼트 관리\r\n\r\n### 1. `onCreateView()` 사용\r\n프래그먼트 클래스에서 레이아웃을 로드하기 위해서 사용해야한다. \r\n```kotlin\r\nclass FragmentOne : Fragment() {\r\n    \r\n    private var _binding: FragmentExampleBinding? = null\r\n    private val binding get() = _binding!!\r\n\r\n    override fun onCreateView(\r\n        inflater: LayoutInflater, container: ViewGroup?,\r\n        savedInstanceState: Bundle?\r\n    ): View? {\r\n        // Inflate the layout for this fragment\r\n        // return inflater.inflate(R.layout.example_fragment, container, false)\r\n        _binding = FragmentExampleBinding.inflate(inflater, container, false)\r\n        return binding.root\r\n    }\r\n}\r\n```\r\n`onCreateView()`를 사용하여 레이아웃을 사용할 준비를 합니다.\r\n\r\n- 예시에서 두개의 프래그먼트는 `FragmentTextBinding`, `FragmentToolbarBinding`을 사용.\r\n\r\n### 2. 액티비티에 프래그먼트 추가\r\n예시) `fragment_toolbar.xml`과 `fragment_text.xml`을 액티비티에 추가한다. \r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    tools:context=\".MainActivity\">\r\n\r\n    <androidx.fragment.app.FragmentContainerView\r\n        android:id=\"@+id/fragmentContainerView\"\r\n        android:name=\"com.kyonggi.fragmentexample.ToolbarFragment\"\r\n        android:layout_width=\"0dp\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:layout_marginTop=\"16dp\"\r\n        app:layout_constraintEnd_toEndOf=\"parent\"\r\n        app:layout_constraintStart_toStartOf=\"parent\"\r\n        app:layout_constraintTop_toTopOf=\"parent\"\r\n        tools:layout=\"@layout/fragment_toolbar\" />\r\n\r\n    <androidx.fragment.app.FragmentContainerView\r\n        android:id=\"@+id/text_fragment\"\r\n        android:name=\"com.kyonggi.fragmentexample.TextFragment\"\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:layout_marginTop=\"88dp\"\r\n        app:layout_constraintEnd_toEndOf=\"parent\"\r\n        app:layout_constraintStart_toStartOf=\"parent\"\r\n        app:layout_constraintTop_toBottomOf=\"@+id/fragmentContainerView\"\r\n        tools:layout=\"@layout/fragment_text\" />\r\n\r\n</androidx.constraintlayout.widget.ConstraintLayout>\r\n```\r\n![image](https://user-images.githubusercontent.com/63226023/147905875-efb89ff4-9a3f-4143-bb9a-2991c7668f7c.png)\r\n\r\n### 3. 프래그먼트 관리\r\n액티비티 내에서 프래그먼트 트랜잭션(예: 프래그먼트의 추가, 제거, 교체)을 수행하기 위해서는 `FragmentTransaction`에서 가져온 API를 사용해야한다.\r\n\r\n```kotlin\r\nval fragmentManager = supportFragmentManager\r\nval fragmentTransaction = fragmentManager.beginTransaction()\r\n```\r\n\r\n트랜잭션을 할 준비가 되었다면 `add()` 메서더를 사용하여 프래그먼트와 이를 삽입할 뷰를 지정한다.\r\n\r\n`FragmentTransaction`을 변경하고나서 적용을 하기위해서는 `commit()`을 호출해야한다.\r\n\r\n```kotlin\r\nval fragment = ExampleFragment()\r\nfragmentTransaction.add(R.id.fragment_container, fragment)\r\nfragmentTransaction.commit()\r\n```\r\n---\r\n[seekBar를 통하여 폰트크기 변경하는 프래그먼트 예시](https://github.com/ppeper/Android_Arctic-Fox/tree/main/FragmentExample)\r\n\r\n# References\r\n- [안드로이드 Fragment](https://developer.android.com/guide/components/fragments)\r\n\r\n\r\n\r\n\r\n\r\n"},{"excerpt":"안드로이드 Lifecycle? 안드로이드를 처음 공부를 하였을때 가장 놀랐던것이 앱이 회전이 되었을때도 앱을 다시 처음부터 그려준다는것이였다. 사용자들이 어플을 쓰게되면 한 화면에서 여러가지 이벤트가 발생할 수 있다(ex. 사용자가 정보를 입력, 게임을 하던도중 전화가 옴..) 정보를 입력하다가 화면이 회전되었음 -> 많은 정보가 사라진다면? 게임을 하던…","fields":{"slug":"/lifecycle/"},"frontmatter":{"date":"January 01, 2022","title":"안드로이드 Lifecycle 제대로 알기","tags":["Android","Lifecycle"]},"rawMarkdownBody":"- - -\r\n# 안드로이드 Lifecycle?\r\n안드로이드를 처음 공부를 하였을때 가장 놀랐던것이 앱이 회전이 되었을때도 앱을 다시 처음부터 그려준다는것이였다.\r\n\r\n사용자들이 어플을 쓰게되면 한 화면에서 여러가지 이벤트가 발생할 수 있다(ex. 사용자가 정보를 입력, 게임을 하던도중 전화가 옴..)\r\n\r\n1. 정보를 입력하다가 화면이 회전되었음 -> 많은 정보가 사라진다면?\r\n2. 게임을 하던도중 전화를 받고옴 -> 게임이 처음부터 다시시작..(ㅂㄷ)\r\n\r\n이러한 문제를 해결하기위해 안드로이드에서는 Lifecycle이 존재하여 Activity의 상태를 저장하고나 복원할 수 있도록 한다.\r\n\r\n> 근래에는 `Jetpack` 안드로이드 아키텍처 컴포넌트로 생명주기 클래스가 도입이 되면서 생명주기를 처리하는 더 좋은 방법을 사용할 수 있게 되었다.\r\n\r\n---\r\n## 안드로이드 Lifecycle 함수\r\n\r\n이러한 Activity의 상태변화가 일어났을때 특정 동작을 수행할 수 있는 여러 `Callback Method`를 안드로이드 프레임워크에서 제공한다. \r\n\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/147640585-d55f8bbc-a22c-4557-aa53-630b64c356a0.png\"> -> Activity에서의 한 lifecycle을 보여주는 그림\r\n\r\n### onCreate(savedInstanceState: Bundle?)\r\n - 이 함수는 액티비티 인스턴스가 최초 생성될 때 호출되며, 대부분의 초기화 작업을 하는 데 이상적인 곳이다.\r\n\r\n### onRestart()\r\n - 액티비티가 런타임 시스템에 의해 이전에 중단되었다가 바로 다시 시작될 때 호출된다.\r\n\r\n### onStart()\r\n- `onCreate()`나 `onRestart()` 함수가 호출된 후 곧바로 호출된다. 그리고 사용자가 곧 보게 된다고 액티비티에서 알려준다. 만일 액티비티가 액티비티 `스택`의 맨 위로 이동하면 이함수가 호출된 다음에 `onResume()`이 호출된다\r\n\r\n### onResume()\r\n- 액티비티가 액티비티 `스택`의 맨 위에 있으며, 사용자와 현재 상호작용하는 액티비티임을 나타낸다.\r\n\r\n### onPause()\r\n- 이 함수 호출 다음에는 `onResume()` 또는 `onStop()` 함수 중 하나가 호출된다. 즉 액티비티가 포그라운드로 돌아가는 경우 (계속 실행하기 위해) `onResume()`이 호출되며, (액티비티의 사용자 인터페이스를) 사용자가 볼 수 없게 되면 중단되면서 `onStop()`이 호출된다.\r\n\r\n - 이 함수 내부에서는 앱에서 아직 저장하지 않은 데이터를 저장하는 작업을 하면 된다. 단, `onPause()`는 아주 잠깐 실행되므로 저장 작업을 실행하기에는 시간이 부족할 수 있어 애플리케이션 또는 사용자데이터를 저장하거나, 네트워크 호출을 하거나, 데이터베이스 트랜잭션을 싱행해서는 `안 된다` -> 그 대신, 부하가 큰 종료 작업은 `onStop()` 상태일 때 실행해야 한다.\r\n\r\n### onStop()\r\n- 이 함수가 호출될 때는 액티비티가 더 이상 사용자에게 보이지 않는다. 이 함수 호출 다음에는 `onRestart()` 또는 `onDestroy()`가 호출된다. `onStop()` 메서드에서는 앱이 사용자에게 보이지 않는 동안 앱은 필요하지 않은 리소스를 해제하거나 조정해야 한다.\r\n\r\n- 또한 `onStop()`을 사용하여 CPU를 비교적 많이 소모하는 종료 작업을 실행해야 한다. 예를 들어 정보를 데이터베이스에 저장할 적절한 시기를 찾지 못했다면 `onStop()` 상태일 때 저장할 수 있다.\r\n\r\n### onDestroy()\r\n- 이 함수는 다음과 같은 이유로 액티비티가 곧 소멸될 때 호출된다.\r\n\r\n1. 액티비티가 자신의 작업을 완료하고 `finish()` 함수를 호출했을 경우.\r\n2. 메모리가 부족하거나 구성변경(예: 장치의 기기 회전 또는 멀티 윈도우 모드)으로 인해 시스템이 일시적으로 활동을 소멸시키는 경우.\r\n\r\n---\r\n\r\n# Fragment에서의 Lifecycle\r\n지금까지는 안드로이드 Activity의 생명주기를 보았다.\r\n\r\nFragment에서의 생명주기 함수는 다음이 추가된다.\r\n\r\n![image](https://user-images.githubusercontent.com/63226023/147833664-4d80ade8-c6e5-4b8f-a9c3-a2af081246f2.png)\r\n\r\n## onAttach()\r\n- 프래그먼트가 액티비티에 지정될 때 호출된다.\r\n\r\n- 프래그먼트가 완벽하게 생성된 상태는 아니다.\r\n\r\n## onCreateView()\r\n- 프래그먼트의 사용자 인터페이스 레이아웃 뷰 계층을 생성하고 반환하기 위해 호출된다.\r\n\r\n## onActivityCreated()\r\n- 프래그먼트와 연관된 액티비티의 `onCreate()` 함수가 실행 완료되면 호출된다.\r\n\r\n## onViewStatusRestored()\r\n- 프래그먼트의 저장된 뷰 계층이 복원될 때 호출된다.\r\n\r\n---\r\n# 동적 상태를 저장하고 복원\r\n지금까지 이야기한 생명주기 함수와 더불어 액티비티의 동적 상태를 저장하고 복원허가 위하여 만들어진 두 개의 함수가 있다. \r\n\r\n## onRestoreInstanceState(savedInstanceState: Bundle?)\r\n- 상태 정보가 저장되었던 이전 액티비티 인스턴스로부터 다시 생성되어 시작될때 `onStart()` 함수가 호출된 후 곧바로 이 함수가 호출된다.\r\n\r\n- `onCreate()`, `onStart()`에서 액티비티의 초기화가 수행된 후에 이전 상태 데이터를 복원해야 할 때 이함수가 호출된다.\r\n\r\n## onSaveInstanceState(outState: Bundle?)\r\n- 현재의 동적 상태 데이터가 저장될 수 있도록 액티비티가 소멸되기 전에 호출된다. \r\n\r\n- 이 Bundle 객체는 이후에 액티비티가 다시 시작될 때 `onCreate()`와 `onRestoredInstanceState()` 함수에 전달된다.                                 \r\n\r\n> 동적 상태 데이터가 저장될 필요가 있다고 런타임이 판단할 경우에만 이 함수가 호출!\r\n\r\n> 이 함수에서는 우리가 보존할 필요가 있는 동적 데이터를 Bundle 객체에 저장하면 된다.\r\n\r\n---\r\n# Bundle 클래스?\r\n`onCreate()`, `onRestoredInstanceState()`의 변수에 들어있는 Bundle 클래스는 데이터를 저장하는 역할을 하고 저장된 데이터를 복원한다고 위에서 설명하였다. -> Bundle??\r\n\r\nBundle 클래스는 `키-값 쌍`(Map)으로 구성되는 데이터를 저장하는 역할을 한다. 키는 문자열의 값이며, 키와 연관된 값은 기본형 데이터 값이거나 또는 안드로이드 Parcelable 인터페이스를 구현하는 어떤 객체도 될 수 있다.\r\n\r\n- Bundle 클래스의 키값은 Parcelable, Serializable, 기본형(Byte, Short, Long, Float, Double, Char, Boolean)등 포함되어 사용.\r\n\r\n---\r\n\r\n\r\n# References\r\n- [안드로이드 Activity 생명주기](https://developer.android.com/guide/components/activities/activity-lifecycle?hl=ko#kotlin)\r\n- [안드로이드 Fragment](https://developer.android.com/guide/components/fragments)\r\n\r\n"},{"excerpt":"지난 안드로이드에 대한 회고 처음 안드로이드 공부를 시작을 한것은 7월 여름방학이였다. 1학기가 끝나가는 6월달 말에 동기를 통하여 공개SW 개발자대회라는 좋은 기회가 있다는 소식을 들었다. 평소에 어느정도 개념을 알고 진행되는 프로젝트만 했기 때문에 처음부터 끝까지 한번도 경험하지못한 안드로이드라는 모바일 플랫폼쪽을 공부를 하며  개발한다는것에 대한 해…","fields":{"slug":"/android-start/"},"frontmatter":{"date":"December 28, 2021","title":"첫 안드로이드 개발에 대한 회고","tags":["Android","Blog"]},"rawMarkdownBody":"- - -\r\n\r\n# __지난 안드로이드에 대한 회고__\r\n\r\n처음 안드로이드 공부를 시작을 한것은 7월 여름방학이였다. 1학기가 끝나가는 6월달 말에 동기를 통하여 [공개SW 개발자대회](https://www.oss.kr/dev_competition)라는 좋은 기회가 있다는 소식을 들었다. 평소에 어느정도 개념을 알고 진행되는 프로젝트만 했기 때문에 처음부터 끝까지 한번도 경험하지못한 안드로이드라는 모바일 플랫폼쪽을 공부를 하며  개발한다는것에 대한 해보지 않았던 두려움(?)과 출품을 등록해야하는 시기까지 완성을 못하면 생기는 팀원들에게 민폐가 될 수 있는 점들이 무섭게 다가왔지만 두려움을 깨지 못하면 내 자신이 발전될 수 없기 때문에 팀원들과 참가하기로 결정하였다.\r\n\r\n## 안드로이드 시작\r\n\r\n7월 부터 진행되었던 공개SW 개발자대회의 첫 출품은 9월 첫째주였다. 기한에 맞추어 프로젝트를 제출하기 위하여 진행한 방향에 대해서 정리해보았다.\r\n\r\n- 안드로이드 책을 통하여 개념을 습득한다.\r\n- 안드로이드 공식 사이트를 통한다.\r\n- 구글을 통하여 내용을 찾아본다.\r\n\r\n평소에 공부도 이러한 방향으로 진행하였지만 이번만큼은 정해진 기한안에 우리가 목표했던 어플을 만들어야 하였기 때문에 처음에는 막막하였다. 이번 공개SW 개발자대회를 통하여 팀원들과 프로젝트가 진행됨에 따라 내 스스로 관심있게 찾아보고 공부를 하는것에 대한 재미도 찾게되고 해보지 못한것에 대한 도전의 두려움을 없애주는 좋은 경험이였다.\r\n\r\n## 마무리\r\n\r\n7월부터 11월초 까지 4개월동안 성공적으로 프로젝트를 마무리하고 안드로이드에 대한 많은 개념들을 알게되었다. 하지만 프로젝트의 마감기한의 맞춰서 개발을 하고, 평소 공부를 하던 방향과 다르게 하다보니 찾아봤던것들에 대한 정확하게 알지 못하는 것이 생기게 되었다.\r\n\r\n---\r\n\r\n# __안드로이드 개념 정리__\r\n\r\n프로젝트를 마무리하고 안드로이드에 대한 공부방향(?), 전체적인 로드맵이 그려졌지만 그 전에 이러한 생각이 없이 공부를 하게 되어 제대로 개념 정리가 필요할것 같다고 생각이 들었다.\r\n\r\n다시 제대로 개념을 정리하기 위하여 선택한 책은 `안드로이드 스튜디오 Arctic Fox & 프로그래밍` 이였다.\r\n\r\n<img src=\"https://user-images.githubusercontent.com/63226023/147557567-199d365e-f492-4456-a63c-f9f39d765c67.png\" width=\"150\">\r\n<- 이 책의 선택의 기준은 다음과 같다.\r\n\r\n1. 전체적인 안드로이드 로드맵을 가지고있는 책. \r\n2. 빠르게 변화하는 안드로이드에 맞추어 비교적 최신의 책.\r\n\r\n[책의 목차](https://github.com/ppeper/Android_Arctic-Fox/blob/main/README.md)를 보면 필요한 개념들을 상세히 정해주고 최신 기술인 `Jetpack` 라이브러리를 알려주는 책인 것을 볼 수 있었다. \r\n\r\n실제로 내용을 보면 어떠할지는 모르지만 방학동안에 이 책에 대한 내용을 공부하고 개념을 다시한번 정리하려고 한다.\r\n\r\n\r\n\r\n\r\n"},{"excerpt":"문제 설명 짝지어 제거하기는, 알파벳 소문자로 이루어진 문자열을 가지고 시작합니다. 먼저 문자열에서 같은 알파벳이 2개 붙어 있는 짝을 찾습니다. 그다음, 그 둘을 제거한 뒤, 앞뒤로 문자열을 이어 붙입니다. 이 과정을 반복해서 문자열을 모두 제거한다면 짝지어 제거하기가 종료됩니다. 문자열 S가 주어졌을 때, 짝지어 제거하기를 성공적으로 수행할 수 있는지…","fields":{"slug":"/programmers-tips-town/"},"frontmatter":{"date":"December 25, 2021","title":"프로그래머스 2017 팁스타운 - 짝지어 제거하기","tags":["Algorithm","programmers"]},"rawMarkdownBody":"### 문제 설명\r\n\r\n짝지어 제거하기는, 알파벳 소문자로 이루어진 문자열을 가지고 시작합니다. 먼저 문자열에서 같은 알파벳이 2개 붙어 있는 짝을 찾습니다. 그다음, 그 둘을 제거한 뒤, 앞뒤로 문자열을 이어 붙입니다. 이 과정을 반복해서 문자열을 모두 제거한다면 짝지어 제거하기가 종료됩니다. 문자열 S가 주어졌을 때, 짝지어 제거하기를 성공적으로 수행할 수 있는지 반환하는 함수를 완성해 주세요. 성공적으로 수행할 수 있으면 1을, 아닐 경우 0을 리턴해주면 됩니다.\r\n   \r\n예를 들어, 문자열 S = `baabaa` 라면\r\n\r\nb aa baa → bb aa → aa →\r\n\r\n의 순서로 문자열을 모두 제거할 수 있으므로 1을 반환합니다.\r\n\r\n### 제한사항\r\n* 문자열의 길이 : 1,000,000이하의 자연수\r\n* 문자열은 모두 소문자로 이루어져 있습니다.\r\n\r\n### 입출력 예\r\n\r\n|   s   | result |\r\n| :---- | :----- | \r\n| baabaa|    1   | \r\n| cdcd  |    0   | \r\n\r\n### 풀이\r\n\r\n- - - \r\n\r\n1. 짝지어 삭제하는 문제에서는 `Stack/Queue` 구조를 많이 사용하기 때문에 이 자료구조부터 생각하였다.\r\n2. `Stack`이 비어있으면 값을 넣고 그 다음부터 `Stack`에 넣기전에 전에 `LIFO`구조로 가장 최신으로 들어온값을 비교하여 같으면 그값을 삭제하고 `다르면` `Stack`에 push하여 진행한다.\r\n3. 문자열의 모든 값이 다 지나고 `Stack`이 empty면 -> 모두 제거 1 else 0으로 출력.\r\n\r\n# 코드(Java)\r\n\r\n- - -\r\n\r\n```java\r\nimport java.util.Stack;\r\n\r\nclass Solution {\r\n    public int solution(String s) {\r\n        Stack<Character> stack = new Stack<Character>();\r\n        for (char ch: s.toCharArray()) {\r\n            if (stack.isEmpty()) {\r\n                stack.push(ch);\r\n            } else {\r\n                // 마지막에 들어온 값과 현재 들어올 값이 같음\r\n                if (stack.peek() == ch) {\r\n                    stack.pop();\r\n                } else {\r\n                    stack.push(ch);\r\n                }\r\n            }\r\n        }\r\n        return stack.isEmpty() ? 1 : 0;\r\n    }\r\n}\r\n```"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}