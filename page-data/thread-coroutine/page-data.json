{"componentChunkName":"component---src-templates-post-jsx","path":"/thread-coroutine/","result":{"data":{"site":{"siteMetadata":{"title":"ppeper🥤"}},"markdownRemark":{"id":"4e1aca12-ae73-550a-9bd0-d4519b0e2b34","excerpt":"안드로이드 앱은 되면 'ANR(애플리케이션 응답 없음)' 오류가 발생하게 된다❗ 앱에서 개발을 하다보면 비동기 백그라운드 작업 을 통하여 이러한 ANR이 발생하지 않도록 노력을 해야한다.  처음으로 앱을 개발할때 네트워크 통신을 할때 위와 같은 문제에 봉착하여 큰 난관에 빠졌었던 기억이 많다. 이번 포스팅을 시작으로 비동기 작업 을 공부하며 정리해 보려고…","html":"<p align='center'><img src='https://user-images.githubusercontent.com/63226023/152731810-a0d2ddc8-cbee-48b0-8398-3b6deb4f0233.png'></p>\n<blockquote>\n<ul>\n<li>안드로이드 앱은 <code class=\"language-text\">UI 스레드가 너무 오랫동안 차단</code>되면 'ANR(애플리케이션 응답 없음)' 오류가 발생하게 된다❗</li>\n<li>앱에서 개발을 하다보면 <strong>비동기 백그라운드 작업</strong> 을 통하여 이러한 ANR이 발생하지 않도록 노력을 해야한다. </li>\n</ul>\n</blockquote>\n<p>처음으로 앱을 개발할때 네트워크 통신을 할때 위와 같은 문제에 봉착하여 큰 난관에 빠졌었던 기억이 많다. 이번 포스팅을 시작으로 <strong>비동기 작업</strong> 을 공부하며 정리해 보려고 한다🤔</p>\n<p>📍 잠깐 짚고 넘어가기</p>\n<blockquote>\n<p><strong>동기(synchronous : 동시에 일어나는)</strong> : 요청을 보내면 결과값이 오기까지 작업을 멈춘다.<br>\n<strong>비동기(Asynchronous : 동시에 일어나지 않는)</strong> : 요청을 보내면 작업을 멈추지 않고 다른 일을 수행한다.</p>\n</blockquote>\n<hr>\n<h1 id=\"Thread-개요\" style=\"position:relative;\"><a href=\"#Thread-%EA%B0%9C%EC%9A%94\" aria-label=\"Thread 개요 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Thread 개요</h1>\n<p>스레드는 멀티태스킹 운영체제의 초석으로 <strong>메인 프로세스 내</strong> 에서 <strong>작은 프로세스가 실행</strong> 되는 것으로 생각할 수 있다. </p>\n<blockquote>\n<p>📍스레드의 목적은 앱 내부에서 <strong>병렬로 실행될 수 있는 코드</strong> 를 만드는 것</p>\n</blockquote>\n<h1 id=\"알아보고-가기\" style=\"position:relative;\"><a href=\"#%EC%95%8C%EC%95%84%EB%B3%B4%EA%B3%A0-%EA%B0%80%EA%B8%B0\" aria-label=\"알아보고 가기 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>🤔알아보고 가기</h1>\n<h2 id=\"Process-vs-Thread\" style=\"position:relative;\"><a href=\"#Process-vs-Thread\" aria-label=\"Process vs Thread permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Process vs Thread</h2>\n<p>프로세스와 비슷해보이는 스레드를 알아보기전에 <code class=\"language-text\">~ 프로그램</code>이라는 말을 많이 들어봤을 것이다.<br>\n프로그램의 예시는 흔히 위도우 컴퓨터에서 볼 수 있는 <strong>.exe</strong> 파일이라고 생각하면 된다.</p>\n<blockquote>\n<p>📍Program : <strong>보조기억장치에 존재하는 실행파일</strong></p>\n</blockquote>\n<p>이러한 <code class=\"language-text\">프로그램</code>은 사용자가 클릭을 하여 운영체제가 <code class=\"language-text\">실행</code>을 하게 해야한다. 즉 실행되고 있는 프로그램이 <strong>프로세스</strong> 라고 할 수 있다.</p>\n<p align='center'><img src='https://user-images.githubusercontent.com/63226023/152743857-ac10d808-8324-461b-9f97-40a07e1eeadb.png'></p>\n<blockquote>\n<p>📍Process : <strong>메모리에 올라와 실행되고 있는 프로그램</strong> 의 인스턴스</p>\n</blockquote>\n<p>🔔프로세스는 다음과 같은 특징이 있다.</p>\n<ul>\n<li>프로세스는 하나 이상의 스레드(메인 스레드)를 포함한다.</li>\n<li>각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.</li>\n<li>다른 프로세스의 자원에 접근을 하려면 프로세스간 통신(IPC: Inter-Process-Communication)을 사용해야 한다.</li>\n<li>프로세스는 각각 <strong>Code, Data, Stack, Heap의 구조</strong> 로 되어있는 <strong>독립된 메모리 영역</strong> 을 할당 받는다.</li>\n</ul>\n<hr>\n<p> 그렇다면 하나의 예시로 크롬창(하나의 프로세스)으로 웹 서핑을 하고 있다고 생각해 보자. 사용자들은 백그라운드로 게임을 다운하면서 웹 서핑을 계속 하고싶을 것이다. 이러한 <strong>하나의 프로세스에서 더 작인 실행 단위</strong> 를 여러 <strong>스레드</strong> 를 통하여 실행하게 된다.</p>\n<p align='center'><img src='https://user-images.githubusercontent.com/63226023/152743769-aa8ae95c-6af9-4369-98f1-92504df1bb76.png'></p>\n<blockquote>\n<p>📍Thread : 독립적인 메모리공간(Stack)을 가지는 <strong>프로세스 내에서 실행되는 여러 흐름 단위</strong></p>\n</blockquote>\n<p> 🔔스레드는 다음과 같은 특징이 있다.</p>\n<ul>\n<li>하나의 스레드는 <strong>독립적인 메모리공간(Stack)</strong> 을 할당 받고 프로세스의 Code, Data, Heap 영역은 공유한다.</li>\n<li>각 스레드는 Stack 메모리를 공유할 수 없다.</li>\n</ul>\n<h1 id=\"동시성-vs-병렬성\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%8B%9C%EC%84%B1-vs-%EB%B3%91%EB%A0%AC%EC%84%B1\" aria-label=\"동시성 vs 병렬성 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>동시성 vs 병렬성</h1>\n<p>Thread와 코루틴은 모두 <strong>동시성 프로그래밍</strong> 을 위한 기술이다.</p>\n<h2 id=\"동시성-Concurrency\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%8B%9C%EC%84%B1-Concurrency\" aria-label=\"동시성 Concurrency permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>동시성 (Concurrency)</h2>\n<p align='center'><img src='https://user-images.githubusercontent.com/63226023/152747561-c8870560-b07d-403a-8cbb-695a0fba3cce.png'></p>\n<p>동시성 프로그래밍은 여러 작업을 <strong>동시에 실행</strong> 하는 것이다. 말은 동시에 실행이라고 하였지만 이는 <strong>작업들을 잘게 쪼게어 빠르게 번갈아가며 수행</strong> 하여 두 작업은 <strong>동시에 실행되는 것</strong> 처럼 느껴지게 하는 것이다.</p>\n<h2 id=\"병렬성-Parallelism\" style=\"position:relative;\"><a href=\"#%EB%B3%91%EB%A0%AC%EC%84%B1-Parallelism\" aria-label=\"병렬성 Parallelism permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>병렬성 (Parallelism)</h2>\n<p align='center'><img src='https://user-images.githubusercontent.com/63226023/152748798-19726566-bf04-4b27-9453-cd23b31f6b21.png'></p>\n<p>병렬성 프로그래밍은 말 그대로 여러 작업을 <strong>한 번에 동시에 실행</strong> 하는 것이다. 즉 병렬성은 실행시키는 자원(CPU 코어)이 여러개(멀티코어)일때 가능한 방법이다.</p>\n<h1 id=\"Thread-vs-Coroutine\" style=\"position:relative;\"><a href=\"#Thread-vs-Coroutine\" aria-label=\"Thread vs Coroutine permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Thread vs Coroutine</h1>\n<p>Thread와 Coroutine은 둘다 <strong>동시성을 보장</strong> 하기 위해 사용된다. 처음 코루틴에 대한 용어를 알게되어 찾아봤을때는 스레드와 별반 차이를 몰랐었다. 스레드와 코루틴의 개념을 알아보면서 둘의 차이점을 알아보았다.</p>\n<h2 id=\"Thread\" style=\"position:relative;\"><a href=\"#Thread\" aria-label=\"Thread permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Thread</h2>\n<ul>\n<li>\n<p>작업의 단위 -> <strong>Thread</strong></p>\n<ul>\n<li>Thread는 독립적인 메모리공간(Stack)을 가진다</li>\n</ul>\n</li>\n<li>\n<p>동시성 보장 수단: <strong>Context Switching</strong></p>\n<ul>\n<li>OS 커널에 의한 <strong>Context Switching</strong> 을 사용한다.</li>\n<li>블로킹 : (Thread 1) 이 (Thread 2) 의 결과가 나오기까지 기다려야한다면 (Thread 1)은 <strong>블로킹</strong> 되어 그 시간동안 해당 자원을 사용하지 못한다.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><strong>🤔Context Switching?</strong>   </p>\n<ul>\n<li>CPU에서 여러 프로세스를 번갈아 가면서 작업을 처리하는 데 이 과정을 Context Switching라 한다.   </li>\n<li>구체적으로, 동작중인 프로세스가 대기 할때 해당 프로세스의 정보(Context)를 보관하고 있다가 다음 순서의 프로세스가 동작할때 해당 정보(Context)를 통하여 상태를 복구하는 작업을 말한다.</li>\n</ul>\n</blockquote>\n<p align='center'><img src='https://user-images.githubusercontent.com/63226023/152752310-17cd2826-0ad2-476f-aa85-e059b251d86b.png'></p>\n<p>위의 그림을 보면 작업 단위는 모두 Thread인것을 볼 수 있다. 위의 그림에서 <strong>동시성이 보장</strong> 이 되는 과정을 보자.</p>\n<ul>\n<li>Thread A 에서 작업 1을 수행중에 작업 2가 필요할때 이를 <strong>비동기로 호출</strong> 하게 된다.</li>\n<li>이 때 Thread A 는 <strong>작업을 멈추고(블로킹)</strong> 되고, <strong>Thread B 로 Context Switching</strong> 이 일어나 작업 2 를 수행한다.</li>\n<li>작업 2가 완료되면 해당 결과값을 <strong>Thread A 로 Context Switching</strong> 이 일어나 작업 1에 반환하게 되고, 동시에 수행할 작업 3과 작업 4는 각각 Thread C 와 Thread D 에 할당된다.</li>\n<li>OS 커널에서는 <strong>Preempting Scheduling</strong> 을 통하여 각 작업에 대해 <strong>얼만큼 수행할지 또는 어떤 작업을 먼저 수행할지를 결정</strong> 하여 그에 맞게 동작을 하게 하여 <strong>동시성을 보장</strong> 하게 되는 것이다.</li>\n</ul>\n<h2 id=\"Coroutine\" style=\"position:relative;\"><a href=\"#Coroutine\" aria-label=\"Coroutine permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Coroutine</h2>\n<ul>\n<li>\n<p>작업의 단위 -> <strong>Object(Coroutine)</strong></p>\n<ul>\n<li>여러 작업에 각각 <strong>Object</strong> 를 할당한다.</li>\n<li><strong>Coroutine Object</strong> 는 객체를 담는 <strong>JVM Heap</strong> 에 적재됩니다.</li>\n</ul>\n</li>\n<li>\n<p>동시성 보장 수단: <strong>Programmer Switching</strong> = <del>No Context Switching</del></p>\n<ul>\n<li><strong>프로그래머의 코딩</strong> 을 통해 Switching 시점을 마음대로 정한다.</li>\n<li><strong>Suspend</strong> (Non-Blocking): <code class=\"language-text\">Object 1(작업 1)</code>이 <code class=\"language-text\">Object 2(작업 2)</code>의 <strong>결과가 나오기까지 기다려야한다</strong> 면\n<code class=\"language-text\">Object 1(작업 1)</code>는 <strong>Suspend(중지)</strong> 되지만 <code class=\"language-text\">Object 1(작업 1)</code>를 수행하던 <strong>Thread 는 그대로 유효</strong> 하기 때문에 <code class=\"language-text\">Object 2(작업 2)</code> 도 <code class=\"language-text\">Object 1(작업 1)</code> 과 <strong>동일한 Thread 에서 실행</strong> 될 수 있다.</li>\n</ul>\n</li>\n</ul>\n<p align='center'><img src='https://user-images.githubusercontent.com/63226023/152752334-57ccdaa1-cea6-43d4-a17f-72444f42a64d.png'></p>\n<p>작업의 단위는 <strong>Coroutine Object</strong> 이므로 작업 1 수행중에 비동기 작업 2가 발생하더라도 작업 1을 수행하던 같은 <strong>Thread에서 작업 2를 수행할 수 있으며</strong>, <strong>하나의 Thread</strong> 에서 <strong>여러개의 Coroutine Object</strong> 들을 수행할 수도 있다.</p>\n<p>위의 그림에서 작업 1에서 작업 2의 전환에 있어서 <strong>Thread A 위에서 Coroutine Object 객체들만 교체</strong> 만  이뤄지기 때문에 Context Switching 은 필요가 없다.<br>\nCoroutine은 한 Thread 에 <strong>다수의 작업(Objcet)</strong> 을 수행할 수 있음과 <strong>Context Switching 이 필요없기</strong> 때문에 <strong>Lightweight Thread</strong> 라고도 불린다.</p>\n<p>다만 위의 세번째 그림에서 처럼 작업 3, 작업 4를 위해 Thread C가 동시에 실행이 된다면, <strong>동시성을 보장</strong> 하기 위하여 Context Switching이 필요하다. 따라서 Coroutine의 <strong>No Context Switching 이라는 장점</strong> 을 최대한 활용하기 위해 <del>여러 Thread 를 사용하는 것</del>보다 <strong>단일 Thread 에서 여러 Coroutine Object 들을 실행하는 것</strong> 이 좋다😮</p>\n<blockquote>\n<p>💡Coroutine 은 <del>Thread 의 대안</del>이 아니라 <strong>기존의 Thread</strong> 를 <strong>더 잘게 쪼개어 사용</strong> 하기위한 개념이다.   </p>\n<ul>\n<li>작업의 단위가 Thread가 아닌 Object 단위로 축소하면서 <strong>단일 Thread가 여러 코루틴을 다룰 수 있기 때문</strong> 에 작업의 수만큼 Thread를 생성하지 않아도 되어 <strong>메모리 낭비, Context Switching</strong> 의 비용 낭비를 할 필요가 없다.</li>\n</ul>\n</blockquote>\n<h1 id=\"마무리-정리\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC-%EC%A0%95%EB%A6%AC\" aria-label=\"마무리 정리 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>마무리 정리</h1>\n<p>처음 Coroutine의 용어를 접했을 때는 Thread와의 차이를 알지 못하고 같은 작업을 한다고 생각하였었다😂</p>\n<p>앱 개발에서 <strong>비동기 작업</strong>(DB 트랜잭션, 네트워킹 요청등)은 거의 필수적으로 사용한다고 생각한다. 이러한 <strong>비동기 작업</strong> 은 앞서 정리한 내용과 같이 <strong>Coroutine을 활용</strong> 하여 비용절감을 할 수 있기 때문에 안드로이드 공부를 꾸준히 해가면서 많이 접하고 적극적으로 사용해봐야겠다👍</p>\n<hr>\n<h1 id=\"References\" style=\"position:relative;\"><a href=\"#References\" aria-label=\"References permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>References</h1>\n<ul>\n<li><a href=\"\">https://velog.io/@haero_kim/Thread-vs-Coroutine-%EB%B9%84%EA%B5%90%ED%95%B4%EB%B3%B4%EA%B8%B0#process-with-thread</a></li>\n<li><a href=\"\">https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html</a></li>\n<li><a href=\"\">https://velog.io/@gparkkii/ProgramProcessThread</a></li>\n</ul>","frontmatter":{"title":"Thread와 Coroutine 짚고 넘어가기","date":"February 07, 2022","update":"February 07, 2022","tags":["OS","비동기"],"series":"OS"},"fields":{"slug":"/thread-coroutine/","readingTime":{"minutes":11.4}}},"seriesList":{"edges":[{"node":{"id":"4e1aca12-ae73-550a-9bd0-d4519b0e2b34","fields":{"slug":"/thread-coroutine/"},"frontmatter":{"title":"Thread와 Coroutine 짚고 넘어가기"}}}]},"previous":{"fields":{"slug":"/programmers-kakao-blind-2018-1/"},"frontmatter":{"title":"프로그래머스 2018 KAKAO RECRUITMENT - [1차]캐시"}},"next":{"fields":{"slug":"/programmers-kakao-blind-2021-1/"},"frontmatter":{"title":"프로그래머스 2021 KAKAO BLIND RECRUITMENT - 순위 검색"}}},"pageContext":{"id":"4e1aca12-ae73-550a-9bd0-d4519b0e2b34","series":"OS","previousPostId":"e39e5fd5-6c40-5260-b245-d291e7d62b55","nextPostId":"243a7274-df6b-570a-8a1e-05e4f556f787"}},"staticQueryHashes":[],"slicesMap":{}}