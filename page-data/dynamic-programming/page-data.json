{"componentChunkName":"component---src-templates-post-jsx","path":"/dynamic-programming/","result":{"data":{"site":{"siteMetadata":{"title":"ppeper🥤"}},"markdownRemark":{"id":"8538a459-fc98-5af8-82f2-4ec7fd589e83","excerpt":"Dynamic Programming(동적 프로그래밍) 동적 프로그래밍이란 주어진 문제를 부분 문제로 나누어 각 부분 문제의 답을 계산하고, 이 계산한 결과값을 이용해 원래 문제의 답을 산출 하는 방법이다. Divide And Conquer 동적 프로그래밍과 같이 큰 문제를 작은 문제로 나누는 알고리즘은 분할 정복(Divide And Conquer) 이 있…","html":"<h1 id=\"Dynamic-Programming동적-프로그래밍\" style=\"position:relative;\"><a href=\"#Dynamic-Programming%EB%8F%99%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D\" aria-label=\"Dynamic Programming동적 프로그래밍 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Dynamic Programming(동적 프로그래밍)</h1>\n<p>동적 프로그래밍이란 <strong>주어진 문제를 부분 문제로 나누어</strong> 각 부분 문제의 답을 계산하고, <strong>이 계산한 결과값을 이용해 원래 문제의 답을 산출</strong> 하는 방법이다.</p>\n<h2 id=\"Divide-And-Conquer\" style=\"position:relative;\"><a href=\"#Divide-And-Conquer\" aria-label=\"Divide And Conquer permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Divide And Conquer</h2>\n<p>동적 프로그래밍과 같이 큰 문제를 작은 문제로 나누는 알고리즘은 <strong>분할 정복(Divide And Conquer)</strong> 이 있다.</p>\n<blockquote>\n<p>📌분할 정복(Divide And Conquer)</p>\n<p><strong>Divide(분할):</strong> 주어진 문제를 부분 문제로 나눈다.</p>\n<p><strong>Conquer(정복):</strong> 작은 문제들을 더 이상 분할되지 않을때까지 <strong>분할(recursion)</strong> 후 작은문제에 대한 답을 구한다.</p>\n<p><strong>Conbine(결합):</strong> 나누어진 작은 문제에 대한 정복된 답을 결합을 통하여 <strong>원래의 문제에 대한 답을 구한다</strong></p>\n</blockquote>\n<blockquote>\n<p>🧷분할 정복은 주어진 문제를 작은 문제로 나누어 푸는 방식으로 <strong>하향식(Top down)</strong> 접근 방법이다.</p>\n</blockquote>\n<hr>\n<h2 id=\"Dynamic-Programming\" style=\"position:relative;\"><a href=\"#Dynamic-Programming\" aria-label=\"Dynamic Programming permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Dynamic Programming</h2>\n<p>동적 프로그래은 분할 정복과 다르게 <strong>작은 문제가 반복</strong> 되는지에 대한 여부가 중요하다. 동적 프로그래밍은 작은 문제의 반복되는 값을 <strong>메모를 해 놓았다가</strong> 다시 사용하여 푸는 방법이다.</p>\n<ol>\n<li>\n<p>동적 프로그래밍을 사용하기 위한 조건은 아래와 같다.</p>\n<blockquote>\n<ul>\n<li>문제를 나누었을 때 작은 문제가 <strong>반복적으로</strong> 일어나는 경우</li>\n<li>같은 나누어진 문제에 대한 <strong>답이 항상 같을 경우</strong></li>\n</ul>\n</blockquote>\n</li>\n<li>Memoization</li>\n</ol>\n<p>앞서 동적 프로그래밍은 <strong>작은 문제가 반복되는 부분을 메모를 해 놓았다가 사용</strong> 한다고 하였다. 이를 Memoization이라고 표현 하며 배열을 통하여 저장할 공간을 생성한다.</p>\n<blockquote>\n<p>🧷Memoization: 계산한 결과를 저장하고 필요할때 다시 사용한다.</p>\n</blockquote>\n<h1 id=\"피보나치\" style=\"position:relative;\"><a href=\"#%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98\" aria-label=\"피보나치 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>피보나치</h1>\n<p>동적 프로그래밍의 예시를 위하여 피보나치 수열을 보면 다음과 같다.</p>\n<blockquote>\n<p>피보나치 수: 첫 번째 및 두번 째 항이 1이며 그 뒤의 모든 항은 바로 앞 두 항의 합인 수열</p>\n</blockquote>\n<ol>\n<li>Recursion 사용</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Int <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> n\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// fibonacci(7) -> 13</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>피보나치 수열을 구하는 과정을 보면 아래와 같다.</p>\n<img src='https://user-images.githubusercontent.com/63226023/168243379-d011f728-5ed4-4696-bfc0-193a44890949.png'>\n<p>피보나치에서 F4까지만 보게되면 여기서도 이미 <strong>F3은 3번, F4는 3번은 반복되어 사용</strong> 되는 것을 볼 수 있다.</p>\n<blockquote>\n<p>Fibonacci(n) = Fibonacci(n-2) + Fibonacci(n-1)</p>\n</blockquote>\n<p>이를 동적 프로그래밍으로 <code class=\"language-text\">Memoization</code>을 사용하여 작은 문제에 대한 결과값을 저장하여 사용하면 아래와 같다.</p>\n<p>전역 변수 <code class=\"language-text\">memo</code>의 배열에서 값을 저장해두고 필요할 때 사용하여 값을 구한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> memo <span class=\"token operator\">=</span> <span class=\"token function\">IntArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Int <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        memo<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> n\n        memo<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>memo<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            memo<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n        memo<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// fibonacci(7) -> 21</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<hr>","frontmatter":{"title":"알고리즘 Dynamic Programming(동적 프로그래밍) 살펴보기","date":"May 13, 2022","update":"May 13, 2022","tags":["Algorithm","DP"],"series":"Algorithm"},"fields":{"slug":"/dynamic-programming/","readingTime":{"minutes":3.845}}},"seriesList":{"edges":[{"node":{"id":"a6e2b33f-15de-5f46-9612-692c2a3b893b","fields":{"slug":"/programmers-tips-town/"},"frontmatter":{"title":"프로그래머스 2017 팁스타운 - 짝지어 제거하기"}}},{"node":{"id":"92348803-f39f-5558-b4f5-2108ac192122","fields":{"slug":"/programmers-kakao-blind-2020-1/"},"frontmatter":{"title":"프로그래머스 2020 KAKAO BLIND RECRUITMENT - 괄호 변환"}}},{"node":{"id":"fb1f5d3c-d399-50ed-a817-20df36759001","fields":{"slug":"/programmers-kakao-blind-2020-2/"},"frontmatter":{"title":"프로그래머스 2022 KAKAO RECRUITMENT - 신고 결과 받기"}}},{"node":{"id":"31b31189-9fe0-55a7-bc1d-fd7f5a5f204e","fields":{"slug":"/programmers-kakao-blind-2020-3/"},"frontmatter":{"title":"프로그래머스 2022 KAKAO RECRUITMENT - k진수에서 소수 개수 구하기"}}},{"node":{"id":"436137ee-76e2-55d1-8423-e79026957050","fields":{"slug":"/programmers-kakao-blind-2018-1/"},"frontmatter":{"title":"프로그래머스 2018 KAKAO RECRUITMENT - [1차]캐시"}}},{"node":{"id":"a392149d-17e0-5618-9c81-ff93eb50e4ce","fields":{"slug":"/programmers-kakao-blind-2021-1/"},"frontmatter":{"title":"프로그래머스 2021 KAKAO BLIND RECRUITMENT - 순위 검색"}}},{"node":{"id":"a7cdd531-abe3-5f8b-a851-04e96b20b97b","fields":{"slug":"/brute-force/"},"frontmatter":{"title":"알고리즘 완전탐색(Exhaustive search)이란"}}},{"node":{"id":"f045bd0f-f85c-5d2b-8d5e-5071f9308fb5","fields":{"slug":"/greedy/"},"frontmatter":{"title":"그리디 알고리즘(Greedy Algorithm)에 대해"}}},{"node":{"id":"7dbb88c6-1acd-5dfb-ba0b-b33d71f105f6","fields":{"slug":"/dfs-bfs/"},"frontmatter":{"title":"알고리즘 DFS/BFS 탐색 방법 알아보기"}}},{"node":{"id":"8538a459-fc98-5af8-82f2-4ec7fd589e83","fields":{"slug":"/dynamic-programming/"},"frontmatter":{"title":"알고리즘 Dynamic Programming(동적 프로그래밍) 살펴보기"}}},{"node":{"id":"7818114f-7688-56f9-9e8f-2756095022de","fields":{"slug":"/graph-mst/"},"frontmatter":{"title":"그래프 알고리즘이란 + 최소 신장 트리(MST)"}}},{"node":{"id":"100720b0-59e5-5a28-985b-043ebfeba57f","fields":{"slug":"/graph-sortest-path/"},"frontmatter":{"title":"그래프 최단거리 구하기"}}}]},"previous":{"fields":{"slug":"/sort/"},"frontmatter":{"title":"코틀린 리스트 정렬하는 방법 (sort vs sortBy vs sortWith)"}},"next":{"fields":{"slug":"/graph-mst/"},"frontmatter":{"title":"그래프 알고리즘이란 + 최소 신장 트리(MST)"}}},"pageContext":{"id":"8538a459-fc98-5af8-82f2-4ec7fd589e83","series":"Algorithm","previousPostId":"e2656aa2-770e-598c-a41d-36367e5cc54d","nextPostId":"7818114f-7688-56f9-9e8f-2756095022de"}},"staticQueryHashes":[],"slicesMap":{}}