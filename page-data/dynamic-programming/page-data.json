{"componentChunkName":"component---src-templates-post-jsx","path":"/dynamic-programming/","result":{"data":{"site":{"siteMetadata":{"title":"ppeper🥤"}},"markdownRemark":{"id":"5bfc345a-73e4-5ba2-9ecc-2d0f7cbcc406","excerpt":"Dynamic Programming(동적 프로그래밍) 동적 프로그래밍이란 주어진 문제를 부분 문제로 나누어 각 부분 문제의 답을 계산하고, 이 계산한 결과값을 이용해 원래 문제의 답을 산출 하는 방법이다. Divide And Conquer 동적 프로그래밍과 같이 큰 문제를 작은 문제로 나누는 알고리즘은 분할 정복(Divide And Conquer) 이 있…","html":"<h1>Dynamic Programming(동적 프로그래밍)</h1>\n<p>동적 프로그래밍이란 <strong>주어진 문제를 부분 문제로 나누어</strong> 각 부분 문제의 답을 계산하고, <strong>이 계산한 결과값을 이용해 원래 문제의 답을 산출</strong> 하는 방법이다.</p>\n<h2>Divide And Conquer</h2>\n<p>동적 프로그래밍과 같이 큰 문제를 작은 문제로 나누는 알고리즘은 <strong>분할 정복(Divide And Conquer)</strong> 이 있다.</p>\n<blockquote>\n<p>📌분할 정복(Divide And Conquer)</p>\n<p><strong>Divide(분할):</strong> 주어진 문제를 부분 문제로 나눈다.</p>\n<p><strong>Conquer(정복):</strong> 작은 문제들을 더 이상 분할되지 않을때까지 <strong>분할(recursion)</strong> 후 작은문제에 대한 답을 구한다.</p>\n<p><strong>Conbine(결합):</strong> 나누어진 작은 문제에 대한 정복된 답을 결합을 통하여 <strong>원래의 문제에 대한 답을 구한다</strong></p>\n</blockquote>\n<blockquote>\n<p>🧷분할 정복은 주어진 문제를 작은 문제로 나누어 푸는 방식으로 <strong>하향식(Top down)</strong> 접근 방법이다.</p>\n</blockquote>\n<hr>\n<h2>Dynamic Programming</h2>\n<p>동적 프로그래은 분할 정복과 다르게 <strong>작은 문제가 반복</strong> 되는지에 대한 여부가 중요하다. 동적 프로그래밍은 작은 문제의 반복되는 값을 <strong>메모를 해 놓았다가</strong> 다시 사용하여 푸는 방법이다.</p>\n<ol>\n<li>\n<p>동적 프로그래밍을 사용하기 위한 조건은 아래와 같다.</p>\n<blockquote>\n<ul>\n<li>문제를 나누었을 때 작은 문제가 <strong>반복적으로</strong> 일어나는 경우</li>\n<li>같은 나누어진 문제에 대한 <strong>답이 항상 같을 경우</strong></li>\n</ul>\n</blockquote>\n</li>\n<li>Memoization</li>\n</ol>\n<p>앞서 동적 프로그래밍은 <strong>작은 문제가 반복되는 부분을 메모를 해 놓았다가 사용</strong> 한다고 하였다. 이를 Memoization이라고 표현 하며 배열을 통하여 저장할 공간을 생성한다.</p>\n<blockquote>\n<p>🧷Memoization: 계산한 결과를 저장하고 필요할때 다시 사용한다.</p>\n</blockquote>\n<h1>피보나치</h1>\n<p>동적 프로그래밍의 예시를 위하여 피보나치 수열을 보면 다음과 같다.</p>\n<blockquote>\n<p>피보나치 수: 첫 번째 및 두번 째 항이 1이며 그 뒤의 모든 항은 바로 앞 두 항의 합인 수열</p>\n</blockquote>\n<ol>\n<li>Recursion 사용</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Int <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> n\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// fibonacci(7) -> 13</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>피보나치 수열을 구하는 과정을 보면 아래와 같다.</p>\n<img src=\"https://user-images.githubusercontent.com/63226023/168243379-d011f728-5ed4-4696-bfc0-193a44890949.png\">\n<p>피보나치에서 F4까지만 보게되면 여기서도 이미 <strong>F3은 3번, F4는 3번은 반복되어 사용</strong> 되는 것을 볼 수 있다.</p>\n<blockquote>\n<p>Fibonacci(n) = Fibonacci(n-2) + Fibonacci(n-1)</p>\n</blockquote>\n<p>이를 동적 프로그래밍으로 <code class=\"language-text\">Memoization</code>을 사용하여 작은 문제에 대한 결과값을 저장하여 사용하면 아래와 같다.</p>\n<p>전역 변수 <code class=\"language-text\">memo</code>의 배열에서 값을 저장해두고 필요할 때 사용하여 값을 구한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> memo <span class=\"token operator\">=</span> <span class=\"token function\">IntArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Int <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        memo<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> n\n        memo<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>memo<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            memo<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n        memo<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// fibonacci(7) -> 21</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<hr>","frontmatter":{"title":"알고리즘 Dynamic Programming(동적 프로그래밍) 살펴보기","date":"May 13, 2022","update":"May 13, 2022","tags":["Algorithm","DP"],"series":"Algorithm"},"fields":{"slug":"/dynamic-programming/","readingTime":{"minutes":3.845}}},"seriesList":{"edges":[{"node":{"id":"6a88ad07-efd2-5e8e-85cb-d5bba9e8cf17","fields":{"slug":"/programmers-tips-town/"},"frontmatter":{"title":"프로그래머스 2017 팁스타운 - 짝지어 제거하기"}}},{"node":{"id":"814be3a5-2662-5037-a41b-ae3a88c11945","fields":{"slug":"/programmers-kakao-blind-2020-1/"},"frontmatter":{"title":"프로그래머스 2020 KAKAO BLIND RECRUITMENT - 괄호 변환"}}},{"node":{"id":"9235e1fe-da08-5cc6-96e9-5919bddff0fa","fields":{"slug":"/programmers-kakao-blind-2020-2/"},"frontmatter":{"title":"프로그래머스 2022 KAKAO RECRUITMENT - 신고 결과 받기"}}},{"node":{"id":"25be2350-7ca4-5657-b192-255f4ac12389","fields":{"slug":"/programmers-kakao-blind-2020-3/"},"frontmatter":{"title":"프로그래머스 2022 KAKAO RECRUITMENT - k진수에서 소수 개수 구하기"}}},{"node":{"id":"8cfe1ce4-abd0-51a5-b257-ee4b1b89dccf","fields":{"slug":"/programmers-kakao-blind-2018-1/"},"frontmatter":{"title":"프로그래머스 2018 KAKAO RECRUITMENT - [1차]캐시"}}},{"node":{"id":"5e3cc442-642e-5777-b707-5f1513b6e7fc","fields":{"slug":"/programmers-kakao-blind-2021-1/"},"frontmatter":{"title":"프로그래머스 2021 KAKAO BLIND RECRUITMENT - 순위 검색"}}},{"node":{"id":"4c2618c6-2138-584d-925b-5ad902505f6b","fields":{"slug":"/brute-force/"},"frontmatter":{"title":"알고리즘 완전탐색(Exhaustive search)이란"}}},{"node":{"id":"b167a775-e860-5c19-8368-765d569da317","fields":{"slug":"/greedy/"},"frontmatter":{"title":"그리디 알고리즘(Greedy Algorithm)에 대해"}}},{"node":{"id":"ef3315e9-7887-56c5-ab56-f0fa510d25a7","fields":{"slug":"/dfs-bfs/"},"frontmatter":{"title":"알고리즘 DFS/BFS 탐색 방법 알아보기"}}},{"node":{"id":"5bfc345a-73e4-5ba2-9ecc-2d0f7cbcc406","fields":{"slug":"/dynamic-programming/"},"frontmatter":{"title":"알고리즘 Dynamic Programming(동적 프로그래밍) 살펴보기"}}},{"node":{"id":"e6cffd30-3ac6-5a9a-8e24-0b0c55c47891","fields":{"slug":"/graph-mst/"},"frontmatter":{"title":"그래프 알고리즘이란 + 최소 신장 트리(MST)"}}},{"node":{"id":"d80bd3c0-f2e9-5a38-a7fd-21ad9685fc86","fields":{"slug":"/graph-sortest-path/"},"frontmatter":{"title":"그래프 최단거리 구하기"}}}]},"previous":{"fields":{"slug":"/sort/"},"frontmatter":{"title":"코틀린 리스트 정렬하는 방법 (sort vs sortBy vs sortWith)"}},"next":{"fields":{"slug":"/graph-mst/"},"frontmatter":{"title":"그래프 알고리즘이란 + 최소 신장 트리(MST)"}}},"pageContext":{"id":"5bfc345a-73e4-5ba2-9ecc-2d0f7cbcc406","series":"Algorithm","previousPostId":"995d0539-ea55-5757-b642-d423a2fef20c","nextPostId":"e6cffd30-3ac6-5a9a-8e24-0b0c55c47891"}},"staticQueryHashes":[],"slicesMap":{}}