{"componentChunkName":"component---src-templates-post-jsx","path":"/graph-mst/","result":{"data":{"site":{"siteMetadata":{"title":"ppeper🥤"}},"markdownRemark":{"id":"e6cffd30-3ac6-5a9a-8e24-0b0c55c47891","excerpt":"🎯그래프 정점(V)과 간선(E)로 이루어진 자료구조이다. 그래프는 사이클이 존재 할 수 있고 간선의 방향이 양뱡향일 수 있다. V개의 정점을 가지는 무방향 그래프  최대 간선 갯수 = V(V-1)/2 V개의 정점을 가지는 방향 그래프 의  최대 간선 갯수 = V(V-1) 🧷그래프의 종류 무방향 그래프: 두 정점을 연결하는 간선에 방향이 없는 그래프이다. …","html":"<h1>🎯그래프</h1>\n<ul>\n<li>정점(V)과 간선(E)로 이루어진 자료구조이다.</li>\n<li>그래프는 <strong>사이클이 존재</strong> 할 수 있고 간선의 방향이 양뱡향일 수 있다.</li>\n<li>\n<p>V개의 정점을 가지는 <strong>무방향 그래프</strong> </p>\n<ul>\n<li>최대 간선 갯수 = V(V-1)/2</li>\n</ul>\n</li>\n<li>\n<p>V개의 정점을 가지는 <strong>방향 그래프</strong> 의 </p>\n<ul>\n<li>최대 간선 갯수 = V(V-1)</li>\n</ul>\n</li>\n</ul>\n<h2>🧷그래프의 종류</h2>\n<blockquote>\n<ol>\n<li>무방향 그래프: 두 정점을 연결하는 간선에 방향이 없는 그래프이다.</li>\n</ol>\n<img src=\"https://user-images.githubusercontent.com/63226023/168820953-4b4ea5a8-7471-4cd8-946f-b5948841f671.png\" width=\"30%\">\n<ol start=\"2\">\n<li>방향 그래프: 두 정점을 연결하는 간선에 방향이 있는 그래프이다.</li>\n</ol>\n<img src=\"https://user-images.githubusercontent.com/63226023/168822029-20a4c4a6-c0f5-40cc-bcef-2f94b55a6acd.png\" width=\"30%\">\n<ol start=\"3\">\n<li>가중치 그래프: 두 정점을 이동할때 비용이 드는 그래프이다.</li>\n</ol>\n<img src=\"https://user-images.githubusercontent.com/63226023/168822813-d547202b-de98-4a3b-9999-ebaab354ccc0.png\" width=\"30%\">\n<ol start=\"4\">\n<li>완전 그래프: 모든 정점이 간선으로 연결되어 있는 그래프이다.</li>\n</ol>\n<img src=\"https://user-images.githubusercontent.com/63226023/168822899-b5f6576f-30fa-47f3-b9a5-69c79250d875.png\" width=\"30%\">\n</blockquote>\n<h2>그래프의 구현 방법</h2>\n<p>그래프를 구현하는 방법은 크게 <strong>인접행렬(Adjacency Matrix)</strong>, <strong>인접리스트(Adjacency List)</strong> 방식이 있다.</p>\n<p>두 개의 구현 방식은 각각의 장단점이 있는데 대부분 <code class=\"language-text\">인접리스트</code> 방식을 많이 사용한다.</p>\n<h3>인접행렬</h3>\n<img src=\"https://user-images.githubusercontent.com/63226023/169044528-8e425dd7-6a9e-4ab4-8e89-0a4955c2d296.png\">\n<blockquote>\n<p>인접행렬은 그래프의 노드들을 <strong>2차원 배열</strong> 로 나타내어, 하나의 정점이 다른 정점과 연결이 되어있으면 <code class=\"language-text\">1</code> 아니면 <code class=\"language-text\">0</code>을 넣어서 만들어 준다.</p>\n</blockquote>\n<p>장점</p>\n<ol>\n<li><strong>두 정점의 연결 정보</strong> 를 알고 싶을때 2차원 배열의 위치가 곧 연결 정보이기 때문에 O(1)의 시간복잡도로 알 수 있다.</li>\n<li>구현이 비교적 간단하다.</li>\n</ol>\n<p>단점 </p>\n<ol>\n<li>2차원 배열에 모든 정점에 대한 간선 정보를 넣어줘야 하므로 O(n²)의 시간복잡도가 소요된다.</li>\n<li>2차원 배열을 사용하므로 필요 이상의 공간을 사용할 가능성이 있다.</li>\n</ol>\n<h3>인접리스트</h3>\n<img src=\"https://user-images.githubusercontent.com/63226023/169202076-00adc01a-00c7-4123-9bf5-7e7cc35bb676.png\" width=\"50%\">\n<blockquote>\n<p>인접리스트는 그래프의 노드간의 연결을 <strong>리스트</strong> 로 나타내어, 각 1,2,3,4,5의 정점에 대한 리스트 배열을 만들어 관계를 설정해준다.</p>\n</blockquote>\n<p>장점</p>\n<ol>\n<li><strong>두 정점의 연결 정보</strong> 를 탐색할때 O(n) 시간복잡도로 알 수 있다.</li>\n<li>필요한 연결정보만 리스트로 설정하여 사용하므로 공간 낭비가 적다.</li>\n</ol>\n<p>단점</p>\n<ol>\n<li>특정 두 정점에 대한 열결 정보를 알고 싶다면 인접행렬에 비하여 느리다.</li>\n</ol>\n<h1>최소 스패닝 트리</h1>\n<blockquote>\n<p>🌳 최소 신장 트리(Minimum Spanning Tree)란</p>\n<ul>\n<li>그래프의 <strong>최소 연결 그래프</strong> -> <strong>Spanning Tree</strong></li>\n<li><strong>Spanning Tree</strong> 에서 간선(E)의 <strong>가중치의 합이 최소</strong> 가 되는 트리 -> <strong>Minimum Spanning Tree</strong></li>\n</ul>\n</blockquote>\n<h2>크루스칼</h2>\n<p>크루스칼 알고리즘은 <strong>가중치가 있는무향 연결 그래프</strong> 가 주어질 때, 최소 스패닝 트리(MST)를 구하는 알고리즘이다. </p>\n<ul>\n<li><strong>모든 간선</strong> 에 대하여 가중치가 적은 순서대로 정렬하여 <strong>그리디 하게</strong> 뽑는다.</li>\n<li>가중치가 적은 순서대로 뽑아 두 정점이 <code class=\"language-text\">연결</code>되어 있지 않다면 두 정점을 <code class=\"language-text\">union</code>하여 연결한다.</li>\n<li>두 정점이 <code class=\"language-text\">연결</code>되었다는 것은 하나의 집합을 이루었다고 할 수 있다.</li>\n<li>최소 신장 트리를 구하기 위해서 같은 집합(사이클이 형성 되는지)에 속하는지에 대한 판별을 하는 과정이 필요하다.</li>\n</ul>\n<h3>Union &#x26; Find(합집합 찾기)</h3>\n<p>사이클의 형성에 대한 판단으로 <code class=\"language-text\">Union &amp; Find</code> 다른 말로 <strong>서로소 집합(Disjoint-Set)</strong> 알고리즘이라고 한다.</p>\n<p>서로 다른 두 집합을 합치는 Union 연산, 알고 싶은 원소가 어느 집합에 포함되는지 찾는 Find 연산이라는 의미로 이름이 붙여졌다.</p>\n<p>아래의 예시는 Union &#x26; Find를 통하여 사이클의 형성을 알아보는 과정을 보여준다.</p>\n<blockquote>\n<img src=\"https://user-images.githubusercontent.com/63226023/169308331-f4c9356f-693b-41eb-b099-c4b95baf6fdc.png\">\n<ul>\n<li>동작 과정</li>\n<li>모든 정점의 개수의 크기의 배열을 생성하여 자기자신으로 초기화 한다.</li>\n<li>두 노드간의 루트 노드(부모 노드)가 다르다면 -> 서로소 집합 -> Union 연산으로 두 노드를 연결해주고, 부모 노드를 바뀌준다. 같다면 사이클이 형성되므로 연결 불가능</li>\n</ul>\n</blockquote>\n<p>부모 노드를 찾는 Find 연산은 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token comment\">// 재귀적으로 쭉 찾기</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">getParentNode</span><span class=\"token punctuation\">(</span>node<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Int <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>parentNode<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> node<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        node\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// parent 노드가 자기자신이 아님 -> 연결된 부모가 있음</span>\n        <span class=\"token function\">getParentNode</span><span class=\"token punctuation\">(</span>parentNode<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 경로 압축</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">getParentNode</span><span class=\"token punctuation\">(</span>node<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Int <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>parentNode<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> node<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 바로 갱신하는 동시에 재귀 호출</span>\n        parentNode<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">getParentNode</span><span class=\"token punctuation\">(</span>parentNode<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> parentNode<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>프림</h2>\n<p>크루스칼과 마친가지로 최소 스패닝 트리(MST)를 구하는 알고리즘이다. 프림 알고리즘은 크루스칼과 다르게 임의의 정점을 시작점으로 잡는다. </p>\n<ul>\n<li><strong>시작 정점</strong> 을 기준으로 가중치가 가장 작은 간선과 <strong>연결된 정점</strong> 을 선택하여 트리를 확장해 가는 방식이다.</li>\n<li>각 정점들은 인접한 정점 중 <strong>최소 비용 간선</strong> 인 정점을 선택하여 큐에 추가한다.</li>\n<li><strong>우선순위 큐</strong> 를 이용하여 임의의 정점에서 인접한 정점의 <strong>간선의 가중치를 기준으로 정렬</strong> 한다.</li>\n<li>가중치가 최소인 정점을 연결후 다시 인접한 정점을 넣고 정렬한다.</li>\n</ul>\n<blockquote>\n<img src=\"https://user-images.githubusercontent.com/63226023/169350972-12a2a1ff-416c-4b9e-a779-b62f757f03ee.png\">\n<ul>\n<li>동작 과정</li>\n<li>임의의 정점에서 연결된 인접된 노드중 <strong>가중치가 최소인 간선</strong> 을 선택한다.</li>\n<li>크루스칼과 마찬가지로 사이클 형성여부는 Union &#x26; Find 연산으로 확인한다.</li>\n<li>연결이 되었다면 선택된 간선에 연결된 정점 중에 <strong>가중치가 최소인 간선</strong> 을 선택한다.(방문하지 않은 노드중)</li>\n</ul>\n</blockquote>\n<hr>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://ko.wikipedia.org/wiki/%ED%94%84%EB%A6%BC_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">https://ko.wikipedia.org/wiki/%ED%94%84%EB%A6%BC_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98</a></li>\n<li><a href=\"https://velog.io/@yuhyerin/%EA%B7%B8%EB%9E%98%ED%94%84%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">https://velog.io/@yuhyerin/%EA%B7%B8%EB%9E%98%ED%94%84%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98</a></li>\n</ul>","frontmatter":{"title":"그래프 알고리즘이란 + 최소 신장 트리(MST)","date":"May 20, 2022","update":"May 20, 2022","tags":["Algorithm","MST","그래프","크루스칼","프림"],"series":"Algorithm"},"fields":{"slug":"/graph-mst/","readingTime":{"minutes":7.665}}},"seriesList":{"edges":[{"node":{"id":"6a88ad07-efd2-5e8e-85cb-d5bba9e8cf17","fields":{"slug":"/programmers-tips-town/"},"frontmatter":{"title":"프로그래머스 2017 팁스타운 - 짝지어 제거하기"}}},{"node":{"id":"814be3a5-2662-5037-a41b-ae3a88c11945","fields":{"slug":"/programmers-kakao-blind-2020-1/"},"frontmatter":{"title":"프로그래머스 2020 KAKAO BLIND RECRUITMENT - 괄호 변환"}}},{"node":{"id":"9235e1fe-da08-5cc6-96e9-5919bddff0fa","fields":{"slug":"/programmers-kakao-blind-2020-2/"},"frontmatter":{"title":"프로그래머스 2022 KAKAO RECRUITMENT - 신고 결과 받기"}}},{"node":{"id":"25be2350-7ca4-5657-b192-255f4ac12389","fields":{"slug":"/programmers-kakao-blind-2020-3/"},"frontmatter":{"title":"프로그래머스 2022 KAKAO RECRUITMENT - k진수에서 소수 개수 구하기"}}},{"node":{"id":"8cfe1ce4-abd0-51a5-b257-ee4b1b89dccf","fields":{"slug":"/programmers-kakao-blind-2018-1/"},"frontmatter":{"title":"프로그래머스 2018 KAKAO RECRUITMENT - [1차]캐시"}}},{"node":{"id":"5e3cc442-642e-5777-b707-5f1513b6e7fc","fields":{"slug":"/programmers-kakao-blind-2021-1/"},"frontmatter":{"title":"프로그래머스 2021 KAKAO BLIND RECRUITMENT - 순위 검색"}}},{"node":{"id":"4c2618c6-2138-584d-925b-5ad902505f6b","fields":{"slug":"/brute-force/"},"frontmatter":{"title":"알고리즘 완전탐색(Exhaustive search)이란"}}},{"node":{"id":"b167a775-e860-5c19-8368-765d569da317","fields":{"slug":"/greedy/"},"frontmatter":{"title":"그리디 알고리즘(Greedy Algorithm)에 대해"}}},{"node":{"id":"ef3315e9-7887-56c5-ab56-f0fa510d25a7","fields":{"slug":"/dfs-bfs/"},"frontmatter":{"title":"알고리즘 DFS/BFS 탐색 방법 알아보기"}}},{"node":{"id":"5bfc345a-73e4-5ba2-9ecc-2d0f7cbcc406","fields":{"slug":"/dynamic-programming/"},"frontmatter":{"title":"알고리즘 Dynamic Programming(동적 프로그래밍) 살펴보기"}}},{"node":{"id":"e6cffd30-3ac6-5a9a-8e24-0b0c55c47891","fields":{"slug":"/graph-mst/"},"frontmatter":{"title":"그래프 알고리즘이란 + 최소 신장 트리(MST)"}}},{"node":{"id":"d80bd3c0-f2e9-5a38-a7fd-21ad9685fc86","fields":{"slug":"/graph-sortest-path/"},"frontmatter":{"title":"그래프 최단거리 구하기"}}}]},"previous":{"fields":{"slug":"/dynamic-programming/"},"frontmatter":{"title":"알고리즘 Dynamic Programming(동적 프로그래밍) 살펴보기"}},"next":{"fields":{"slug":"/graph-sortest-path/"},"frontmatter":{"title":"그래프 최단거리 구하기"}}},"pageContext":{"id":"e6cffd30-3ac6-5a9a-8e24-0b0c55c47891","series":"Algorithm","previousPostId":"5bfc345a-73e4-5ba2-9ecc-2d0f7cbcc406","nextPostId":"d80bd3c0-f2e9-5a38-a7fd-21ad9685fc86"}},"staticQueryHashes":[],"slicesMap":{}}