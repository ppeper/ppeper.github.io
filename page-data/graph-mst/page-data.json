{"componentChunkName":"component---src-templates-post-jsx","path":"/graph-mst/","result":{"data":{"site":{"siteMetadata":{"title":"ppeper🥤"}},"markdownRemark":{"id":"459edbb5-9a63-5390-9b2e-331fa9d3d4ad","excerpt":"🎯그래프 정점(V)과 간선(E)로 이루어진 자료구조이다. 그래프는 사이클이 존재 할 수 있고 간선의 방향이 양뱡향일 수 있다. V개의 정점을 가지는 무방향 그래프  최대 간선 갯수 = V(V-1)/2 V개의 정점을 가지는 방향 그래프 의  최대 간선 갯수 = V(V-1) 🧷그래프의 종류 무방향 그래프: 두 정점을 연결하는 간선에 방향이 없는 그래프이다. …","html":"<h1 id=\"그래프\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%9E%98%ED%94%84\" aria-label=\"그래프 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>🎯그래프</h1>\n<ul>\n<li>정점(V)과 간선(E)로 이루어진 자료구조이다.</li>\n<li>그래프는 <strong>사이클이 존재</strong> 할 수 있고 간선의 방향이 양뱡향일 수 있다.</li>\n<li>\n<p>V개의 정점을 가지는 <strong>무방향 그래프</strong> </p>\n<ul>\n<li>최대 간선 갯수 = V(V-1)/2</li>\n</ul>\n</li>\n<li>\n<p>V개의 정점을 가지는 <strong>방향 그래프</strong> 의 </p>\n<ul>\n<li>최대 간선 갯수 = V(V-1)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"그래프의-종류\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%9E%98%ED%94%84%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-label=\"그래프의 종류 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>🧷그래프의 종류</h2>\n<blockquote>\n<ol>\n<li>무방향 그래프: 두 정점을 연결하는 간선에 방향이 없는 그래프이다.</li>\n</ol>\n<img src='https://user-images.githubusercontent.com/63226023/168820953-4b4ea5a8-7471-4cd8-946f-b5948841f671.png' width='30%'>\n<ol start=\"2\">\n<li>방향 그래프: 두 정점을 연결하는 간선에 방향이 있는 그래프이다.</li>\n</ol>\n<img src='https://user-images.githubusercontent.com/63226023/168822029-20a4c4a6-c0f5-40cc-bcef-2f94b55a6acd.png' width='30%'>\n<ol start=\"3\">\n<li>가중치 그래프: 두 정점을 이동할때 비용이 드는 그래프이다.</li>\n</ol>\n<img src='https://user-images.githubusercontent.com/63226023/168822813-d547202b-de98-4a3b-9999-ebaab354ccc0.png' width='30%'>\n<ol start=\"4\">\n<li>완전 그래프: 모든 정점이 간선으로 연결되어 있는 그래프이다.</li>\n</ol>\n<img src='https://user-images.githubusercontent.com/63226023/168822899-b5f6576f-30fa-47f3-b9a5-69c79250d875.png' width='30%'>\n</blockquote>\n<h2 id=\"그래프의-구현-방법\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%9E%98%ED%94%84%EC%9D%98-%EA%B5%AC%ED%98%84-%EB%B0%A9%EB%B2%95\" aria-label=\"그래프의 구현 방법 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>그래프의 구현 방법</h2>\n<p>그래프를 구현하는 방법은 크게 <strong>인접행렬(Adjacency Matrix)</strong>, <strong>인접리스트(Adjacency List)</strong> 방식이 있다.</p>\n<p>두 개의 구현 방식은 각각의 장단점이 있는데 대부분 <code class=\"language-text\">인접리스트</code> 방식을 많이 사용한다.</p>\n<h3 id=\"인접행렬\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EC%A0%91%ED%96%89%EB%A0%AC\" aria-label=\"인접행렬 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>인접행렬</h3>\n<img src='https://user-images.githubusercontent.com/63226023/169044528-8e425dd7-6a9e-4ab4-8e89-0a4955c2d296.png'>\n<blockquote>\n<p>인접행렬은 그래프의 노드들을 <strong>2차원 배열</strong> 로 나타내어, 하나의 정점이 다른 정점과 연결이 되어있으면 <code class=\"language-text\">1</code> 아니면 <code class=\"language-text\">0</code>을 넣어서 만들어 준다.</p>\n</blockquote>\n<p>장점</p>\n<ol>\n<li><strong>두 정점의 연결 정보</strong> 를 알고 싶을때 2차원 배열의 위치가 곧 연결 정보이기 때문에 O(1)의 시간복잡도로 알 수 있다.</li>\n<li>구현이 비교적 간단하다.</li>\n</ol>\n<p>단점 </p>\n<ol>\n<li>2차원 배열에 모든 정점에 대한 간선 정보를 넣어줘야 하므로 O(n²)의 시간복잡도가 소요된다.</li>\n<li>2차원 배열을 사용하므로 필요 이상의 공간을 사용할 가능성이 있다.</li>\n</ol>\n<h3 id=\"인접리스트\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EC%A0%91%EB%A6%AC%EC%8A%A4%ED%8A%B8\" aria-label=\"인접리스트 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>인접리스트</h3>\n<img src='https://user-images.githubusercontent.com/63226023/169202076-00adc01a-00c7-4123-9bf5-7e7cc35bb676.png' width='50%'>\n<blockquote>\n<p>인접리스트는 그래프의 노드간의 연결을 <strong>리스트</strong> 로 나타내어, 각 1,2,3,4,5의 정점에 대한 리스트 배열을 만들어 관계를 설정해준다.</p>\n</blockquote>\n<p>장점</p>\n<ol>\n<li><strong>두 정점의 연결 정보</strong> 를 탐색할때 O(n) 시간복잡도로 알 수 있다.</li>\n<li>필요한 연결정보만 리스트로 설정하여 사용하므로 공간 낭비가 적다.</li>\n</ol>\n<p>단점</p>\n<ol>\n<li>특정 두 정점에 대한 열결 정보를 알고 싶다면 인접행렬에 비하여 느리다.</li>\n</ol>\n<h1 id=\"최소-스패닝-트리\" style=\"position:relative;\"><a href=\"#%EC%B5%9C%EC%86%8C-%EC%8A%A4%ED%8C%A8%EB%8B%9D-%ED%8A%B8%EB%A6%AC\" aria-label=\"최소 스패닝 트리 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>최소 스패닝 트리</h1>\n<blockquote>\n<p>🌳 최소 신장 트리(Minimum Spanning Tree)란</p>\n<ul>\n<li>그래프의 <strong>최소 연결 그래프</strong> -> <strong>Spanning Tree</strong></li>\n<li><strong>Spanning Tree</strong> 에서 간선(E)의 <strong>가중치의 합이 최소</strong> 가 되는 트리 -> <strong>Minimum Spanning Tree</strong></li>\n</ul>\n</blockquote>\n<h2 id=\"크루스칼\" style=\"position:relative;\"><a href=\"#%ED%81%AC%EB%A3%A8%EC%8A%A4%EC%B9%BC\" aria-label=\"크루스칼 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>크루스칼</h2>\n<p>크루스칼 알고리즘은 <strong>가중치가 있는무향 연결 그래프</strong> 가 주어질 때, 최소 스패닝 트리(MST)를 구하는 알고리즘이다. </p>\n<ul>\n<li><strong>모든 간선</strong> 에 대하여 가중치가 적은 순서대로 정렬하여 <strong>그리디 하게</strong> 뽑는다.</li>\n<li>가중치가 적은 순서대로 뽑아 두 정점이 <code class=\"language-text\">연결</code>되어 있지 않다면 두 정점을 <code class=\"language-text\">union</code>하여 연결한다.</li>\n<li>두 정점이 <code class=\"language-text\">연결</code>되었다는 것은 하나의 집합을 이루었다고 할 수 있다.</li>\n<li>최소 신장 트리를 구하기 위해서 같은 집합(사이클이 형성 되는지)에 속하는지에 대한 판별을 하는 과정이 필요하다.</li>\n</ul>\n<h3 id=\"Union--Find합집합-찾기\" style=\"position:relative;\"><a href=\"#Union--Find%ED%95%A9%EC%A7%91%ED%95%A9-%EC%B0%BE%EA%B8%B0\" aria-label=\"Union  Find합집합 찾기 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Union &#x26; Find(합집합 찾기)</h3>\n<p>사이클의 형성에 대한 판단으로 <code class=\"language-text\">Union &amp; Find</code> 다른 말로 <strong>서로소 집합(Disjoint-Set)</strong> 알고리즘이라고 한다.</p>\n<p>서로 다른 두 집합을 합치는 Union 연산, 알고 싶은 원소가 어느 집합에 포함되는지 찾는 Find 연산이라는 의미로 이름이 붙여졌다.</p>\n<p>아래의 예시는 Union &#x26; Find를 통하여 사이클의 형성을 알아보는 과정을 보여준다.</p>\n<blockquote>\n<img src='https://user-images.githubusercontent.com/63226023/169308331-f4c9356f-693b-41eb-b099-c4b95baf6fdc.png'>\n<ul>\n<li>동작 과정</li>\n<li>모든 정점의 개수의 크기의 배열을 생성하여 자기자신으로 초기화 한다.</li>\n<li>두 노드간의 루트 노드(부모 노드)가 다르다면 -> 서로소 집합 -> Union 연산으로 두 노드를 연결해주고, 부모 노드를 바뀌준다. 같다면 사이클이 형성되므로 연결 불가능</li>\n</ul>\n</blockquote>\n<p>부모 노드를 찾는 Find 연산은 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token comment\">// 재귀적으로 쭉 찾기</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">getParentNode</span><span class=\"token punctuation\">(</span>node<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Int <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>parentNode<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> node<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        node\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// parent 노드가 자기자신이 아님 -> 연결된 부모가 있음</span>\n        <span class=\"token function\">getParentNode</span><span class=\"token punctuation\">(</span>parentNode<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 경로 압축</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">getParentNode</span><span class=\"token punctuation\">(</span>node<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Int <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>parentNode<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> node<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 바로 갱신하는 동시에 재귀 호출</span>\n        parentNode<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">getParentNode</span><span class=\"token punctuation\">(</span>parentNode<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> parentNode<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"프림\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A6%BC\" aria-label=\"프림 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>프림</h2>\n<p>크루스칼과 마친가지로 최소 스패닝 트리(MST)를 구하는 알고리즘이다. 프림 알고리즘은 크루스칼과 다르게 임의의 정점을 시작점으로 잡는다. </p>\n<ul>\n<li><strong>시작 정점</strong> 을 기준으로 가중치가 가장 작은 간선과 <strong>연결된 정점</strong> 을 선택하여 트리를 확장해 가는 방식이다.</li>\n<li>각 정점들은 인접한 정점 중 <strong>최소 비용 간선</strong> 인 정점을 선택하여 큐에 추가한다.</li>\n<li><strong>우선순위 큐</strong> 를 이용하여 임의의 정점에서 인접한 정점의 <strong>간선의 가중치를 기준으로 정렬</strong> 한다.</li>\n<li>가중치가 최소인 정점을 연결후 다시 인접한 정점을 넣고 정렬한다.</li>\n</ul>\n<blockquote>\n<img src='https://user-images.githubusercontent.com/63226023/169350972-12a2a1ff-416c-4b9e-a779-b62f757f03ee.png'>\n<ul>\n<li>동작 과정</li>\n<li>임의의 정점에서 연결된 인접된 노드중 <strong>가중치가 최소인 간선</strong> 을 선택한다.</li>\n<li>크루스칼과 마찬가지로 사이클 형성여부는 Union &#x26; Find 연산으로 확인한다.</li>\n<li>연결이 되었다면 선택된 간선에 연결된 정점 중에 <strong>가중치가 최소인 간선</strong> 을 선택한다.(방문하지 않은 노드중)</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"References\" style=\"position:relative;\"><a href=\"#References\" aria-label=\"References permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>References</h1>\n<ul>\n<li><a href=\"https://ko.wikipedia.org/wiki/%ED%94%84%EB%A6%BC_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">https://ko.wikipedia.org/wiki/%ED%94%84%EB%A6%BC_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98</a></li>\n<li><a href=\"https://velog.io/@yuhyerin/%EA%B7%B8%EB%9E%98%ED%94%84%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">https://velog.io/@yuhyerin/%EA%B7%B8%EB%9E%98%ED%94%84%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98</a></li>\n</ul>","frontmatter":{"title":"그래프 알고리즘이란 + 최소 신장 트리(MST)","date":"May 20, 2022","update":"May 20, 2022","tags":["Algorithm","MST","그래프","크루스칼","프림"],"series":"Algorithm"},"fields":{"slug":"/graph-mst/","readingTime":{"minutes":7.665}}},"seriesList":{"edges":[{"node":{"id":"f95fc217-b9c9-5985-943d-f6db2fd56a30","fields":{"slug":"/programmers-tips-town/"},"frontmatter":{"title":"프로그래머스 2017 팁스타운 - 짝지어 제거하기"}}},{"node":{"id":"de9cf818-57cf-5617-b6f9-aa87e585afa9","fields":{"slug":"/programmers-kakao-blind-2020-1/"},"frontmatter":{"title":"프로그래머스 2020 KAKAO BLIND RECRUITMENT - 괄호 변환"}}},{"node":{"id":"17ca645f-dd9f-516b-aa44-9221aa906278","fields":{"slug":"/programmers-kakao-blind-2020-2/"},"frontmatter":{"title":"프로그래머스 2022 KAKAO RECRUITMENT - 신고 결과 받기"}}},{"node":{"id":"6b276284-ed62-5856-a5e2-c4cabf52acc9","fields":{"slug":"/programmers-kakao-blind-2020-3/"},"frontmatter":{"title":"프로그래머스 2022 KAKAO RECRUITMENT - k진수에서 소수 개수 구하기"}}},{"node":{"id":"e39e5fd5-6c40-5260-b245-d291e7d62b55","fields":{"slug":"/programmers-kakao-blind-2018-1/"},"frontmatter":{"title":"프로그래머스 2018 KAKAO RECRUITMENT - [1차]캐시"}}},{"node":{"id":"243a7274-df6b-570a-8a1e-05e4f556f787","fields":{"slug":"/programmers-kakao-blind-2021-1/"},"frontmatter":{"title":"프로그래머스 2021 KAKAO BLIND RECRUITMENT - 순위 검색"}}},{"node":{"id":"7241a8e0-c224-55a5-a6b1-8136b4f2356c","fields":{"slug":"/brute-force/"},"frontmatter":{"title":"알고리즘 완전탐색(Exhaustive search)이란"}}},{"node":{"id":"052ebb4e-897f-5992-bab6-cd7e92036341","fields":{"slug":"/greedy/"},"frontmatter":{"title":"그리디 알고리즘(Greedy Algorithm)에 대해"}}},{"node":{"id":"f808b5c3-3d94-5f20-a7cc-a1441209d3e6","fields":{"slug":"/dfs-bfs/"},"frontmatter":{"title":"알고리즘 DFS/BFS 탐색 방법 알아보기"}}},{"node":{"id":"aa2be475-c199-5487-bf60-b883bea887af","fields":{"slug":"/dynamic-programming/"},"frontmatter":{"title":"알고리즘 Dynamic Programming(동적 프로그래밍) 살펴보기"}}},{"node":{"id":"459edbb5-9a63-5390-9b2e-331fa9d3d4ad","fields":{"slug":"/graph-mst/"},"frontmatter":{"title":"그래프 알고리즘이란 + 최소 신장 트리(MST)"}}},{"node":{"id":"67819626-dcdc-5ece-bab4-311c5c8f6097","fields":{"slug":"/graph-sortest-path/"},"frontmatter":{"title":"그래프 최단거리 구하기"}}}]},"previous":{"fields":{"slug":"/dynamic-programming/"},"frontmatter":{"title":"알고리즘 Dynamic Programming(동적 프로그래밍) 살펴보기"}},"next":{"fields":{"slug":"/graph-sortest-path/"},"frontmatter":{"title":"그래프 최단거리 구하기"}}},"pageContext":{"id":"459edbb5-9a63-5390-9b2e-331fa9d3d4ad","series":"Algorithm","previousPostId":"aa2be475-c199-5487-bf60-b883bea887af","nextPostId":"67819626-dcdc-5ece-bab4-311c5c8f6097"}},"staticQueryHashes":[],"slicesMap":{}}